// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: public_api_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_public_5fapi_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_public_5fapi_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_public_5fapi_5ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_public_5fapi_5ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[34]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_public_5fapi_5ftypes_2eproto;
class ArmApiControlCommand;
struct ArmApiControlCommandDefaultTypeInternal;
extern ArmApiControlCommandDefaultTypeInternal _ArmApiControlCommand_default_instance_;
class ArmApiFreeDragCommand;
struct ArmApiFreeDragCommandDefaultTypeInternal;
extern ArmApiFreeDragCommandDefaultTypeInternal _ArmApiFreeDragCommand_default_instance_;
class ArmApiZeroCurrentCommand;
struct ArmApiZeroCurrentCommandDefaultTypeInternal;
extern ArmApiZeroCurrentCommandDefaultTypeInternal _ArmApiZeroCurrentCommand_default_instance_;
class ArmCommand;
struct ArmCommandDefaultTypeInternal;
extern ArmCommandDefaultTypeInternal _ArmCommand_default_instance_;
class ArmExclusiveCommand;
struct ArmExclusiveCommandDefaultTypeInternal;
extern ArmExclusiveCommandDefaultTypeInternal _ArmExclusiveCommand_default_instance_;
class ArmSharedCommand;
struct ArmSharedCommandDefaultTypeInternal;
extern ArmSharedCommandDefaultTypeInternal _ArmSharedCommand_default_instance_;
class ArmStatus;
struct ArmStatusDefaultTypeInternal;
extern ArmStatusDefaultTypeInternal _ArmStatus_default_instance_;
class BaseCommand;
struct BaseCommandDefaultTypeInternal;
extern BaseCommandDefaultTypeInternal _BaseCommand_default_instance_;
class BaseEstimatedOdometry;
struct BaseEstimatedOdometryDefaultTypeInternal;
extern BaseEstimatedOdometryDefaultTypeInternal _BaseEstimatedOdometry_default_instance_;
class BaseStatus;
struct BaseStatusDefaultTypeInternal;
extern BaseStatusDefaultTypeInternal _BaseStatus_default_instance_;
class EnableKcp;
struct EnableKcpDefaultTypeInternal;
extern EnableKcpDefaultTypeInternal _EnableKcp_default_instance_;
class GamepadRead;
struct GamepadReadDefaultTypeInternal;
extern GamepadReadDefaultTypeInternal _GamepadRead_default_instance_;
class HandCommand;
struct HandCommandDefaultTypeInternal;
extern HandCommandDefaultTypeInternal _HandCommand_default_instance_;
class HandStatus;
struct HandStatusDefaultTypeInternal;
extern HandStatusDefaultTypeInternal _HandStatus_default_instance_;
class ImuAcceleration;
struct ImuAccelerationDefaultTypeInternal;
extern ImuAccelerationDefaultTypeInternal _ImuAcceleration_default_instance_;
class ImuAngularVelocity;
struct ImuAngularVelocityDefaultTypeInternal;
extern ImuAngularVelocityDefaultTypeInternal _ImuAngularVelocity_default_instance_;
class ImuData;
struct ImuDataDefaultTypeInternal;
extern ImuDataDefaultTypeInternal _ImuData_default_instance_;
class ImuQuaternion;
struct ImuQuaternionDefaultTypeInternal;
extern ImuQuaternionDefaultTypeInternal _ImuQuaternion_default_instance_;
class KcpConfig;
struct KcpConfigDefaultTypeInternal;
extern KcpConfigDefaultTypeInternal _KcpConfig_default_instance_;
class KcpServerStatus;
struct KcpServerStatusDefaultTypeInternal;
extern KcpServerStatusDefaultTypeInternal _KcpServerStatus_default_instance_;
class LinearLiftCommand;
struct LinearLiftCommandDefaultTypeInternal;
extern LinearLiftCommandDefaultTypeInternal _LinearLiftCommand_default_instance_;
class LinearLiftStatus;
struct LinearLiftStatusDefaultTypeInternal;
extern LinearLiftStatusDefaultTypeInternal _LinearLiftStatus_default_instance_;
class MitMotorTarget;
struct MitMotorTargetDefaultTypeInternal;
extern MitMotorTargetDefaultTypeInternal _MitMotorTarget_default_instance_;
class MotorStatus;
struct MotorStatusDefaultTypeInternal;
extern MotorStatusDefaultTypeInternal _MotorStatus_default_instance_;
class MotorTargets;
struct MotorTargetsDefaultTypeInternal;
extern MotorTargetsDefaultTypeInternal _MotorTargets_default_instance_;
class ParkingStopDetail;
struct ParkingStopDetailDefaultTypeInternal;
extern ParkingStopDetailDefaultTypeInternal _ParkingStopDetail_default_instance_;
class RotateLiftCommand;
struct RotateLiftCommandDefaultTypeInternal;
extern RotateLiftCommandDefaultTypeInternal _RotateLiftCommand_default_instance_;
class RotateLiftRuntimeConfig;
struct RotateLiftRuntimeConfigDefaultTypeInternal;
extern RotateLiftRuntimeConfigDefaultTypeInternal _RotateLiftRuntimeConfig_default_instance_;
class RotateLiftStatus;
struct RotateLiftStatusDefaultTypeInternal;
extern RotateLiftStatusDefaultTypeInternal _RotateLiftStatus_default_instance_;
class SecondaryDeviceCommand;
struct SecondaryDeviceCommandDefaultTypeInternal;
extern SecondaryDeviceCommandDefaultTypeInternal _SecondaryDeviceCommand_default_instance_;
class SecondaryDeviceStatus;
struct SecondaryDeviceStatusDefaultTypeInternal;
extern SecondaryDeviceStatusDefaultTypeInternal _SecondaryDeviceStatus_default_instance_;
class SimpleBaseMoveCommand;
struct SimpleBaseMoveCommandDefaultTypeInternal;
extern SimpleBaseMoveCommandDefaultTypeInternal _SimpleBaseMoveCommand_default_instance_;
class SingleMotorTarget;
struct SingleMotorTargetDefaultTypeInternal;
extern SingleMotorTargetDefaultTypeInternal _SingleMotorTarget_default_instance_;
class XyzSpeed;
struct XyzSpeedDefaultTypeInternal;
extern XyzSpeedDefaultTypeInternal _XyzSpeed_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ArmApiControlCommand* Arena::CreateMaybeMessage<::ArmApiControlCommand>(Arena*);
template<> ::ArmApiFreeDragCommand* Arena::CreateMaybeMessage<::ArmApiFreeDragCommand>(Arena*);
template<> ::ArmApiZeroCurrentCommand* Arena::CreateMaybeMessage<::ArmApiZeroCurrentCommand>(Arena*);
template<> ::ArmCommand* Arena::CreateMaybeMessage<::ArmCommand>(Arena*);
template<> ::ArmExclusiveCommand* Arena::CreateMaybeMessage<::ArmExclusiveCommand>(Arena*);
template<> ::ArmSharedCommand* Arena::CreateMaybeMessage<::ArmSharedCommand>(Arena*);
template<> ::ArmStatus* Arena::CreateMaybeMessage<::ArmStatus>(Arena*);
template<> ::BaseCommand* Arena::CreateMaybeMessage<::BaseCommand>(Arena*);
template<> ::BaseEstimatedOdometry* Arena::CreateMaybeMessage<::BaseEstimatedOdometry>(Arena*);
template<> ::BaseStatus* Arena::CreateMaybeMessage<::BaseStatus>(Arena*);
template<> ::EnableKcp* Arena::CreateMaybeMessage<::EnableKcp>(Arena*);
template<> ::GamepadRead* Arena::CreateMaybeMessage<::GamepadRead>(Arena*);
template<> ::HandCommand* Arena::CreateMaybeMessage<::HandCommand>(Arena*);
template<> ::HandStatus* Arena::CreateMaybeMessage<::HandStatus>(Arena*);
template<> ::ImuAcceleration* Arena::CreateMaybeMessage<::ImuAcceleration>(Arena*);
template<> ::ImuAngularVelocity* Arena::CreateMaybeMessage<::ImuAngularVelocity>(Arena*);
template<> ::ImuData* Arena::CreateMaybeMessage<::ImuData>(Arena*);
template<> ::ImuQuaternion* Arena::CreateMaybeMessage<::ImuQuaternion>(Arena*);
template<> ::KcpConfig* Arena::CreateMaybeMessage<::KcpConfig>(Arena*);
template<> ::KcpServerStatus* Arena::CreateMaybeMessage<::KcpServerStatus>(Arena*);
template<> ::LinearLiftCommand* Arena::CreateMaybeMessage<::LinearLiftCommand>(Arena*);
template<> ::LinearLiftStatus* Arena::CreateMaybeMessage<::LinearLiftStatus>(Arena*);
template<> ::MitMotorTarget* Arena::CreateMaybeMessage<::MitMotorTarget>(Arena*);
template<> ::MotorStatus* Arena::CreateMaybeMessage<::MotorStatus>(Arena*);
template<> ::MotorTargets* Arena::CreateMaybeMessage<::MotorTargets>(Arena*);
template<> ::ParkingStopDetail* Arena::CreateMaybeMessage<::ParkingStopDetail>(Arena*);
template<> ::RotateLiftCommand* Arena::CreateMaybeMessage<::RotateLiftCommand>(Arena*);
template<> ::RotateLiftRuntimeConfig* Arena::CreateMaybeMessage<::RotateLiftRuntimeConfig>(Arena*);
template<> ::RotateLiftStatus* Arena::CreateMaybeMessage<::RotateLiftStatus>(Arena*);
template<> ::SecondaryDeviceCommand* Arena::CreateMaybeMessage<::SecondaryDeviceCommand>(Arena*);
template<> ::SecondaryDeviceStatus* Arena::CreateMaybeMessage<::SecondaryDeviceStatus>(Arena*);
template<> ::SimpleBaseMoveCommand* Arena::CreateMaybeMessage<::SimpleBaseMoveCommand>(Arena*);
template<> ::SingleMotorTarget* Arena::CreateMaybeMessage<::SingleMotorTarget>(Arena*);
template<> ::XyzSpeed* Arena::CreateMaybeMessage<::XyzSpeed>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum RobotType : int {
  RtUnknown = 0,
  RtTriggerA3 = 1,
  RtMaverX4 = 2,
  RtCustomPcwVehicle = 4,
  RtMaverL4 = 20,
  RtMaverL2 = 21,
  RtMark1DiffBBDriver = 6,
  RtArk2LrDriver = 5,
  RtMark1McnmBBDriver = 7,
  RtLotaLinearLift = 8,
  RtZeta3Lift = 13,
  RtArmSaber750d3Lr3DmDriver = 9,
  RtArmSaber750d4Lr3DmDriver = 10,
  RtArmSaber750h3Lr3DmDriver = 11,
  RtArmSaber750h4Lr3DmDriver = 12,
  RtArmSaberD6X = 14,
  RtArmSaberD7X = 15,
  RtArmArcherD6Y = 16,
  RtPureForwardOnly = 100,
  RobotType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RobotType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RobotType_IsValid(int value);
constexpr RobotType RobotType_MIN = RtUnknown;
constexpr RobotType RobotType_MAX = RtPureForwardOnly;
constexpr int RobotType_ARRAYSIZE = RobotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotType_descriptor();
template<typename T>
inline const std::string& RobotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotType_descriptor(), enum_t_value);
}
inline bool RobotType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotType>(
    RobotType_descriptor(), name, value);
}
enum SecondaryDeviceType : int {
  SdtUnknown = 0,
  SdtHandGp100 = 1,
  SdtGamepad = 2,
  SdtImuY200 = 3,
  SecondaryDeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SecondaryDeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SecondaryDeviceType_IsValid(int value);
constexpr SecondaryDeviceType SecondaryDeviceType_MIN = SdtUnknown;
constexpr SecondaryDeviceType SecondaryDeviceType_MAX = SdtImuY200;
constexpr int SecondaryDeviceType_ARRAYSIZE = SecondaryDeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecondaryDeviceType_descriptor();
template<typename T>
inline const std::string& SecondaryDeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecondaryDeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecondaryDeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecondaryDeviceType_descriptor(), enum_t_value);
}
inline bool SecondaryDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecondaryDeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecondaryDeviceType>(
    SecondaryDeviceType_descriptor(), name, value);
}
enum BaseState : int {
  BsParked = 0,
  BsAlgrithmControl = 1,
  BsOvertakeSpeedControl = 2,
  BsOvertakeZeroResistanceControl = 3,
  BsEmergencyStop = 4,
  BaseState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BaseState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BaseState_IsValid(int value);
constexpr BaseState BaseState_MIN = BsParked;
constexpr BaseState BaseState_MAX = BsEmergencyStop;
constexpr int BaseState_ARRAYSIZE = BaseState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BaseState_descriptor();
template<typename T>
inline const std::string& BaseState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BaseState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BaseState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BaseState_descriptor(), enum_t_value);
}
inline bool BaseState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BaseState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BaseState>(
    BaseState_descriptor(), name, value);
}
enum LiftState : int {
  LsBrake = 0,
  LsCalibrating = 1,
  LsAlgrithmControl = 2,
  LsOvertakeControl = 3,
  LsEmergencyStop = 4,
  LiftState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LiftState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LiftState_IsValid(int value);
constexpr LiftState LiftState_MIN = LsBrake;
constexpr LiftState LiftState_MAX = LsEmergencyStop;
constexpr int LiftState_ARRAYSIZE = LiftState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LiftState_descriptor();
template<typename T>
inline const std::string& LiftState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LiftState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LiftState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LiftState_descriptor(), enum_t_value);
}
inline bool LiftState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LiftState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LiftState>(
    LiftState_descriptor(), name, value);
}
enum ReportFrequency : int {
  Rf1000Hz = 0,
  Rf500Hz = 3,
  Rf250Hz = 4,
  Rf100Hz = 1,
  Rf50Hz = 2,
  Rf1Hz = 5,
  ReportFrequency_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ReportFrequency_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ReportFrequency_IsValid(int value);
constexpr ReportFrequency ReportFrequency_MIN = Rf1000Hz;
constexpr ReportFrequency ReportFrequency_MAX = Rf1Hz;
constexpr int ReportFrequency_ARRAYSIZE = ReportFrequency_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReportFrequency_descriptor();
template<typename T>
inline const std::string& ReportFrequency_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReportFrequency>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReportFrequency_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReportFrequency_descriptor(), enum_t_value);
}
inline bool ReportFrequency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReportFrequency* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReportFrequency>(
    ReportFrequency_descriptor(), name, value);
}
enum ParkingStopCategory : int {
  PscEmergencyStopButton = 0,
  PscMotorHasError = 1,
  PscBatteryProtection = 2,
  PscGamepadTriggered = 3,
  PscUnknownParkingStopCategory = 4,
  PscAPICommunicationTimeout = 5,
  PscLimitSwitchTriggered = 6,
  PscBmsTimeout = 7,
  ParkingStopCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParkingStopCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParkingStopCategory_IsValid(int value);
constexpr ParkingStopCategory ParkingStopCategory_MIN = PscEmergencyStopButton;
constexpr ParkingStopCategory ParkingStopCategory_MAX = PscBmsTimeout;
constexpr int ParkingStopCategory_ARRAYSIZE = ParkingStopCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParkingStopCategory_descriptor();
template<typename T>
inline const std::string& ParkingStopCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParkingStopCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParkingStopCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParkingStopCategory_descriptor(), enum_t_value);
}
inline bool ParkingStopCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParkingStopCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParkingStopCategory>(
    ParkingStopCategory_descriptor(), name, value);
}
enum WarningCategory : int {
  WcUnknownWarningCategory = 0,
  WcBatteryLow = 1,
  WarningCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WarningCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WarningCategory_IsValid(int value);
constexpr WarningCategory WarningCategory_MIN = WcUnknownWarningCategory;
constexpr WarningCategory WarningCategory_MAX = WcBatteryLow;
constexpr int WarningCategory_ARRAYSIZE = WarningCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WarningCategory_descriptor();
template<typename T>
inline const std::string& WarningCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WarningCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WarningCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WarningCategory_descriptor(), enum_t_value);
}
inline bool WarningCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WarningCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WarningCategory>(
    WarningCategory_descriptor(), name, value);
}
enum MotorError : int {
  MeCommunicationError = 0,
  MeOverCurrent = 1,
  MeOverVoltage = 2,
  MeUnderVoltage = 3,
  MeMotorOverTemperature = 4,
  MeDriverOverTemperature = 5,
  MeGeneralError = 6,
  MotorError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MotorError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MotorError_IsValid(int value);
constexpr MotorError MotorError_MIN = MeCommunicationError;
constexpr MotorError MotorError_MAX = MeGeneralError;
constexpr int MotorError_ARRAYSIZE = MotorError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotorError_descriptor();
template<typename T>
inline const std::string& MotorError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotorError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotorError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotorError_descriptor(), enum_t_value);
}
inline bool MotorError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotorError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotorError>(
    MotorError_descriptor(), name, value);
}
// ===================================================================

class BaseEstimatedOdometry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseEstimatedOdometry) */ {
 public:
  inline BaseEstimatedOdometry() : BaseEstimatedOdometry(nullptr) {}
  ~BaseEstimatedOdometry() override;
  explicit constexpr BaseEstimatedOdometry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseEstimatedOdometry(const BaseEstimatedOdometry& from);
  BaseEstimatedOdometry(BaseEstimatedOdometry&& from) noexcept
    : BaseEstimatedOdometry() {
    *this = ::std::move(from);
  }

  inline BaseEstimatedOdometry& operator=(const BaseEstimatedOdometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseEstimatedOdometry& operator=(BaseEstimatedOdometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseEstimatedOdometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseEstimatedOdometry* internal_default_instance() {
    return reinterpret_cast<const BaseEstimatedOdometry*>(
               &_BaseEstimatedOdometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BaseEstimatedOdometry& a, BaseEstimatedOdometry& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseEstimatedOdometry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseEstimatedOdometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseEstimatedOdometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseEstimatedOdometry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseEstimatedOdometry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaseEstimatedOdometry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseEstimatedOdometry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseEstimatedOdometry";
  }
  protected:
  explicit BaseEstimatedOdometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedXFieldNumber = 1,
    kSpeedYFieldNumber = 2,
    kPosXFieldNumber = 4,
    kPosYFieldNumber = 5,
    kPosZFieldNumber = 6,
    kSpeedZFieldNumber = 3,
  };
  // float speed_x = 1;
  void clear_speed_x();
  float speed_x() const;
  void set_speed_x(float value);
  private:
  float _internal_speed_x() const;
  void _internal_set_speed_x(float value);
  public:

  // float speed_y = 2;
  void clear_speed_y();
  float speed_y() const;
  void set_speed_y(float value);
  private:
  float _internal_speed_y() const;
  void _internal_set_speed_y(float value);
  public:

  // double pos_x = 4;
  void clear_pos_x();
  double pos_x() const;
  void set_pos_x(double value);
  private:
  double _internal_pos_x() const;
  void _internal_set_pos_x(double value);
  public:

  // double pos_y = 5;
  void clear_pos_y();
  double pos_y() const;
  void set_pos_y(double value);
  private:
  double _internal_pos_y() const;
  void _internal_set_pos_y(double value);
  public:

  // double pos_z = 6;
  void clear_pos_z();
  double pos_z() const;
  void set_pos_z(double value);
  private:
  double _internal_pos_z() const;
  void _internal_set_pos_z(double value);
  public:

  // float speed_z = 3;
  void clear_speed_z();
  float speed_z() const;
  void set_speed_z(float value);
  private:
  float _internal_speed_z() const;
  void _internal_set_speed_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:BaseEstimatedOdometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float speed_x_;
  float speed_y_;
  double pos_x_;
  double pos_y_;
  double pos_z_;
  float speed_z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class BaseStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseStatus) */ {
 public:
  inline BaseStatus() : BaseStatus(nullptr) {}
  ~BaseStatus() override;
  explicit constexpr BaseStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseStatus(const BaseStatus& from);
  BaseStatus(BaseStatus&& from) noexcept
    : BaseStatus() {
    *this = ::std::move(from);
  }

  inline BaseStatus& operator=(const BaseStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseStatus& operator=(BaseStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseStatus* internal_default_instance() {
    return reinterpret_cast<const BaseStatus*>(
               &_BaseStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BaseStatus& a, BaseStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaseStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseStatus";
  }
  protected:
  explicit BaseStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorStatusFieldNumber = 5,
    kParkingStopDetailFieldNumber = 11,
    kEstimatedOdometryFieldNumber = 13,
    kStateFieldNumber = 1,
    kBatteryVoltageFieldNumber = 3,
    kBatteryThousandthFieldNumber = 4,
    kSessionHolderFieldNumber = 6,
    kApiControlInitializedFieldNumber = 2,
    kBatteryChargingFieldNumber = 10,
    kWarningFieldNumber = 12,
  };
  // repeated .MotorStatus motor_status = 5;
  int motor_status_size() const;
  private:
  int _internal_motor_status_size() const;
  public:
  void clear_motor_status();
  ::MotorStatus* mutable_motor_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
      mutable_motor_status();
  private:
  const ::MotorStatus& _internal_motor_status(int index) const;
  ::MotorStatus* _internal_add_motor_status();
  public:
  const ::MotorStatus& motor_status(int index) const;
  ::MotorStatus* add_motor_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
      motor_status() const;

  // optional .ParkingStopDetail parking_stop_detail = 11;
  bool has_parking_stop_detail() const;
  private:
  bool _internal_has_parking_stop_detail() const;
  public:
  void clear_parking_stop_detail();
  const ::ParkingStopDetail& parking_stop_detail() const;
  PROTOBUF_NODISCARD ::ParkingStopDetail* release_parking_stop_detail();
  ::ParkingStopDetail* mutable_parking_stop_detail();
  void set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail);
  private:
  const ::ParkingStopDetail& _internal_parking_stop_detail() const;
  ::ParkingStopDetail* _internal_mutable_parking_stop_detail();
  public:
  void unsafe_arena_set_allocated_parking_stop_detail(
      ::ParkingStopDetail* parking_stop_detail);
  ::ParkingStopDetail* unsafe_arena_release_parking_stop_detail();

  // optional .BaseEstimatedOdometry estimated_odometry = 13;
  bool has_estimated_odometry() const;
  private:
  bool _internal_has_estimated_odometry() const;
  public:
  void clear_estimated_odometry();
  const ::BaseEstimatedOdometry& estimated_odometry() const;
  PROTOBUF_NODISCARD ::BaseEstimatedOdometry* release_estimated_odometry();
  ::BaseEstimatedOdometry* mutable_estimated_odometry();
  void set_allocated_estimated_odometry(::BaseEstimatedOdometry* estimated_odometry);
  private:
  const ::BaseEstimatedOdometry& _internal_estimated_odometry() const;
  ::BaseEstimatedOdometry* _internal_mutable_estimated_odometry();
  public:
  void unsafe_arena_set_allocated_estimated_odometry(
      ::BaseEstimatedOdometry* estimated_odometry);
  ::BaseEstimatedOdometry* unsafe_arena_release_estimated_odometry();

  // .BaseState state = 1;
  void clear_state();
  ::BaseState state() const;
  void set_state(::BaseState value);
  private:
  ::BaseState _internal_state() const;
  void _internal_set_state(::BaseState value);
  public:

  // float battery_voltage = 3;
  void clear_battery_voltage();
  float battery_voltage() const;
  void set_battery_voltage(float value);
  private:
  float _internal_battery_voltage() const;
  void _internal_set_battery_voltage(float value);
  public:

  // uint32 battery_thousandth = 4;
  void clear_battery_thousandth();
  uint32_t battery_thousandth() const;
  void set_battery_thousandth(uint32_t value);
  private:
  uint32_t _internal_battery_thousandth() const;
  void _internal_set_battery_thousandth(uint32_t value);
  public:

  // uint32 session_holder = 6;
  void clear_session_holder();
  uint32_t session_holder() const;
  void set_session_holder(uint32_t value);
  private:
  uint32_t _internal_session_holder() const;
  void _internal_set_session_holder(uint32_t value);
  public:

  // bool api_control_initialized = 2;
  void clear_api_control_initialized();
  bool api_control_initialized() const;
  void set_api_control_initialized(bool value);
  private:
  bool _internal_api_control_initialized() const;
  void _internal_set_api_control_initialized(bool value);
  public:

  // optional bool battery_charging = 10;
  bool has_battery_charging() const;
  private:
  bool _internal_has_battery_charging() const;
  public:
  void clear_battery_charging();
  bool battery_charging() const;
  void set_battery_charging(bool value);
  private:
  bool _internal_battery_charging() const;
  void _internal_set_battery_charging(bool value);
  public:

  // optional .WarningCategory warning = 12;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  ::WarningCategory warning() const;
  void set_warning(::WarningCategory value);
  private:
  ::WarningCategory _internal_warning() const;
  void _internal_set_warning(::WarningCategory value);
  public:

  // @@protoc_insertion_point(class_scope:BaseStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus > motor_status_;
  ::ParkingStopDetail* parking_stop_detail_;
  ::BaseEstimatedOdometry* estimated_odometry_;
  int state_;
  float battery_voltage_;
  uint32_t battery_thousandth_;
  uint32_t session_holder_;
  bool api_control_initialized_;
  bool battery_charging_;
  int warning_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class XyzSpeed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XyzSpeed) */ {
 public:
  inline XyzSpeed() : XyzSpeed(nullptr) {}
  ~XyzSpeed() override;
  explicit constexpr XyzSpeed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XyzSpeed(const XyzSpeed& from);
  XyzSpeed(XyzSpeed&& from) noexcept
    : XyzSpeed() {
    *this = ::std::move(from);
  }

  inline XyzSpeed& operator=(const XyzSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline XyzSpeed& operator=(XyzSpeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XyzSpeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const XyzSpeed* internal_default_instance() {
    return reinterpret_cast<const XyzSpeed*>(
               &_XyzSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(XyzSpeed& a, XyzSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(XyzSpeed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XyzSpeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XyzSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XyzSpeed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XyzSpeed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const XyzSpeed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XyzSpeed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XyzSpeed";
  }
  protected:
  explicit XyzSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedXFieldNumber = 1,
    kSpeedYFieldNumber = 2,
    kSpeedZFieldNumber = 3,
  };
  // float speed_x = 1;
  void clear_speed_x();
  float speed_x() const;
  void set_speed_x(float value);
  private:
  float _internal_speed_x() const;
  void _internal_set_speed_x(float value);
  public:

  // float speed_y = 2;
  void clear_speed_y();
  float speed_y() const;
  void set_speed_y(float value);
  private:
  float _internal_speed_y() const;
  void _internal_set_speed_y(float value);
  public:

  // float speed_z = 3;
  void clear_speed_z();
  float speed_z() const;
  void set_speed_z(float value);
  private:
  float _internal_speed_z() const;
  void _internal_set_speed_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:XyzSpeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float speed_x_;
  float speed_y_;
  float speed_z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SimpleBaseMoveCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SimpleBaseMoveCommand) */ {
 public:
  inline SimpleBaseMoveCommand() : SimpleBaseMoveCommand(nullptr) {}
  ~SimpleBaseMoveCommand() override;
  explicit constexpr SimpleBaseMoveCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimpleBaseMoveCommand(const SimpleBaseMoveCommand& from);
  SimpleBaseMoveCommand(SimpleBaseMoveCommand&& from) noexcept
    : SimpleBaseMoveCommand() {
    *this = ::std::move(from);
  }

  inline SimpleBaseMoveCommand& operator=(const SimpleBaseMoveCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleBaseMoveCommand& operator=(SimpleBaseMoveCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleBaseMoveCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kXyzSpeed = 1,
    kZeroResistance = 2,
    kBrake = 3,
    COMMAND_NOT_SET = 0,
  };

  static inline const SimpleBaseMoveCommand* internal_default_instance() {
    return reinterpret_cast<const SimpleBaseMoveCommand*>(
               &_SimpleBaseMoveCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SimpleBaseMoveCommand& a, SimpleBaseMoveCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleBaseMoveCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleBaseMoveCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleBaseMoveCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleBaseMoveCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimpleBaseMoveCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimpleBaseMoveCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleBaseMoveCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SimpleBaseMoveCommand";
  }
  protected:
  explicit SimpleBaseMoveCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXyzSpeedFieldNumber = 1,
    kZeroResistanceFieldNumber = 2,
    kBrakeFieldNumber = 3,
  };
  // .XyzSpeed xyz_speed = 1;
  bool has_xyz_speed() const;
  private:
  bool _internal_has_xyz_speed() const;
  public:
  void clear_xyz_speed();
  const ::XyzSpeed& xyz_speed() const;
  PROTOBUF_NODISCARD ::XyzSpeed* release_xyz_speed();
  ::XyzSpeed* mutable_xyz_speed();
  void set_allocated_xyz_speed(::XyzSpeed* xyz_speed);
  private:
  const ::XyzSpeed& _internal_xyz_speed() const;
  ::XyzSpeed* _internal_mutable_xyz_speed();
  public:
  void unsafe_arena_set_allocated_xyz_speed(
      ::XyzSpeed* xyz_speed);
  ::XyzSpeed* unsafe_arena_release_xyz_speed();

  // bool zero_resistance = 2;
  bool has_zero_resistance() const;
  private:
  bool _internal_has_zero_resistance() const;
  public:
  void clear_zero_resistance();
  bool zero_resistance() const;
  void set_zero_resistance(bool value);
  private:
  bool _internal_zero_resistance() const;
  void _internal_set_zero_resistance(bool value);
  public:

  // bool brake = 3;
  bool has_brake() const;
  private:
  bool _internal_has_brake() const;
  public:
  void clear_brake();
  bool brake() const;
  void set_brake(bool value);
  private:
  bool _internal_brake() const;
  void _internal_set_brake(bool value);
  public:

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:SimpleBaseMoveCommand)
 private:
  class _Internal;
  void set_has_xyz_speed();
  void set_has_zero_resistance();
  void set_has_brake();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::XyzSpeed* xyz_speed_;
    bool zero_resistance_;
    bool brake_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class BaseCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseCommand) */ {
 public:
  inline BaseCommand() : BaseCommand(nullptr) {}
  ~BaseCommand() override;
  explicit constexpr BaseCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseCommand(const BaseCommand& from);
  BaseCommand(BaseCommand&& from) noexcept
    : BaseCommand() {
    *this = ::std::move(from);
  }

  inline BaseCommand& operator=(const BaseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseCommand& operator=(BaseCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kApiControlInitialize = 1,
    kClearParkingStop = 2,
    kMotorTargets = 3,
    kSimpleMoveCommand = 5,
    COMMAND_NOT_SET = 0,
  };

  static inline const BaseCommand* internal_default_instance() {
    return reinterpret_cast<const BaseCommand*>(
               &_BaseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BaseCommand& a, BaseCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaseCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseCommand";
  }
  protected:
  explicit BaseCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiControlInitializeFieldNumber = 1,
    kClearParkingStopFieldNumber = 2,
    kMotorTargetsFieldNumber = 3,
    kSimpleMoveCommandFieldNumber = 5,
  };
  // bool api_control_initialize = 1;
  bool has_api_control_initialize() const;
  private:
  bool _internal_has_api_control_initialize() const;
  public:
  void clear_api_control_initialize();
  bool api_control_initialize() const;
  void set_api_control_initialize(bool value);
  private:
  bool _internal_api_control_initialize() const;
  void _internal_set_api_control_initialize(bool value);
  public:

  // bool clear_parking_stop = 2;
  bool has_clear_parking_stop() const;
  private:
  bool _internal_has_clear_parking_stop() const;
  public:
  void clear_clear_parking_stop();
  bool clear_parking_stop() const;
  void set_clear_parking_stop(bool value);
  private:
  bool _internal_clear_parking_stop() const;
  void _internal_set_clear_parking_stop(bool value);
  public:

  // .MotorTargets motor_targets = 3;
  bool has_motor_targets() const;
  private:
  bool _internal_has_motor_targets() const;
  public:
  void clear_motor_targets();
  const ::MotorTargets& motor_targets() const;
  PROTOBUF_NODISCARD ::MotorTargets* release_motor_targets();
  ::MotorTargets* mutable_motor_targets();
  void set_allocated_motor_targets(::MotorTargets* motor_targets);
  private:
  const ::MotorTargets& _internal_motor_targets() const;
  ::MotorTargets* _internal_mutable_motor_targets();
  public:
  void unsafe_arena_set_allocated_motor_targets(
      ::MotorTargets* motor_targets);
  ::MotorTargets* unsafe_arena_release_motor_targets();

  // .SimpleBaseMoveCommand simple_move_command = 5;
  bool has_simple_move_command() const;
  private:
  bool _internal_has_simple_move_command() const;
  public:
  void clear_simple_move_command();
  const ::SimpleBaseMoveCommand& simple_move_command() const;
  PROTOBUF_NODISCARD ::SimpleBaseMoveCommand* release_simple_move_command();
  ::SimpleBaseMoveCommand* mutable_simple_move_command();
  void set_allocated_simple_move_command(::SimpleBaseMoveCommand* simple_move_command);
  private:
  const ::SimpleBaseMoveCommand& _internal_simple_move_command() const;
  ::SimpleBaseMoveCommand* _internal_mutable_simple_move_command();
  public:
  void unsafe_arena_set_allocated_simple_move_command(
      ::SimpleBaseMoveCommand* simple_move_command);
  ::SimpleBaseMoveCommand* unsafe_arena_release_simple_move_command();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:BaseCommand)
 private:
  class _Internal;
  void set_has_api_control_initialize();
  void set_has_clear_parking_stop();
  void set_has_motor_targets();
  void set_has_simple_move_command();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool api_control_initialize_;
    bool clear_parking_stop_;
    ::MotorTargets* motor_targets_;
    ::SimpleBaseMoveCommand* simple_move_command_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RotateLiftStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RotateLiftStatus) */ {
 public:
  inline RotateLiftStatus() : RotateLiftStatus(nullptr) {}
  ~RotateLiftStatus() override;
  explicit constexpr RotateLiftStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotateLiftStatus(const RotateLiftStatus& from);
  RotateLiftStatus(RotateLiftStatus&& from) noexcept
    : RotateLiftStatus() {
    *this = ::std::move(from);
  }

  inline RotateLiftStatus& operator=(const RotateLiftStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateLiftStatus& operator=(RotateLiftStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotateLiftStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotateLiftStatus* internal_default_instance() {
    return reinterpret_cast<const RotateLiftStatus*>(
               &_RotateLiftStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RotateLiftStatus& a, RotateLiftStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RotateLiftStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotateLiftStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotateLiftStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotateLiftStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotateLiftStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RotateLiftStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateLiftStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RotateLiftStatus";
  }
  protected:
  explicit RotateLiftStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorStatusFieldNumber = 3,
    kMaxPosFieldNumber = 4,
    kMinPosFieldNumber = 5,
    kParkingStopDetailFieldNumber = 10,
    kCalibratedFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // repeated .MotorStatus motor_status = 3;
  int motor_status_size() const;
  private:
  int _internal_motor_status_size() const;
  public:
  void clear_motor_status();
  ::MotorStatus* mutable_motor_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
      mutable_motor_status();
  private:
  const ::MotorStatus& _internal_motor_status(int index) const;
  ::MotorStatus* _internal_add_motor_status();
  public:
  const ::MotorStatus& motor_status(int index) const;
  ::MotorStatus* add_motor_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
      motor_status() const;

  // repeated int32 max_pos = 4;
  int max_pos_size() const;
  private:
  int _internal_max_pos_size() const;
  public:
  void clear_max_pos();
  private:
  int32_t _internal_max_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_max_pos() const;
  void _internal_add_max_pos(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_max_pos();
  public:
  int32_t max_pos(int index) const;
  void set_max_pos(int index, int32_t value);
  void add_max_pos(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      max_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_max_pos();

  // repeated int32 min_pos = 5;
  int min_pos_size() const;
  private:
  int _internal_min_pos_size() const;
  public:
  void clear_min_pos();
  private:
  int32_t _internal_min_pos(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_min_pos() const;
  void _internal_add_min_pos(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_min_pos();
  public:
  int32_t min_pos(int index) const;
  void set_min_pos(int index, int32_t value);
  void add_min_pos(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      min_pos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_min_pos();

  // optional .ParkingStopDetail parking_stop_detail = 10;
  bool has_parking_stop_detail() const;
  private:
  bool _internal_has_parking_stop_detail() const;
  public:
  void clear_parking_stop_detail();
  const ::ParkingStopDetail& parking_stop_detail() const;
  PROTOBUF_NODISCARD ::ParkingStopDetail* release_parking_stop_detail();
  ::ParkingStopDetail* mutable_parking_stop_detail();
  void set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail);
  private:
  const ::ParkingStopDetail& _internal_parking_stop_detail() const;
  ::ParkingStopDetail* _internal_mutable_parking_stop_detail();
  public:
  void unsafe_arena_set_allocated_parking_stop_detail(
      ::ParkingStopDetail* parking_stop_detail);
  ::ParkingStopDetail* unsafe_arena_release_parking_stop_detail();

  // bool calibrated = 1;
  void clear_calibrated();
  bool calibrated() const;
  void set_calibrated(bool value);
  private:
  bool _internal_calibrated() const;
  void _internal_set_calibrated(bool value);
  public:

  // .LiftState state = 2;
  void clear_state();
  ::LiftState state() const;
  void set_state(::LiftState value);
  private:
  ::LiftState _internal_state() const;
  void _internal_set_state(::LiftState value);
  public:

  // @@protoc_insertion_point(class_scope:RotateLiftStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus > motor_status_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > max_pos_;
  mutable std::atomic<int> _max_pos_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > min_pos_;
  mutable std::atomic<int> _min_pos_cached_byte_size_;
  ::ParkingStopDetail* parking_stop_detail_;
  bool calibrated_;
  int state_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RotateLiftRuntimeConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RotateLiftRuntimeConfig) */ {
 public:
  inline RotateLiftRuntimeConfig() : RotateLiftRuntimeConfig(nullptr) {}
  ~RotateLiftRuntimeConfig() override;
  explicit constexpr RotateLiftRuntimeConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotateLiftRuntimeConfig(const RotateLiftRuntimeConfig& from);
  RotateLiftRuntimeConfig(RotateLiftRuntimeConfig&& from) noexcept
    : RotateLiftRuntimeConfig() {
    *this = ::std::move(from);
  }

  inline RotateLiftRuntimeConfig& operator=(const RotateLiftRuntimeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateLiftRuntimeConfig& operator=(RotateLiftRuntimeConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotateLiftRuntimeConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotateLiftRuntimeConfig* internal_default_instance() {
    return reinterpret_cast<const RotateLiftRuntimeConfig*>(
               &_RotateLiftRuntimeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RotateLiftRuntimeConfig& a, RotateLiftRuntimeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RotateLiftRuntimeConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotateLiftRuntimeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotateLiftRuntimeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotateLiftRuntimeConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotateLiftRuntimeConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RotateLiftRuntimeConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateLiftRuntimeConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RotateLiftRuntimeConfig";
  }
  protected:
  explicit RotateLiftRuntimeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosModeMaxSpeedFieldNumber = 1,
  };
  // repeated double pos_mode_max_speed = 1;
  int pos_mode_max_speed_size() const;
  private:
  int _internal_pos_mode_max_speed_size() const;
  public:
  void clear_pos_mode_max_speed();
  private:
  double _internal_pos_mode_max_speed(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_pos_mode_max_speed() const;
  void _internal_add_pos_mode_max_speed(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_pos_mode_max_speed();
  public:
  double pos_mode_max_speed(int index) const;
  void set_pos_mode_max_speed(int index, double value);
  void add_pos_mode_max_speed(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      pos_mode_max_speed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_pos_mode_max_speed();

  // @@protoc_insertion_point(class_scope:RotateLiftRuntimeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > pos_mode_max_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class RotateLiftCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RotateLiftCommand) */ {
 public:
  inline RotateLiftCommand() : RotateLiftCommand(nullptr) {}
  ~RotateLiftCommand() override;
  explicit constexpr RotateLiftCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RotateLiftCommand(const RotateLiftCommand& from);
  RotateLiftCommand(RotateLiftCommand&& from) noexcept
    : RotateLiftCommand() {
    *this = ::std::move(from);
  }

  inline RotateLiftCommand& operator=(const RotateLiftCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateLiftCommand& operator=(RotateLiftCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotateLiftCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kCalibrate = 1,
    kMotorTargets = 2,
    kRuntimeConfig = 3,
    COMMAND_NOT_SET = 0,
  };

  static inline const RotateLiftCommand* internal_default_instance() {
    return reinterpret_cast<const RotateLiftCommand*>(
               &_RotateLiftCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RotateLiftCommand& a, RotateLiftCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RotateLiftCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotateLiftCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotateLiftCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotateLiftCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RotateLiftCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RotateLiftCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateLiftCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RotateLiftCommand";
  }
  protected:
  explicit RotateLiftCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCalibrateFieldNumber = 1,
    kMotorTargetsFieldNumber = 2,
    kRuntimeConfigFieldNumber = 3,
  };
  // bool calibrate = 1;
  bool has_calibrate() const;
  private:
  bool _internal_has_calibrate() const;
  public:
  void clear_calibrate();
  bool calibrate() const;
  void set_calibrate(bool value);
  private:
  bool _internal_calibrate() const;
  void _internal_set_calibrate(bool value);
  public:

  // .MotorTargets motor_targets = 2;
  bool has_motor_targets() const;
  private:
  bool _internal_has_motor_targets() const;
  public:
  void clear_motor_targets();
  const ::MotorTargets& motor_targets() const;
  PROTOBUF_NODISCARD ::MotorTargets* release_motor_targets();
  ::MotorTargets* mutable_motor_targets();
  void set_allocated_motor_targets(::MotorTargets* motor_targets);
  private:
  const ::MotorTargets& _internal_motor_targets() const;
  ::MotorTargets* _internal_mutable_motor_targets();
  public:
  void unsafe_arena_set_allocated_motor_targets(
      ::MotorTargets* motor_targets);
  ::MotorTargets* unsafe_arena_release_motor_targets();

  // .RotateLiftRuntimeConfig runtime_config = 3;
  bool has_runtime_config() const;
  private:
  bool _internal_has_runtime_config() const;
  public:
  void clear_runtime_config();
  const ::RotateLiftRuntimeConfig& runtime_config() const;
  PROTOBUF_NODISCARD ::RotateLiftRuntimeConfig* release_runtime_config();
  ::RotateLiftRuntimeConfig* mutable_runtime_config();
  void set_allocated_runtime_config(::RotateLiftRuntimeConfig* runtime_config);
  private:
  const ::RotateLiftRuntimeConfig& _internal_runtime_config() const;
  ::RotateLiftRuntimeConfig* _internal_mutable_runtime_config();
  public:
  void unsafe_arena_set_allocated_runtime_config(
      ::RotateLiftRuntimeConfig* runtime_config);
  ::RotateLiftRuntimeConfig* unsafe_arena_release_runtime_config();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:RotateLiftCommand)
 private:
  class _Internal;
  void set_has_calibrate();
  void set_has_motor_targets();
  void set_has_runtime_config();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool calibrate_;
    ::MotorTargets* motor_targets_;
    ::RotateLiftRuntimeConfig* runtime_config_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class LinearLiftStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LinearLiftStatus) */ {
 public:
  inline LinearLiftStatus() : LinearLiftStatus(nullptr) {}
  ~LinearLiftStatus() override;
  explicit constexpr LinearLiftStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearLiftStatus(const LinearLiftStatus& from);
  LinearLiftStatus(LinearLiftStatus&& from) noexcept
    : LinearLiftStatus() {
    *this = ::std::move(from);
  }

  inline LinearLiftStatus& operator=(const LinearLiftStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearLiftStatus& operator=(LinearLiftStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearLiftStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearLiftStatus* internal_default_instance() {
    return reinterpret_cast<const LinearLiftStatus*>(
               &_LinearLiftStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LinearLiftStatus& a, LinearLiftStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearLiftStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearLiftStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearLiftStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearLiftStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinearLiftStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinearLiftStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearLiftStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LinearLiftStatus";
  }
  protected:
  explicit LinearLiftStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingStopDetailFieldNumber = 10,
    kMaxPosFieldNumber = 3,
    kStateFieldNumber = 2,
    kPulsePerRotationFieldNumber = 5,
    kCurrentPosFieldNumber = 4,
    kMaxSpeedFieldNumber = 6,
    kCalibratedFieldNumber = 1,
    kCustomButtonPressedFieldNumber = 11,
    kSpeedFieldNumber = 7,
  };
  // optional .ParkingStopDetail parking_stop_detail = 10;
  bool has_parking_stop_detail() const;
  private:
  bool _internal_has_parking_stop_detail() const;
  public:
  void clear_parking_stop_detail();
  const ::ParkingStopDetail& parking_stop_detail() const;
  PROTOBUF_NODISCARD ::ParkingStopDetail* release_parking_stop_detail();
  ::ParkingStopDetail* mutable_parking_stop_detail();
  void set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail);
  private:
  const ::ParkingStopDetail& _internal_parking_stop_detail() const;
  ::ParkingStopDetail* _internal_mutable_parking_stop_detail();
  public:
  void unsafe_arena_set_allocated_parking_stop_detail(
      ::ParkingStopDetail* parking_stop_detail);
  ::ParkingStopDetail* unsafe_arena_release_parking_stop_detail();

  // int64 max_pos = 3;
  void clear_max_pos();
  int64_t max_pos() const;
  void set_max_pos(int64_t value);
  private:
  int64_t _internal_max_pos() const;
  void _internal_set_max_pos(int64_t value);
  public:

  // .LiftState state = 2;
  void clear_state();
  ::LiftState state() const;
  void set_state(::LiftState value);
  private:
  ::LiftState _internal_state() const;
  void _internal_set_state(::LiftState value);
  public:

  // uint32 pulse_per_rotation = 5;
  void clear_pulse_per_rotation();
  uint32_t pulse_per_rotation() const;
  void set_pulse_per_rotation(uint32_t value);
  private:
  uint32_t _internal_pulse_per_rotation() const;
  void _internal_set_pulse_per_rotation(uint32_t value);
  public:

  // int64 current_pos = 4;
  void clear_current_pos();
  int64_t current_pos() const;
  void set_current_pos(int64_t value);
  private:
  int64_t _internal_current_pos() const;
  void _internal_set_current_pos(int64_t value);
  public:

  // uint32 max_speed = 6;
  void clear_max_speed();
  uint32_t max_speed() const;
  void set_max_speed(uint32_t value);
  private:
  uint32_t _internal_max_speed() const;
  void _internal_set_max_speed(uint32_t value);
  public:

  // bool calibrated = 1;
  void clear_calibrated();
  bool calibrated() const;
  void set_calibrated(bool value);
  private:
  bool _internal_calibrated() const;
  void _internal_set_calibrated(bool value);
  public:

  // optional bool custom_button_pressed = 11;
  bool has_custom_button_pressed() const;
  private:
  bool _internal_has_custom_button_pressed() const;
  public:
  void clear_custom_button_pressed();
  bool custom_button_pressed() const;
  void set_custom_button_pressed(bool value);
  private:
  bool _internal_custom_button_pressed() const;
  void _internal_set_custom_button_pressed(bool value);
  public:

  // uint32 speed = 7;
  void clear_speed();
  uint32_t speed() const;
  void set_speed(uint32_t value);
  private:
  uint32_t _internal_speed() const;
  void _internal_set_speed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LinearLiftStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ParkingStopDetail* parking_stop_detail_;
  int64_t max_pos_;
  int state_;
  uint32_t pulse_per_rotation_;
  int64_t current_pos_;
  uint32_t max_speed_;
  bool calibrated_;
  bool custom_button_pressed_;
  uint32_t speed_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class LinearLiftCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LinearLiftCommand) */ {
 public:
  inline LinearLiftCommand() : LinearLiftCommand(nullptr) {}
  ~LinearLiftCommand() override;
  explicit constexpr LinearLiftCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearLiftCommand(const LinearLiftCommand& from);
  LinearLiftCommand(LinearLiftCommand&& from) noexcept
    : LinearLiftCommand() {
    *this = ::std::move(from);
  }

  inline LinearLiftCommand& operator=(const LinearLiftCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearLiftCommand& operator=(LinearLiftCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearLiftCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kCalibrate = 1,
    kTargetPos = 2,
    kBrake = 3,
    kSetSpeed = 4,
    COMMAND_NOT_SET = 0,
  };

  static inline const LinearLiftCommand* internal_default_instance() {
    return reinterpret_cast<const LinearLiftCommand*>(
               &_LinearLiftCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LinearLiftCommand& a, LinearLiftCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearLiftCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearLiftCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearLiftCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearLiftCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinearLiftCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinearLiftCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearLiftCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LinearLiftCommand";
  }
  protected:
  explicit LinearLiftCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCalibrateFieldNumber = 1,
    kTargetPosFieldNumber = 2,
    kBrakeFieldNumber = 3,
    kSetSpeedFieldNumber = 4,
  };
  // bool calibrate = 1;
  bool has_calibrate() const;
  private:
  bool _internal_has_calibrate() const;
  public:
  void clear_calibrate();
  bool calibrate() const;
  void set_calibrate(bool value);
  private:
  bool _internal_calibrate() const;
  void _internal_set_calibrate(bool value);
  public:

  // int64 target_pos = 2;
  bool has_target_pos() const;
  private:
  bool _internal_has_target_pos() const;
  public:
  void clear_target_pos();
  int64_t target_pos() const;
  void set_target_pos(int64_t value);
  private:
  int64_t _internal_target_pos() const;
  void _internal_set_target_pos(int64_t value);
  public:

  // bool brake = 3;
  bool has_brake() const;
  private:
  bool _internal_has_brake() const;
  public:
  void clear_brake();
  bool brake() const;
  void set_brake(bool value);
  private:
  bool _internal_brake() const;
  void _internal_set_brake(bool value);
  public:

  // uint32 set_speed = 4;
  bool has_set_speed() const;
  private:
  bool _internal_has_set_speed() const;
  public:
  void clear_set_speed();
  uint32_t set_speed() const;
  void set_set_speed(uint32_t value);
  private:
  uint32_t _internal_set_speed() const;
  void _internal_set_set_speed(uint32_t value);
  public:

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:LinearLiftCommand)
 private:
  class _Internal;
  void set_has_calibrate();
  void set_has_target_pos();
  void set_has_brake();
  void set_has_set_speed();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool calibrate_;
    int64_t target_pos_;
    bool brake_;
    uint32_t set_speed_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ArmStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmStatus) */ {
 public:
  inline ArmStatus() : ArmStatus(nullptr) {}
  ~ArmStatus() override;
  explicit constexpr ArmStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmStatus(const ArmStatus& from);
  ArmStatus(ArmStatus&& from) noexcept
    : ArmStatus() {
    *this = ::std::move(from);
  }

  inline ArmStatus& operator=(const ArmStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmStatus& operator=(ArmStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArmStatus* internal_default_instance() {
    return reinterpret_cast<const ArmStatus*>(
               &_ArmStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ArmStatus& a, ArmStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArmStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArmStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmStatus";
  }
  protected:
  explicit ArmStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorStatusFieldNumber = 4,
    kParkingStopDetailFieldNumber = 5,
    kApiControlInitializedFieldNumber = 1,
    kCalibratedFieldNumber = 3,
    kSessionHolderFieldNumber = 6,
  };
  // repeated .MotorStatus motor_status = 4;
  int motor_status_size() const;
  private:
  int _internal_motor_status_size() const;
  public:
  void clear_motor_status();
  ::MotorStatus* mutable_motor_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
      mutable_motor_status();
  private:
  const ::MotorStatus& _internal_motor_status(int index) const;
  ::MotorStatus* _internal_add_motor_status();
  public:
  const ::MotorStatus& motor_status(int index) const;
  ::MotorStatus* add_motor_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
      motor_status() const;

  // optional .ParkingStopDetail parking_stop_detail = 5;
  bool has_parking_stop_detail() const;
  private:
  bool _internal_has_parking_stop_detail() const;
  public:
  void clear_parking_stop_detail();
  const ::ParkingStopDetail& parking_stop_detail() const;
  PROTOBUF_NODISCARD ::ParkingStopDetail* release_parking_stop_detail();
  ::ParkingStopDetail* mutable_parking_stop_detail();
  void set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail);
  private:
  const ::ParkingStopDetail& _internal_parking_stop_detail() const;
  ::ParkingStopDetail* _internal_mutable_parking_stop_detail();
  public:
  void unsafe_arena_set_allocated_parking_stop_detail(
      ::ParkingStopDetail* parking_stop_detail);
  ::ParkingStopDetail* unsafe_arena_release_parking_stop_detail();

  // bool api_control_initialized = 1;
  void clear_api_control_initialized();
  bool api_control_initialized() const;
  void set_api_control_initialized(bool value);
  private:
  bool _internal_api_control_initialized() const;
  void _internal_set_api_control_initialized(bool value);
  public:

  // bool calibrated = 3;
  void clear_calibrated();
  bool calibrated() const;
  void set_calibrated(bool value);
  private:
  bool _internal_calibrated() const;
  void _internal_set_calibrated(bool value);
  public:

  // uint32 session_holder = 6;
  void clear_session_holder();
  uint32_t session_holder() const;
  void set_session_holder(uint32_t value);
  private:
  uint32_t _internal_session_holder() const;
  void _internal_set_session_holder(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ArmStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus > motor_status_;
  ::ParkingStopDetail* parking_stop_detail_;
  bool api_control_initialized_;
  bool calibrated_;
  uint32_t session_holder_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class HandStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HandStatus) */ {
 public:
  inline HandStatus() : HandStatus(nullptr) {}
  ~HandStatus() override;
  explicit constexpr HandStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandStatus(const HandStatus& from);
  HandStatus(HandStatus&& from) noexcept
    : HandStatus() {
    *this = ::std::move(from);
  }

  inline HandStatus& operator=(const HandStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandStatus& operator=(HandStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandStatus* internal_default_instance() {
    return reinterpret_cast<const HandStatus*>(
               &_HandStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HandStatus& a, HandStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(HandStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HandStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HandStatus";
  }
  protected:
  explicit HandStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorStatusFieldNumber = 2,
  };
  // repeated .MotorStatus motor_status = 2;
  int motor_status_size() const;
  private:
  int _internal_motor_status_size() const;
  public:
  void clear_motor_status();
  ::MotorStatus* mutable_motor_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
      mutable_motor_status();
  private:
  const ::MotorStatus& _internal_motor_status(int index) const;
  ::MotorStatus* _internal_add_motor_status();
  public:
  const ::MotorStatus& motor_status(int index) const;
  ::MotorStatus* add_motor_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
      motor_status() const;

  // @@protoc_insertion_point(class_scope:HandStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus > motor_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class HandCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HandCommand) */ {
 public:
  inline HandCommand() : HandCommand(nullptr) {}
  ~HandCommand() override;
  explicit constexpr HandCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandCommand(const HandCommand& from);
  HandCommand(HandCommand&& from) noexcept
    : HandCommand() {
    *this = ::std::move(from);
  }

  inline HandCommand& operator=(const HandCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandCommand& operator=(HandCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandCommand* internal_default_instance() {
    return reinterpret_cast<const HandCommand*>(
               &_HandCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HandCommand& a, HandCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(HandCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HandCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HandCommand";
  }
  protected:
  explicit HandCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorTargetsFieldNumber = 1,
  };
  // .MotorTargets motor_targets = 1;
  bool has_motor_targets() const;
  private:
  bool _internal_has_motor_targets() const;
  public:
  void clear_motor_targets();
  const ::MotorTargets& motor_targets() const;
  PROTOBUF_NODISCARD ::MotorTargets* release_motor_targets();
  ::MotorTargets* mutable_motor_targets();
  void set_allocated_motor_targets(::MotorTargets* motor_targets);
  private:
  const ::MotorTargets& _internal_motor_targets() const;
  ::MotorTargets* _internal_mutable_motor_targets();
  public:
  void unsafe_arena_set_allocated_motor_targets(
      ::MotorTargets* motor_targets);
  ::MotorTargets* unsafe_arena_release_motor_targets();

  // @@protoc_insertion_point(class_scope:HandCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::MotorTargets* motor_targets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ArmApiFreeDragCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ArmApiFreeDragCommand) */ {
 public:
  inline ArmApiFreeDragCommand() : ArmApiFreeDragCommand(nullptr) {}
  explicit constexpr ArmApiFreeDragCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmApiFreeDragCommand(const ArmApiFreeDragCommand& from);
  ArmApiFreeDragCommand(ArmApiFreeDragCommand&& from) noexcept
    : ArmApiFreeDragCommand() {
    *this = ::std::move(from);
  }

  inline ArmApiFreeDragCommand& operator=(const ArmApiFreeDragCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmApiFreeDragCommand& operator=(ArmApiFreeDragCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmApiFreeDragCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArmApiFreeDragCommand* internal_default_instance() {
    return reinterpret_cast<const ArmApiFreeDragCommand*>(
               &_ArmApiFreeDragCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ArmApiFreeDragCommand& a, ArmApiFreeDragCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmApiFreeDragCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmApiFreeDragCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmApiFreeDragCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmApiFreeDragCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ArmApiFreeDragCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ArmApiFreeDragCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmApiFreeDragCommand";
  }
  protected:
  explicit ArmApiFreeDragCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ArmApiFreeDragCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ArmApiZeroCurrentCommand final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ArmApiZeroCurrentCommand) */ {
 public:
  inline ArmApiZeroCurrentCommand() : ArmApiZeroCurrentCommand(nullptr) {}
  explicit constexpr ArmApiZeroCurrentCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmApiZeroCurrentCommand(const ArmApiZeroCurrentCommand& from);
  ArmApiZeroCurrentCommand(ArmApiZeroCurrentCommand&& from) noexcept
    : ArmApiZeroCurrentCommand() {
    *this = ::std::move(from);
  }

  inline ArmApiZeroCurrentCommand& operator=(const ArmApiZeroCurrentCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmApiZeroCurrentCommand& operator=(ArmApiZeroCurrentCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmApiZeroCurrentCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArmApiZeroCurrentCommand* internal_default_instance() {
    return reinterpret_cast<const ArmApiZeroCurrentCommand*>(
               &_ArmApiZeroCurrentCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ArmApiZeroCurrentCommand& a, ArmApiZeroCurrentCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmApiZeroCurrentCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmApiZeroCurrentCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmApiZeroCurrentCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmApiZeroCurrentCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ArmApiZeroCurrentCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ArmApiZeroCurrentCommand& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmApiZeroCurrentCommand";
  }
  protected:
  explicit ArmApiZeroCurrentCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ArmApiZeroCurrentCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ArmApiControlCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmApiControlCommand) */ {
 public:
  inline ArmApiControlCommand() : ArmApiControlCommand(nullptr) {}
  ~ArmApiControlCommand() override;
  explicit constexpr ArmApiControlCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmApiControlCommand(const ArmApiControlCommand& from);
  ArmApiControlCommand(ArmApiControlCommand&& from) noexcept
    : ArmApiControlCommand() {
    *this = ::std::move(from);
  }

  inline ArmApiControlCommand& operator=(const ArmApiControlCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmApiControlCommand& operator=(ArmApiControlCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmApiControlCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kMotorTargets = 1,
    kArmApiFreeDragCommand = 2,
    kArmApiZeroCurrentCommand = 3,
    COMMAND_NOT_SET = 0,
  };

  static inline const ArmApiControlCommand* internal_default_instance() {
    return reinterpret_cast<const ArmApiControlCommand*>(
               &_ArmApiControlCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ArmApiControlCommand& a, ArmApiControlCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmApiControlCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmApiControlCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmApiControlCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmApiControlCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArmApiControlCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArmApiControlCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmApiControlCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmApiControlCommand";
  }
  protected:
  explicit ArmApiControlCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorTargetsFieldNumber = 1,
    kArmApiFreeDragCommandFieldNumber = 2,
    kArmApiZeroCurrentCommandFieldNumber = 3,
  };
  // .MotorTargets motor_targets = 1;
  bool has_motor_targets() const;
  private:
  bool _internal_has_motor_targets() const;
  public:
  void clear_motor_targets();
  const ::MotorTargets& motor_targets() const;
  PROTOBUF_NODISCARD ::MotorTargets* release_motor_targets();
  ::MotorTargets* mutable_motor_targets();
  void set_allocated_motor_targets(::MotorTargets* motor_targets);
  private:
  const ::MotorTargets& _internal_motor_targets() const;
  ::MotorTargets* _internal_mutable_motor_targets();
  public:
  void unsafe_arena_set_allocated_motor_targets(
      ::MotorTargets* motor_targets);
  ::MotorTargets* unsafe_arena_release_motor_targets();

  // .ArmApiFreeDragCommand arm_api_free_drag_command = 2;
  bool has_arm_api_free_drag_command() const;
  private:
  bool _internal_has_arm_api_free_drag_command() const;
  public:
  void clear_arm_api_free_drag_command();
  const ::ArmApiFreeDragCommand& arm_api_free_drag_command() const;
  PROTOBUF_NODISCARD ::ArmApiFreeDragCommand* release_arm_api_free_drag_command();
  ::ArmApiFreeDragCommand* mutable_arm_api_free_drag_command();
  void set_allocated_arm_api_free_drag_command(::ArmApiFreeDragCommand* arm_api_free_drag_command);
  private:
  const ::ArmApiFreeDragCommand& _internal_arm_api_free_drag_command() const;
  ::ArmApiFreeDragCommand* _internal_mutable_arm_api_free_drag_command();
  public:
  void unsafe_arena_set_allocated_arm_api_free_drag_command(
      ::ArmApiFreeDragCommand* arm_api_free_drag_command);
  ::ArmApiFreeDragCommand* unsafe_arena_release_arm_api_free_drag_command();

  // .ArmApiZeroCurrentCommand arm_api_zero_current_command = 3;
  bool has_arm_api_zero_current_command() const;
  private:
  bool _internal_has_arm_api_zero_current_command() const;
  public:
  void clear_arm_api_zero_current_command();
  const ::ArmApiZeroCurrentCommand& arm_api_zero_current_command() const;
  PROTOBUF_NODISCARD ::ArmApiZeroCurrentCommand* release_arm_api_zero_current_command();
  ::ArmApiZeroCurrentCommand* mutable_arm_api_zero_current_command();
  void set_allocated_arm_api_zero_current_command(::ArmApiZeroCurrentCommand* arm_api_zero_current_command);
  private:
  const ::ArmApiZeroCurrentCommand& _internal_arm_api_zero_current_command() const;
  ::ArmApiZeroCurrentCommand* _internal_mutable_arm_api_zero_current_command();
  public:
  void unsafe_arena_set_allocated_arm_api_zero_current_command(
      ::ArmApiZeroCurrentCommand* arm_api_zero_current_command);
  ::ArmApiZeroCurrentCommand* unsafe_arena_release_arm_api_zero_current_command();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:ArmApiControlCommand)
 private:
  class _Internal;
  void set_has_motor_targets();
  void set_has_arm_api_free_drag_command();
  void set_has_arm_api_zero_current_command();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::MotorTargets* motor_targets_;
    ::ArmApiFreeDragCommand* arm_api_free_drag_command_;
    ::ArmApiZeroCurrentCommand* arm_api_zero_current_command_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ArmSharedCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmSharedCommand) */ {
 public:
  inline ArmSharedCommand() : ArmSharedCommand(nullptr) {}
  ~ArmSharedCommand() override;
  explicit constexpr ArmSharedCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmSharedCommand(const ArmSharedCommand& from);
  ArmSharedCommand(ArmSharedCommand&& from) noexcept
    : ArmSharedCommand() {
    *this = ::std::move(from);
  }

  inline ArmSharedCommand& operator=(const ArmSharedCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmSharedCommand& operator=(ArmSharedCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmSharedCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kClearParkingStop = 1,
    kEnterParkingStop = 2,
    COMMAND_NOT_SET = 0,
  };

  static inline const ArmSharedCommand* internal_default_instance() {
    return reinterpret_cast<const ArmSharedCommand*>(
               &_ArmSharedCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ArmSharedCommand& a, ArmSharedCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmSharedCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmSharedCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmSharedCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmSharedCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArmSharedCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArmSharedCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmSharedCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmSharedCommand";
  }
  protected:
  explicit ArmSharedCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClearParkingStopFieldNumber = 1,
    kEnterParkingStopFieldNumber = 2,
  };
  // bool clear_parking_stop = 1;
  bool has_clear_parking_stop() const;
  private:
  bool _internal_has_clear_parking_stop() const;
  public:
  void clear_clear_parking_stop();
  bool clear_parking_stop() const;
  void set_clear_parking_stop(bool value);
  private:
  bool _internal_clear_parking_stop() const;
  void _internal_set_clear_parking_stop(bool value);
  public:

  // .ParkingStopDetail enter_parking_stop = 2;
  bool has_enter_parking_stop() const;
  private:
  bool _internal_has_enter_parking_stop() const;
  public:
  void clear_enter_parking_stop();
  const ::ParkingStopDetail& enter_parking_stop() const;
  PROTOBUF_NODISCARD ::ParkingStopDetail* release_enter_parking_stop();
  ::ParkingStopDetail* mutable_enter_parking_stop();
  void set_allocated_enter_parking_stop(::ParkingStopDetail* enter_parking_stop);
  private:
  const ::ParkingStopDetail& _internal_enter_parking_stop() const;
  ::ParkingStopDetail* _internal_mutable_enter_parking_stop();
  public:
  void unsafe_arena_set_allocated_enter_parking_stop(
      ::ParkingStopDetail* enter_parking_stop);
  ::ParkingStopDetail* unsafe_arena_release_enter_parking_stop();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:ArmSharedCommand)
 private:
  class _Internal;
  void set_has_clear_parking_stop();
  void set_has_enter_parking_stop();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool clear_parking_stop_;
    ::ParkingStopDetail* enter_parking_stop_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ArmExclusiveCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmExclusiveCommand) */ {
 public:
  inline ArmExclusiveCommand() : ArmExclusiveCommand(nullptr) {}
  ~ArmExclusiveCommand() override;
  explicit constexpr ArmExclusiveCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmExclusiveCommand(const ArmExclusiveCommand& from);
  ArmExclusiveCommand(ArmExclusiveCommand&& from) noexcept
    : ArmExclusiveCommand() {
    *this = ::std::move(from);
  }

  inline ArmExclusiveCommand& operator=(const ArmExclusiveCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmExclusiveCommand& operator=(ArmExclusiveCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmExclusiveCommand& default_instance() {
    return *internal_default_instance();
  }
  enum ExclusiveCommandCase {
    kApiControlInitialize = 1,
    kArmApiControlCommand = 6,
    kCalibrate = 4,
    EXCLUSIVE_COMMAND_NOT_SET = 0,
  };

  static inline const ArmExclusiveCommand* internal_default_instance() {
    return reinterpret_cast<const ArmExclusiveCommand*>(
               &_ArmExclusiveCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ArmExclusiveCommand& a, ArmExclusiveCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmExclusiveCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmExclusiveCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmExclusiveCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmExclusiveCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArmExclusiveCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArmExclusiveCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmExclusiveCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmExclusiveCommand";
  }
  protected:
  explicit ArmExclusiveCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiControlInitializeFieldNumber = 1,
    kArmApiControlCommandFieldNumber = 6,
    kCalibrateFieldNumber = 4,
  };
  // bool api_control_initialize = 1;
  bool has_api_control_initialize() const;
  private:
  bool _internal_has_api_control_initialize() const;
  public:
  void clear_api_control_initialize();
  bool api_control_initialize() const;
  void set_api_control_initialize(bool value);
  private:
  bool _internal_api_control_initialize() const;
  void _internal_set_api_control_initialize(bool value);
  public:

  // .ArmApiControlCommand arm_api_control_command = 6;
  bool has_arm_api_control_command() const;
  private:
  bool _internal_has_arm_api_control_command() const;
  public:
  void clear_arm_api_control_command();
  const ::ArmApiControlCommand& arm_api_control_command() const;
  PROTOBUF_NODISCARD ::ArmApiControlCommand* release_arm_api_control_command();
  ::ArmApiControlCommand* mutable_arm_api_control_command();
  void set_allocated_arm_api_control_command(::ArmApiControlCommand* arm_api_control_command);
  private:
  const ::ArmApiControlCommand& _internal_arm_api_control_command() const;
  ::ArmApiControlCommand* _internal_mutable_arm_api_control_command();
  public:
  void unsafe_arena_set_allocated_arm_api_control_command(
      ::ArmApiControlCommand* arm_api_control_command);
  ::ArmApiControlCommand* unsafe_arena_release_arm_api_control_command();

  // bool calibrate = 4;
  bool has_calibrate() const;
  private:
  bool _internal_has_calibrate() const;
  public:
  void clear_calibrate();
  bool calibrate() const;
  void set_calibrate(bool value);
  private:
  bool _internal_calibrate() const;
  void _internal_set_calibrate(bool value);
  public:

  void clear_exclusive_command();
  ExclusiveCommandCase exclusive_command_case() const;
  // @@protoc_insertion_point(class_scope:ArmExclusiveCommand)
 private:
  class _Internal;
  void set_has_api_control_initialize();
  void set_has_arm_api_control_command();
  void set_has_calibrate();

  inline bool has_exclusive_command() const;
  inline void clear_has_exclusive_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ExclusiveCommandUnion {
    constexpr ExclusiveCommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool api_control_initialize_;
    ::ArmApiControlCommand* arm_api_control_command_;
    bool calibrate_;
  } exclusive_command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ArmCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ArmCommand) */ {
 public:
  inline ArmCommand() : ArmCommand(nullptr) {}
  ~ArmCommand() override;
  explicit constexpr ArmCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArmCommand(const ArmCommand& from);
  ArmCommand(ArmCommand&& from) noexcept
    : ArmCommand() {
    *this = ::std::move(from);
  }

  inline ArmCommand& operator=(const ArmCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArmCommand& operator=(ArmCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArmCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kArmExclusiveCommand = 1,
    kArmSharedCommand = 2,
    COMMAND_NOT_SET = 0,
  };

  static inline const ArmCommand* internal_default_instance() {
    return reinterpret_cast<const ArmCommand*>(
               &_ArmCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ArmCommand& a, ArmCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ArmCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArmCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArmCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArmCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArmCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ArmCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ArmCommand";
  }
  protected:
  explicit ArmCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArmExclusiveCommandFieldNumber = 1,
    kArmSharedCommandFieldNumber = 2,
  };
  // .ArmExclusiveCommand arm_exclusive_command = 1;
  bool has_arm_exclusive_command() const;
  private:
  bool _internal_has_arm_exclusive_command() const;
  public:
  void clear_arm_exclusive_command();
  const ::ArmExclusiveCommand& arm_exclusive_command() const;
  PROTOBUF_NODISCARD ::ArmExclusiveCommand* release_arm_exclusive_command();
  ::ArmExclusiveCommand* mutable_arm_exclusive_command();
  void set_allocated_arm_exclusive_command(::ArmExclusiveCommand* arm_exclusive_command);
  private:
  const ::ArmExclusiveCommand& _internal_arm_exclusive_command() const;
  ::ArmExclusiveCommand* _internal_mutable_arm_exclusive_command();
  public:
  void unsafe_arena_set_allocated_arm_exclusive_command(
      ::ArmExclusiveCommand* arm_exclusive_command);
  ::ArmExclusiveCommand* unsafe_arena_release_arm_exclusive_command();

  // .ArmSharedCommand arm_shared_command = 2;
  bool has_arm_shared_command() const;
  private:
  bool _internal_has_arm_shared_command() const;
  public:
  void clear_arm_shared_command();
  const ::ArmSharedCommand& arm_shared_command() const;
  PROTOBUF_NODISCARD ::ArmSharedCommand* release_arm_shared_command();
  ::ArmSharedCommand* mutable_arm_shared_command();
  void set_allocated_arm_shared_command(::ArmSharedCommand* arm_shared_command);
  private:
  const ::ArmSharedCommand& _internal_arm_shared_command() const;
  ::ArmSharedCommand* _internal_mutable_arm_shared_command();
  public:
  void unsafe_arena_set_allocated_arm_shared_command(
      ::ArmSharedCommand* arm_shared_command);
  ::ArmSharedCommand* unsafe_arena_release_arm_shared_command();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:ArmCommand)
 private:
  class _Internal;
  void set_has_arm_exclusive_command();
  void set_has_arm_shared_command();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ArmExclusiveCommand* arm_exclusive_command_;
    ::ArmSharedCommand* arm_shared_command_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class GamepadRead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GamepadRead) */ {
 public:
  inline GamepadRead() : GamepadRead(nullptr) {}
  ~GamepadRead() override;
  explicit constexpr GamepadRead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GamepadRead(const GamepadRead& from);
  GamepadRead(GamepadRead&& from) noexcept
    : GamepadRead() {
    *this = ::std::move(from);
  }

  inline GamepadRead& operator=(const GamepadRead& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamepadRead& operator=(GamepadRead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GamepadRead& default_instance() {
    return *internal_default_instance();
  }
  static inline const GamepadRead* internal_default_instance() {
    return reinterpret_cast<const GamepadRead*>(
               &_GamepadRead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GamepadRead& a, GamepadRead& b) {
    a.Swap(&b);
  }
  inline void Swap(GamepadRead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamepadRead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GamepadRead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GamepadRead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GamepadRead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GamepadRead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GamepadRead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GamepadRead";
  }
  protected:
  explicit GamepadRead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftStickXFieldNumber = 1,
    kLeftStickYFieldNumber = 2,
    kRightStickXFieldNumber = 3,
    kRightStickYFieldNumber = 4,
    kLeftTriggerFieldNumber = 7,
    kLeftBumperFieldNumber = 5,
    kRightBumperFieldNumber = 6,
    kAButtonFieldNumber = 9,
    kBButtonFieldNumber = 10,
    kRightTriggerFieldNumber = 8,
    kXButtonFieldNumber = 11,
    kYButtonFieldNumber = 12,
    kSelectButtonFieldNumber = 13,
    kStartButtonFieldNumber = 14,
    kLeftStickButtonFieldNumber = 15,
    kRightStickButtonFieldNumber = 16,
    kDpadUpFieldNumber = 17,
    kDpadDownFieldNumber = 18,
    kDpadLeftFieldNumber = 19,
    kDpadRightFieldNumber = 20,
  };
  // float left_stick_x = 1;
  void clear_left_stick_x();
  float left_stick_x() const;
  void set_left_stick_x(float value);
  private:
  float _internal_left_stick_x() const;
  void _internal_set_left_stick_x(float value);
  public:

  // float left_stick_y = 2;
  void clear_left_stick_y();
  float left_stick_y() const;
  void set_left_stick_y(float value);
  private:
  float _internal_left_stick_y() const;
  void _internal_set_left_stick_y(float value);
  public:

  // float right_stick_x = 3;
  void clear_right_stick_x();
  float right_stick_x() const;
  void set_right_stick_x(float value);
  private:
  float _internal_right_stick_x() const;
  void _internal_set_right_stick_x(float value);
  public:

  // float right_stick_y = 4;
  void clear_right_stick_y();
  float right_stick_y() const;
  void set_right_stick_y(float value);
  private:
  float _internal_right_stick_y() const;
  void _internal_set_right_stick_y(float value);
  public:

  // float left_trigger = 7;
  void clear_left_trigger();
  float left_trigger() const;
  void set_left_trigger(float value);
  private:
  float _internal_left_trigger() const;
  void _internal_set_left_trigger(float value);
  public:

  // bool left_bumper = 5;
  void clear_left_bumper();
  bool left_bumper() const;
  void set_left_bumper(bool value);
  private:
  bool _internal_left_bumper() const;
  void _internal_set_left_bumper(bool value);
  public:

  // bool right_bumper = 6;
  void clear_right_bumper();
  bool right_bumper() const;
  void set_right_bumper(bool value);
  private:
  bool _internal_right_bumper() const;
  void _internal_set_right_bumper(bool value);
  public:

  // bool a_button = 9;
  void clear_a_button();
  bool a_button() const;
  void set_a_button(bool value);
  private:
  bool _internal_a_button() const;
  void _internal_set_a_button(bool value);
  public:

  // bool b_button = 10;
  void clear_b_button();
  bool b_button() const;
  void set_b_button(bool value);
  private:
  bool _internal_b_button() const;
  void _internal_set_b_button(bool value);
  public:

  // float right_trigger = 8;
  void clear_right_trigger();
  float right_trigger() const;
  void set_right_trigger(float value);
  private:
  float _internal_right_trigger() const;
  void _internal_set_right_trigger(float value);
  public:

  // bool x_button = 11;
  void clear_x_button();
  bool x_button() const;
  void set_x_button(bool value);
  private:
  bool _internal_x_button() const;
  void _internal_set_x_button(bool value);
  public:

  // bool y_button = 12;
  void clear_y_button();
  bool y_button() const;
  void set_y_button(bool value);
  private:
  bool _internal_y_button() const;
  void _internal_set_y_button(bool value);
  public:

  // bool select_button = 13;
  void clear_select_button();
  bool select_button() const;
  void set_select_button(bool value);
  private:
  bool _internal_select_button() const;
  void _internal_set_select_button(bool value);
  public:

  // bool start_button = 14;
  void clear_start_button();
  bool start_button() const;
  void set_start_button(bool value);
  private:
  bool _internal_start_button() const;
  void _internal_set_start_button(bool value);
  public:

  // bool left_stick_button = 15;
  void clear_left_stick_button();
  bool left_stick_button() const;
  void set_left_stick_button(bool value);
  private:
  bool _internal_left_stick_button() const;
  void _internal_set_left_stick_button(bool value);
  public:

  // bool right_stick_button = 16;
  void clear_right_stick_button();
  bool right_stick_button() const;
  void set_right_stick_button(bool value);
  private:
  bool _internal_right_stick_button() const;
  void _internal_set_right_stick_button(bool value);
  public:

  // bool dpad_up = 17;
  void clear_dpad_up();
  bool dpad_up() const;
  void set_dpad_up(bool value);
  private:
  bool _internal_dpad_up() const;
  void _internal_set_dpad_up(bool value);
  public:

  // bool dpad_down = 18;
  void clear_dpad_down();
  bool dpad_down() const;
  void set_dpad_down(bool value);
  private:
  bool _internal_dpad_down() const;
  void _internal_set_dpad_down(bool value);
  public:

  // bool dpad_left = 19;
  void clear_dpad_left();
  bool dpad_left() const;
  void set_dpad_left(bool value);
  private:
  bool _internal_dpad_left() const;
  void _internal_set_dpad_left(bool value);
  public:

  // bool dpad_right = 20;
  void clear_dpad_right();
  bool dpad_right() const;
  void set_dpad_right(bool value);
  private:
  bool _internal_dpad_right() const;
  void _internal_set_dpad_right(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GamepadRead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float left_stick_x_;
  float left_stick_y_;
  float right_stick_x_;
  float right_stick_y_;
  float left_trigger_;
  bool left_bumper_;
  bool right_bumper_;
  bool a_button_;
  bool b_button_;
  float right_trigger_;
  bool x_button_;
  bool y_button_;
  bool select_button_;
  bool start_button_;
  bool left_stick_button_;
  bool right_stick_button_;
  bool dpad_up_;
  bool dpad_down_;
  bool dpad_left_;
  bool dpad_right_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class EnableKcp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EnableKcp) */ {
 public:
  inline EnableKcp() : EnableKcp(nullptr) {}
  ~EnableKcp() override;
  explicit constexpr EnableKcp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableKcp(const EnableKcp& from);
  EnableKcp(EnableKcp&& from) noexcept
    : EnableKcp() {
    *this = ::std::move(from);
  }

  inline EnableKcp& operator=(const EnableKcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableKcp& operator=(EnableKcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableKcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableKcp* internal_default_instance() {
    return reinterpret_cast<const EnableKcp*>(
               &_EnableKcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EnableKcp& a, EnableKcp& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableKcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableKcp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableKcp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableKcp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableKcp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnableKcp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableKcp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EnableKcp";
  }
  protected:
  explicit EnableKcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKcpConfigFieldNumber = 2,
    kClientPeerPortFieldNumber = 1,
  };
  // .KcpConfig kcp_config = 2;
  bool has_kcp_config() const;
  private:
  bool _internal_has_kcp_config() const;
  public:
  void clear_kcp_config();
  const ::KcpConfig& kcp_config() const;
  PROTOBUF_NODISCARD ::KcpConfig* release_kcp_config();
  ::KcpConfig* mutable_kcp_config();
  void set_allocated_kcp_config(::KcpConfig* kcp_config);
  private:
  const ::KcpConfig& _internal_kcp_config() const;
  ::KcpConfig* _internal_mutable_kcp_config();
  public:
  void unsafe_arena_set_allocated_kcp_config(
      ::KcpConfig* kcp_config);
  ::KcpConfig* unsafe_arena_release_kcp_config();

  // uint32 client_peer_port = 1;
  void clear_client_peer_port();
  uint32_t client_peer_port() const;
  void set_client_peer_port(uint32_t value);
  private:
  uint32_t _internal_client_peer_port() const;
  void _internal_set_client_peer_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EnableKcp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::KcpConfig* kcp_config_;
  uint32_t client_peer_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KcpServerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KcpServerStatus) */ {
 public:
  inline KcpServerStatus() : KcpServerStatus(nullptr) {}
  ~KcpServerStatus() override;
  explicit constexpr KcpServerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KcpServerStatus(const KcpServerStatus& from);
  KcpServerStatus(KcpServerStatus&& from) noexcept
    : KcpServerStatus() {
    *this = ::std::move(from);
  }

  inline KcpServerStatus& operator=(const KcpServerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline KcpServerStatus& operator=(KcpServerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KcpServerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const KcpServerStatus* internal_default_instance() {
    return reinterpret_cast<const KcpServerStatus*>(
               &_KcpServerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(KcpServerStatus& a, KcpServerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(KcpServerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KcpServerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KcpServerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KcpServerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KcpServerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KcpServerStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KcpServerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KcpServerStatus";
  }
  protected:
  explicit KcpServerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKcpConfigFieldNumber = 2,
    kServerPortFieldNumber = 1,
  };
  // .KcpConfig kcp_config = 2;
  bool has_kcp_config() const;
  private:
  bool _internal_has_kcp_config() const;
  public:
  void clear_kcp_config();
  const ::KcpConfig& kcp_config() const;
  PROTOBUF_NODISCARD ::KcpConfig* release_kcp_config();
  ::KcpConfig* mutable_kcp_config();
  void set_allocated_kcp_config(::KcpConfig* kcp_config);
  private:
  const ::KcpConfig& _internal_kcp_config() const;
  ::KcpConfig* _internal_mutable_kcp_config();
  public:
  void unsafe_arena_set_allocated_kcp_config(
      ::KcpConfig* kcp_config);
  ::KcpConfig* unsafe_arena_release_kcp_config();

  // uint32 server_port = 1;
  void clear_server_port();
  uint32_t server_port() const;
  void set_server_port(uint32_t value);
  private:
  uint32_t _internal_server_port() const;
  void _internal_set_server_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KcpServerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::KcpConfig* kcp_config_;
  uint32_t server_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class KcpConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KcpConfig) */ {
 public:
  inline KcpConfig() : KcpConfig(nullptr) {}
  ~KcpConfig() override;
  explicit constexpr KcpConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KcpConfig(const KcpConfig& from);
  KcpConfig(KcpConfig&& from) noexcept
    : KcpConfig() {
    *this = ::std::move(from);
  }

  inline KcpConfig& operator=(const KcpConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline KcpConfig& operator=(KcpConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KcpConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const KcpConfig* internal_default_instance() {
    return reinterpret_cast<const KcpConfig*>(
               &_KcpConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(KcpConfig& a, KcpConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(KcpConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KcpConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KcpConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KcpConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KcpConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KcpConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KcpConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KcpConfig";
  }
  protected:
  explicit KcpConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowSizeSndWndFieldNumber = 1,
    kWindowSizeRcvWndFieldNumber = 2,
    kIntervalMsFieldNumber = 3,
    kNoDelayFieldNumber = 4,
    kNcFieldNumber = 5,
    kResendFieldNumber = 6,
  };
  // int32 window_size_snd_wnd = 1;
  void clear_window_size_snd_wnd();
  int32_t window_size_snd_wnd() const;
  void set_window_size_snd_wnd(int32_t value);
  private:
  int32_t _internal_window_size_snd_wnd() const;
  void _internal_set_window_size_snd_wnd(int32_t value);
  public:

  // int32 window_size_rcv_wnd = 2;
  void clear_window_size_rcv_wnd();
  int32_t window_size_rcv_wnd() const;
  void set_window_size_rcv_wnd(int32_t value);
  private:
  int32_t _internal_window_size_rcv_wnd() const;
  void _internal_set_window_size_rcv_wnd(int32_t value);
  public:

  // int32 interval_ms = 3;
  void clear_interval_ms();
  int32_t interval_ms() const;
  void set_interval_ms(int32_t value);
  private:
  int32_t _internal_interval_ms() const;
  void _internal_set_interval_ms(int32_t value);
  public:

  // bool no_delay = 4;
  void clear_no_delay();
  bool no_delay() const;
  void set_no_delay(bool value);
  private:
  bool _internal_no_delay() const;
  void _internal_set_no_delay(bool value);
  public:

  // bool nc = 5;
  void clear_nc();
  bool nc() const;
  void set_nc(bool value);
  private:
  bool _internal_nc() const;
  void _internal_set_nc(bool value);
  public:

  // int32 resend = 6;
  void clear_resend();
  int32_t resend() const;
  void set_resend(int32_t value);
  private:
  int32_t _internal_resend() const;
  void _internal_set_resend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:KcpConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t window_size_snd_wnd_;
  int32_t window_size_rcv_wnd_;
  int32_t interval_ms_;
  bool no_delay_;
  bool nc_;
  int32_t resend_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ImuAcceleration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ImuAcceleration) */ {
 public:
  inline ImuAcceleration() : ImuAcceleration(nullptr) {}
  ~ImuAcceleration() override;
  explicit constexpr ImuAcceleration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImuAcceleration(const ImuAcceleration& from);
  ImuAcceleration(ImuAcceleration&& from) noexcept
    : ImuAcceleration() {
    *this = ::std::move(from);
  }

  inline ImuAcceleration& operator=(const ImuAcceleration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuAcceleration& operator=(ImuAcceleration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImuAcceleration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImuAcceleration* internal_default_instance() {
    return reinterpret_cast<const ImuAcceleration*>(
               &_ImuAcceleration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ImuAcceleration& a, ImuAcceleration& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuAcceleration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuAcceleration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImuAcceleration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImuAcceleration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImuAcceleration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImuAcceleration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuAcceleration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ImuAcceleration";
  }
  protected:
  explicit ImuAcceleration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAxFieldNumber = 1,
    kAyFieldNumber = 2,
    kAzFieldNumber = 3,
  };
  // float ax = 1;
  void clear_ax();
  float ax() const;
  void set_ax(float value);
  private:
  float _internal_ax() const;
  void _internal_set_ax(float value);
  public:

  // float ay = 2;
  void clear_ay();
  float ay() const;
  void set_ay(float value);
  private:
  float _internal_ay() const;
  void _internal_set_ay(float value);
  public:

  // float az = 3;
  void clear_az();
  float az() const;
  void set_az(float value);
  private:
  float _internal_az() const;
  void _internal_set_az(float value);
  public:

  // @@protoc_insertion_point(class_scope:ImuAcceleration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float ax_;
  float ay_;
  float az_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ImuAngularVelocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ImuAngularVelocity) */ {
 public:
  inline ImuAngularVelocity() : ImuAngularVelocity(nullptr) {}
  ~ImuAngularVelocity() override;
  explicit constexpr ImuAngularVelocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImuAngularVelocity(const ImuAngularVelocity& from);
  ImuAngularVelocity(ImuAngularVelocity&& from) noexcept
    : ImuAngularVelocity() {
    *this = ::std::move(from);
  }

  inline ImuAngularVelocity& operator=(const ImuAngularVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuAngularVelocity& operator=(ImuAngularVelocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImuAngularVelocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImuAngularVelocity* internal_default_instance() {
    return reinterpret_cast<const ImuAngularVelocity*>(
               &_ImuAngularVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ImuAngularVelocity& a, ImuAngularVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuAngularVelocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuAngularVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImuAngularVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImuAngularVelocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImuAngularVelocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImuAngularVelocity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuAngularVelocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ImuAngularVelocity";
  }
  protected:
  explicit ImuAngularVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWxFieldNumber = 1,
    kWyFieldNumber = 2,
    kWzFieldNumber = 3,
  };
  // float wx = 1;
  void clear_wx();
  float wx() const;
  void set_wx(float value);
  private:
  float _internal_wx() const;
  void _internal_set_wx(float value);
  public:

  // float wy = 2;
  void clear_wy();
  float wy() const;
  void set_wy(float value);
  private:
  float _internal_wy() const;
  void _internal_set_wy(float value);
  public:

  // float wz = 3;
  void clear_wz();
  float wz() const;
  void set_wz(float value);
  private:
  float _internal_wz() const;
  void _internal_set_wz(float value);
  public:

  // @@protoc_insertion_point(class_scope:ImuAngularVelocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float wx_;
  float wy_;
  float wz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ImuQuaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ImuQuaternion) */ {
 public:
  inline ImuQuaternion() : ImuQuaternion(nullptr) {}
  ~ImuQuaternion() override;
  explicit constexpr ImuQuaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImuQuaternion(const ImuQuaternion& from);
  ImuQuaternion(ImuQuaternion&& from) noexcept
    : ImuQuaternion() {
    *this = ::std::move(from);
  }

  inline ImuQuaternion& operator=(const ImuQuaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuQuaternion& operator=(ImuQuaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImuQuaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImuQuaternion* internal_default_instance() {
    return reinterpret_cast<const ImuQuaternion*>(
               &_ImuQuaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ImuQuaternion& a, ImuQuaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuQuaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuQuaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImuQuaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImuQuaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImuQuaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImuQuaternion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuQuaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ImuQuaternion";
  }
  protected:
  explicit ImuQuaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQxFieldNumber = 1,
    kQyFieldNumber = 2,
    kQzFieldNumber = 3,
    kQwFieldNumber = 4,
  };
  // float qx = 1;
  void clear_qx();
  float qx() const;
  void set_qx(float value);
  private:
  float _internal_qx() const;
  void _internal_set_qx(float value);
  public:

  // float qy = 2;
  void clear_qy();
  float qy() const;
  void set_qy(float value);
  private:
  float _internal_qy() const;
  void _internal_set_qy(float value);
  public:

  // float qz = 3;
  void clear_qz();
  float qz() const;
  void set_qz(float value);
  private:
  float _internal_qz() const;
  void _internal_set_qz(float value);
  public:

  // float qw = 4;
  void clear_qw();
  float qw() const;
  void set_qw(float value);
  private:
  float _internal_qw() const;
  void _internal_set_qw(float value);
  public:

  // @@protoc_insertion_point(class_scope:ImuQuaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float qx_;
  float qy_;
  float qz_;
  float qw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ImuData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ImuData) */ {
 public:
  inline ImuData() : ImuData(nullptr) {}
  ~ImuData() override;
  explicit constexpr ImuData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImuData(const ImuData& from);
  ImuData(ImuData&& from) noexcept
    : ImuData() {
    *this = ::std::move(from);
  }

  inline ImuData& operator=(const ImuData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImuData& operator=(ImuData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImuData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImuData* internal_default_instance() {
    return reinterpret_cast<const ImuData*>(
               &_ImuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ImuData& a, ImuData& b) {
    a.Swap(&b);
  }
  inline void Swap(ImuData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImuData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImuData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImuData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImuData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImuData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ImuData";
  }
  protected:
  explicit ImuData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerationFieldNumber = 1,
    kAngularVelocityFieldNumber = 2,
    kQuaternionFieldNumber = 3,
  };
  // .ImuAcceleration acceleration = 1;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::ImuAcceleration& acceleration() const;
  PROTOBUF_NODISCARD ::ImuAcceleration* release_acceleration();
  ::ImuAcceleration* mutable_acceleration();
  void set_allocated_acceleration(::ImuAcceleration* acceleration);
  private:
  const ::ImuAcceleration& _internal_acceleration() const;
  ::ImuAcceleration* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::ImuAcceleration* acceleration);
  ::ImuAcceleration* unsafe_arena_release_acceleration();

  // .ImuAngularVelocity angular_velocity = 2;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  const ::ImuAngularVelocity& angular_velocity() const;
  PROTOBUF_NODISCARD ::ImuAngularVelocity* release_angular_velocity();
  ::ImuAngularVelocity* mutable_angular_velocity();
  void set_allocated_angular_velocity(::ImuAngularVelocity* angular_velocity);
  private:
  const ::ImuAngularVelocity& _internal_angular_velocity() const;
  ::ImuAngularVelocity* _internal_mutable_angular_velocity();
  public:
  void unsafe_arena_set_allocated_angular_velocity(
      ::ImuAngularVelocity* angular_velocity);
  ::ImuAngularVelocity* unsafe_arena_release_angular_velocity();

  // .ImuQuaternion quaternion = 3;
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;
  public:
  void clear_quaternion();
  const ::ImuQuaternion& quaternion() const;
  PROTOBUF_NODISCARD ::ImuQuaternion* release_quaternion();
  ::ImuQuaternion* mutable_quaternion();
  void set_allocated_quaternion(::ImuQuaternion* quaternion);
  private:
  const ::ImuQuaternion& _internal_quaternion() const;
  ::ImuQuaternion* _internal_mutable_quaternion();
  public:
  void unsafe_arena_set_allocated_quaternion(
      ::ImuQuaternion* quaternion);
  ::ImuQuaternion* unsafe_arena_release_quaternion();

  // @@protoc_insertion_point(class_scope:ImuData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ImuAcceleration* acceleration_;
  ::ImuAngularVelocity* angular_velocity_;
  ::ImuQuaternion* quaternion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class ParkingStopDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ParkingStopDetail) */ {
 public:
  inline ParkingStopDetail() : ParkingStopDetail(nullptr) {}
  ~ParkingStopDetail() override;
  explicit constexpr ParkingStopDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParkingStopDetail(const ParkingStopDetail& from);
  ParkingStopDetail(ParkingStopDetail&& from) noexcept
    : ParkingStopDetail() {
    *this = ::std::move(from);
  }

  inline ParkingStopDetail& operator=(const ParkingStopDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingStopDetail& operator=(ParkingStopDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParkingStopDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParkingStopDetail* internal_default_instance() {
    return reinterpret_cast<const ParkingStopDetail*>(
               &_ParkingStopDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ParkingStopDetail& a, ParkingStopDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingStopDetail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingStopDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParkingStopDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParkingStopDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParkingStopDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParkingStopDetail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingStopDetail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ParkingStopDetail";
  }
  protected:
  explicit ParkingStopDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kCategoryFieldNumber = 2,
    kIsRemotelyClearableFieldNumber = 3,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // .ParkingStopCategory category = 2;
  void clear_category();
  ::ParkingStopCategory category() const;
  void set_category(::ParkingStopCategory value);
  private:
  ::ParkingStopCategory _internal_category() const;
  void _internal_set_category(::ParkingStopCategory value);
  public:

  // bool is_remotely_clearable = 3;
  void clear_is_remotely_clearable();
  bool is_remotely_clearable() const;
  void set_is_remotely_clearable(bool value);
  private:
  bool _internal_is_remotely_clearable() const;
  void _internal_set_is_remotely_clearable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ParkingStopDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int category_;
  bool is_remotely_clearable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SingleMotorTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SingleMotorTarget) */ {
 public:
  inline SingleMotorTarget() : SingleMotorTarget(nullptr) {}
  ~SingleMotorTarget() override;
  explicit constexpr SingleMotorTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleMotorTarget(const SingleMotorTarget& from);
  SingleMotorTarget(SingleMotorTarget&& from) noexcept
    : SingleMotorTarget() {
    *this = ::std::move(from);
  }

  inline SingleMotorTarget& operator=(const SingleMotorTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleMotorTarget& operator=(SingleMotorTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleMotorTarget& default_instance() {
    return *internal_default_instance();
  }
  enum TargetCase {
    kTorque = 1,
    kSpeed = 2,
    kPosition = 3,
    kBrake = 4,
    kMitTarget = 5,
    TARGET_NOT_SET = 0,
  };

  static inline const SingleMotorTarget* internal_default_instance() {
    return reinterpret_cast<const SingleMotorTarget*>(
               &_SingleMotorTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SingleMotorTarget& a, SingleMotorTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleMotorTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleMotorTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleMotorTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleMotorTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleMotorTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SingleMotorTarget& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleMotorTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SingleMotorTarget";
  }
  protected:
  explicit SingleMotorTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTorqueFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kPositionFieldNumber = 3,
    kBrakeFieldNumber = 4,
    kMitTargetFieldNumber = 5,
  };
  // double torque = 1;
  bool has_torque() const;
  private:
  bool _internal_has_torque() const;
  public:
  void clear_torque();
  double torque() const;
  void set_torque(double value);
  private:
  double _internal_torque() const;
  void _internal_set_torque(double value);
  public:

  // double speed = 2;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // int64 position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  int64_t position() const;
  void set_position(int64_t value);
  private:
  int64_t _internal_position() const;
  void _internal_set_position(int64_t value);
  public:

  // bool brake = 4;
  bool has_brake() const;
  private:
  bool _internal_has_brake() const;
  public:
  void clear_brake();
  bool brake() const;
  void set_brake(bool value);
  private:
  bool _internal_brake() const;
  void _internal_set_brake(bool value);
  public:

  // .MitMotorTarget mit_target = 5;
  bool has_mit_target() const;
  private:
  bool _internal_has_mit_target() const;
  public:
  void clear_mit_target();
  const ::MitMotorTarget& mit_target() const;
  PROTOBUF_NODISCARD ::MitMotorTarget* release_mit_target();
  ::MitMotorTarget* mutable_mit_target();
  void set_allocated_mit_target(::MitMotorTarget* mit_target);
  private:
  const ::MitMotorTarget& _internal_mit_target() const;
  ::MitMotorTarget* _internal_mutable_mit_target();
  public:
  void unsafe_arena_set_allocated_mit_target(
      ::MitMotorTarget* mit_target);
  ::MitMotorTarget* unsafe_arena_release_mit_target();

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SingleMotorTarget)
 private:
  class _Internal;
  void set_has_torque();
  void set_has_speed();
  void set_has_position();
  void set_has_brake();
  void set_has_mit_target();

  inline bool has_target() const;
  inline void clear_has_target();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TargetUnion {
    constexpr TargetUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double torque_;
    double speed_;
    int64_t position_;
    bool brake_;
    ::MitMotorTarget* mit_target_;
  } target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class MitMotorTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MitMotorTarget) */ {
 public:
  inline MitMotorTarget() : MitMotorTarget(nullptr) {}
  ~MitMotorTarget() override;
  explicit constexpr MitMotorTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MitMotorTarget(const MitMotorTarget& from);
  MitMotorTarget(MitMotorTarget&& from) noexcept
    : MitMotorTarget() {
    *this = ::std::move(from);
  }

  inline MitMotorTarget& operator=(const MitMotorTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline MitMotorTarget& operator=(MitMotorTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MitMotorTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const MitMotorTarget* internal_default_instance() {
    return reinterpret_cast<const MitMotorTarget*>(
               &_MitMotorTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(MitMotorTarget& a, MitMotorTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(MitMotorTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MitMotorTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MitMotorTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MitMotorTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MitMotorTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MitMotorTarget& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MitMotorTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MitMotorTarget";
  }
  protected:
  explicit MitMotorTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTorqueFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kPositionFieldNumber = 3,
    kKpFieldNumber = 4,
    kKdFieldNumber = 5,
  };
  // double torque = 1;
  void clear_torque();
  double torque() const;
  void set_torque(double value);
  private:
  double _internal_torque() const;
  void _internal_set_torque(double value);
  public:

  // double speed = 2;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double position = 3;
  void clear_position();
  double position() const;
  void set_position(double value);
  private:
  double _internal_position() const;
  void _internal_set_position(double value);
  public:

  // double kp = 4;
  void clear_kp();
  double kp() const;
  void set_kp(double value);
  private:
  double _internal_kp() const;
  void _internal_set_kp(double value);
  public:

  // double kd = 5;
  void clear_kd();
  double kd() const;
  void set_kd(double value);
  private:
  double _internal_kd() const;
  void _internal_set_kd(double value);
  public:

  // @@protoc_insertion_point(class_scope:MitMotorTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double torque_;
  double speed_;
  double position_;
  double kp_;
  double kd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class MotorTargets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MotorTargets) */ {
 public:
  inline MotorTargets() : MotorTargets(nullptr) {}
  ~MotorTargets() override;
  explicit constexpr MotorTargets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorTargets(const MotorTargets& from);
  MotorTargets(MotorTargets&& from) noexcept
    : MotorTargets() {
    *this = ::std::move(from);
  }

  inline MotorTargets& operator=(const MotorTargets& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorTargets& operator=(MotorTargets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorTargets& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorTargets* internal_default_instance() {
    return reinterpret_cast<const MotorTargets*>(
               &_MotorTargets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(MotorTargets& a, MotorTargets& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorTargets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorTargets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorTargets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorTargets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorTargets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotorTargets& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorTargets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MotorTargets";
  }
  protected:
  explicit MotorTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated .SingleMotorTarget targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::SingleMotorTarget* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SingleMotorTarget >*
      mutable_targets();
  private:
  const ::SingleMotorTarget& _internal_targets(int index) const;
  ::SingleMotorTarget* _internal_add_targets();
  public:
  const ::SingleMotorTarget& targets(int index) const;
  ::SingleMotorTarget* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SingleMotorTarget >&
      targets() const;

  // @@protoc_insertion_point(class_scope:MotorTargets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SingleMotorTarget > targets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class MotorStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MotorStatus) */ {
 public:
  inline MotorStatus() : MotorStatus(nullptr) {}
  ~MotorStatus() override;
  explicit constexpr MotorStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorStatus(const MotorStatus& from);
  MotorStatus(MotorStatus&& from) noexcept
    : MotorStatus() {
    *this = ::std::move(from);
  }

  inline MotorStatus& operator=(const MotorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorStatus& operator=(MotorStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorStatus* internal_default_instance() {
    return reinterpret_cast<const MotorStatus*>(
               &_MotorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MotorStatus& a, MotorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotorStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotorStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MotorStatus";
  }
  protected:
  explicit MotorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 7,
    kCurrentTargetFieldNumber = 8,
    kTorqueFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kPositionFieldNumber = 4,
    kWheelRadiusFieldNumber = 6,
    kPulsePerRotationFieldNumber = 5,
    kDriverTemperatureFieldNumber = 11,
    kMotorTemperatureFieldNumber = 12,
    kVoltageFieldNumber = 13,
  };
  // repeated .MotorError error = 7;
  int error_size() const;
  private:
  int _internal_error_size() const;
  public:
  void clear_error();
  private:
  ::MotorError _internal_error(int index) const;
  void _internal_add_error(::MotorError value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_error();
  public:
  ::MotorError error(int index) const;
  void set_error(int index, ::MotorError value);
  void add_error(::MotorError value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& error() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_error();

  // .SingleMotorTarget current_target = 8;
  bool has_current_target() const;
  private:
  bool _internal_has_current_target() const;
  public:
  void clear_current_target();
  const ::SingleMotorTarget& current_target() const;
  PROTOBUF_NODISCARD ::SingleMotorTarget* release_current_target();
  ::SingleMotorTarget* mutable_current_target();
  void set_allocated_current_target(::SingleMotorTarget* current_target);
  private:
  const ::SingleMotorTarget& _internal_current_target() const;
  ::SingleMotorTarget* _internal_mutable_current_target();
  public:
  void unsafe_arena_set_allocated_current_target(
      ::SingleMotorTarget* current_target);
  ::SingleMotorTarget* unsafe_arena_release_current_target();

  // double torque = 2;
  void clear_torque();
  double torque() const;
  void set_torque(double value);
  private:
  double _internal_torque() const;
  void _internal_set_torque(double value);
  public:

  // double speed = 3;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // int64 position = 4;
  void clear_position();
  int64_t position() const;
  void set_position(int64_t value);
  private:
  int64_t _internal_position() const;
  void _internal_set_position(int64_t value);
  public:

  // double wheel_radius = 6;
  void clear_wheel_radius();
  double wheel_radius() const;
  void set_wheel_radius(double value);
  private:
  double _internal_wheel_radius() const;
  void _internal_set_wheel_radius(double value);
  public:

  // uint32 pulse_per_rotation = 5;
  void clear_pulse_per_rotation();
  uint32_t pulse_per_rotation() const;
  void set_pulse_per_rotation(uint32_t value);
  private:
  uint32_t _internal_pulse_per_rotation() const;
  void _internal_set_pulse_per_rotation(uint32_t value);
  public:

  // optional float driver_temperature = 11;
  bool has_driver_temperature() const;
  private:
  bool _internal_has_driver_temperature() const;
  public:
  void clear_driver_temperature();
  float driver_temperature() const;
  void set_driver_temperature(float value);
  private:
  float _internal_driver_temperature() const;
  void _internal_set_driver_temperature(float value);
  public:

  // optional float motor_temperature = 12;
  bool has_motor_temperature() const;
  private:
  bool _internal_has_motor_temperature() const;
  public:
  void clear_motor_temperature();
  float motor_temperature() const;
  void set_motor_temperature(float value);
  private:
  float _internal_motor_temperature() const;
  void _internal_set_motor_temperature(float value);
  public:

  // optional float voltage = 13;
  bool has_voltage() const;
  private:
  bool _internal_has_voltage() const;
  public:
  void clear_voltage();
  float voltage() const;
  void set_voltage(float value);
  private:
  float _internal_voltage() const;
  void _internal_set_voltage(float value);
  public:

  // @@protoc_insertion_point(class_scope:MotorStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> error_;
  mutable std::atomic<int> _error_cached_byte_size_;
  ::SingleMotorTarget* current_target_;
  double torque_;
  double speed_;
  int64_t position_;
  double wheel_radius_;
  uint32_t pulse_per_rotation_;
  float driver_temperature_;
  float motor_temperature_;
  float voltage_;
  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SecondaryDeviceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SecondaryDeviceStatus) */ {
 public:
  inline SecondaryDeviceStatus() : SecondaryDeviceStatus(nullptr) {}
  ~SecondaryDeviceStatus() override;
  explicit constexpr SecondaryDeviceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecondaryDeviceStatus(const SecondaryDeviceStatus& from);
  SecondaryDeviceStatus(SecondaryDeviceStatus&& from) noexcept
    : SecondaryDeviceStatus() {
    *this = ::std::move(from);
  }

  inline SecondaryDeviceStatus& operator=(const SecondaryDeviceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecondaryDeviceStatus& operator=(SecondaryDeviceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecondaryDeviceStatus& default_instance() {
    return *internal_default_instance();
  }
  enum StatusCase {
    kImuData = 11,
    kHandStatus = 12,
    kGamepadRead = 13,
    STATUS_NOT_SET = 0,
  };

  static inline const SecondaryDeviceStatus* internal_default_instance() {
    return reinterpret_cast<const SecondaryDeviceStatus*>(
               &_SecondaryDeviceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SecondaryDeviceStatus& a, SecondaryDeviceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SecondaryDeviceStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecondaryDeviceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecondaryDeviceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecondaryDeviceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecondaryDeviceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SecondaryDeviceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecondaryDeviceStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SecondaryDeviceStatus";
  }
  protected:
  explicit SecondaryDeviceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
    kDeviceTypeFieldNumber = 2,
    kImuDataFieldNumber = 11,
    kHandStatusFieldNumber = 12,
    kGamepadReadFieldNumber = 13,
  };
  // uint32 device_id = 1;
  void clear_device_id();
  uint32_t device_id() const;
  void set_device_id(uint32_t value);
  private:
  uint32_t _internal_device_id() const;
  void _internal_set_device_id(uint32_t value);
  public:

  // .SecondaryDeviceType device_type = 2;
  void clear_device_type();
  ::SecondaryDeviceType device_type() const;
  void set_device_type(::SecondaryDeviceType value);
  private:
  ::SecondaryDeviceType _internal_device_type() const;
  void _internal_set_device_type(::SecondaryDeviceType value);
  public:

  // .ImuData imu_data = 11;
  bool has_imu_data() const;
  private:
  bool _internal_has_imu_data() const;
  public:
  void clear_imu_data();
  const ::ImuData& imu_data() const;
  PROTOBUF_NODISCARD ::ImuData* release_imu_data();
  ::ImuData* mutable_imu_data();
  void set_allocated_imu_data(::ImuData* imu_data);
  private:
  const ::ImuData& _internal_imu_data() const;
  ::ImuData* _internal_mutable_imu_data();
  public:
  void unsafe_arena_set_allocated_imu_data(
      ::ImuData* imu_data);
  ::ImuData* unsafe_arena_release_imu_data();

  // .HandStatus hand_status = 12;
  bool has_hand_status() const;
  private:
  bool _internal_has_hand_status() const;
  public:
  void clear_hand_status();
  const ::HandStatus& hand_status() const;
  PROTOBUF_NODISCARD ::HandStatus* release_hand_status();
  ::HandStatus* mutable_hand_status();
  void set_allocated_hand_status(::HandStatus* hand_status);
  private:
  const ::HandStatus& _internal_hand_status() const;
  ::HandStatus* _internal_mutable_hand_status();
  public:
  void unsafe_arena_set_allocated_hand_status(
      ::HandStatus* hand_status);
  ::HandStatus* unsafe_arena_release_hand_status();

  // .GamepadRead gamepad_read = 13;
  bool has_gamepad_read() const;
  private:
  bool _internal_has_gamepad_read() const;
  public:
  void clear_gamepad_read();
  const ::GamepadRead& gamepad_read() const;
  PROTOBUF_NODISCARD ::GamepadRead* release_gamepad_read();
  ::GamepadRead* mutable_gamepad_read();
  void set_allocated_gamepad_read(::GamepadRead* gamepad_read);
  private:
  const ::GamepadRead& _internal_gamepad_read() const;
  ::GamepadRead* _internal_mutable_gamepad_read();
  public:
  void unsafe_arena_set_allocated_gamepad_read(
      ::GamepadRead* gamepad_read);
  ::GamepadRead* unsafe_arena_release_gamepad_read();

  void clear_status();
  StatusCase status_case() const;
  // @@protoc_insertion_point(class_scope:SecondaryDeviceStatus)
 private:
  class _Internal;
  void set_has_imu_data();
  void set_has_hand_status();
  void set_has_gamepad_read();

  inline bool has_status() const;
  inline void clear_has_status();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t device_id_;
  int device_type_;
  union StatusUnion {
    constexpr StatusUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ImuData* imu_data_;
    ::HandStatus* hand_status_;
    ::GamepadRead* gamepad_read_;
  } status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SecondaryDeviceCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SecondaryDeviceCommand) */ {
 public:
  inline SecondaryDeviceCommand() : SecondaryDeviceCommand(nullptr) {}
  ~SecondaryDeviceCommand() override;
  explicit constexpr SecondaryDeviceCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecondaryDeviceCommand(const SecondaryDeviceCommand& from);
  SecondaryDeviceCommand(SecondaryDeviceCommand&& from) noexcept
    : SecondaryDeviceCommand() {
    *this = ::std::move(from);
  }

  inline SecondaryDeviceCommand& operator=(const SecondaryDeviceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecondaryDeviceCommand& operator=(SecondaryDeviceCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecondaryDeviceCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kHandCommand = 12,
    COMMAND_NOT_SET = 0,
  };

  static inline const SecondaryDeviceCommand* internal_default_instance() {
    return reinterpret_cast<const SecondaryDeviceCommand*>(
               &_SecondaryDeviceCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SecondaryDeviceCommand& a, SecondaryDeviceCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(SecondaryDeviceCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecondaryDeviceCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecondaryDeviceCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecondaryDeviceCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecondaryDeviceCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SecondaryDeviceCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecondaryDeviceCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SecondaryDeviceCommand";
  }
  protected:
  explicit SecondaryDeviceCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
    kHandCommandFieldNumber = 12,
  };
  // uint32 device_id = 1;
  void clear_device_id();
  uint32_t device_id() const;
  void set_device_id(uint32_t value);
  private:
  uint32_t _internal_device_id() const;
  void _internal_set_device_id(uint32_t value);
  public:

  // .HandCommand hand_command = 12;
  bool has_hand_command() const;
  private:
  bool _internal_has_hand_command() const;
  public:
  void clear_hand_command();
  const ::HandCommand& hand_command() const;
  PROTOBUF_NODISCARD ::HandCommand* release_hand_command();
  ::HandCommand* mutable_hand_command();
  void set_allocated_hand_command(::HandCommand* hand_command);
  private:
  const ::HandCommand& _internal_hand_command() const;
  ::HandCommand* _internal_mutable_hand_command();
  public:
  void unsafe_arena_set_allocated_hand_command(
      ::HandCommand* hand_command);
  ::HandCommand* unsafe_arena_release_hand_command();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:SecondaryDeviceCommand)
 private:
  class _Internal;
  void set_has_hand_command();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t device_id_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::HandCommand* hand_command_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_public_5fapi_5ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BaseEstimatedOdometry

// float speed_x = 1;
inline void BaseEstimatedOdometry::clear_speed_x() {
  speed_x_ = 0;
}
inline float BaseEstimatedOdometry::_internal_speed_x() const {
  return speed_x_;
}
inline float BaseEstimatedOdometry::speed_x() const {
  // @@protoc_insertion_point(field_get:BaseEstimatedOdometry.speed_x)
  return _internal_speed_x();
}
inline void BaseEstimatedOdometry::_internal_set_speed_x(float value) {
  
  speed_x_ = value;
}
inline void BaseEstimatedOdometry::set_speed_x(float value) {
  _internal_set_speed_x(value);
  // @@protoc_insertion_point(field_set:BaseEstimatedOdometry.speed_x)
}

// float speed_y = 2;
inline void BaseEstimatedOdometry::clear_speed_y() {
  speed_y_ = 0;
}
inline float BaseEstimatedOdometry::_internal_speed_y() const {
  return speed_y_;
}
inline float BaseEstimatedOdometry::speed_y() const {
  // @@protoc_insertion_point(field_get:BaseEstimatedOdometry.speed_y)
  return _internal_speed_y();
}
inline void BaseEstimatedOdometry::_internal_set_speed_y(float value) {
  
  speed_y_ = value;
}
inline void BaseEstimatedOdometry::set_speed_y(float value) {
  _internal_set_speed_y(value);
  // @@protoc_insertion_point(field_set:BaseEstimatedOdometry.speed_y)
}

// float speed_z = 3;
inline void BaseEstimatedOdometry::clear_speed_z() {
  speed_z_ = 0;
}
inline float BaseEstimatedOdometry::_internal_speed_z() const {
  return speed_z_;
}
inline float BaseEstimatedOdometry::speed_z() const {
  // @@protoc_insertion_point(field_get:BaseEstimatedOdometry.speed_z)
  return _internal_speed_z();
}
inline void BaseEstimatedOdometry::_internal_set_speed_z(float value) {
  
  speed_z_ = value;
}
inline void BaseEstimatedOdometry::set_speed_z(float value) {
  _internal_set_speed_z(value);
  // @@protoc_insertion_point(field_set:BaseEstimatedOdometry.speed_z)
}

// double pos_x = 4;
inline void BaseEstimatedOdometry::clear_pos_x() {
  pos_x_ = 0;
}
inline double BaseEstimatedOdometry::_internal_pos_x() const {
  return pos_x_;
}
inline double BaseEstimatedOdometry::pos_x() const {
  // @@protoc_insertion_point(field_get:BaseEstimatedOdometry.pos_x)
  return _internal_pos_x();
}
inline void BaseEstimatedOdometry::_internal_set_pos_x(double value) {
  
  pos_x_ = value;
}
inline void BaseEstimatedOdometry::set_pos_x(double value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:BaseEstimatedOdometry.pos_x)
}

// double pos_y = 5;
inline void BaseEstimatedOdometry::clear_pos_y() {
  pos_y_ = 0;
}
inline double BaseEstimatedOdometry::_internal_pos_y() const {
  return pos_y_;
}
inline double BaseEstimatedOdometry::pos_y() const {
  // @@protoc_insertion_point(field_get:BaseEstimatedOdometry.pos_y)
  return _internal_pos_y();
}
inline void BaseEstimatedOdometry::_internal_set_pos_y(double value) {
  
  pos_y_ = value;
}
inline void BaseEstimatedOdometry::set_pos_y(double value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:BaseEstimatedOdometry.pos_y)
}

// double pos_z = 6;
inline void BaseEstimatedOdometry::clear_pos_z() {
  pos_z_ = 0;
}
inline double BaseEstimatedOdometry::_internal_pos_z() const {
  return pos_z_;
}
inline double BaseEstimatedOdometry::pos_z() const {
  // @@protoc_insertion_point(field_get:BaseEstimatedOdometry.pos_z)
  return _internal_pos_z();
}
inline void BaseEstimatedOdometry::_internal_set_pos_z(double value) {
  
  pos_z_ = value;
}
inline void BaseEstimatedOdometry::set_pos_z(double value) {
  _internal_set_pos_z(value);
  // @@protoc_insertion_point(field_set:BaseEstimatedOdometry.pos_z)
}

// -------------------------------------------------------------------

// BaseStatus

// .BaseState state = 1;
inline void BaseStatus::clear_state() {
  state_ = 0;
}
inline ::BaseState BaseStatus::_internal_state() const {
  return static_cast< ::BaseState >(state_);
}
inline ::BaseState BaseStatus::state() const {
  // @@protoc_insertion_point(field_get:BaseStatus.state)
  return _internal_state();
}
inline void BaseStatus::_internal_set_state(::BaseState value) {
  
  state_ = value;
}
inline void BaseStatus::set_state(::BaseState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:BaseStatus.state)
}

// bool api_control_initialized = 2;
inline void BaseStatus::clear_api_control_initialized() {
  api_control_initialized_ = false;
}
inline bool BaseStatus::_internal_api_control_initialized() const {
  return api_control_initialized_;
}
inline bool BaseStatus::api_control_initialized() const {
  // @@protoc_insertion_point(field_get:BaseStatus.api_control_initialized)
  return _internal_api_control_initialized();
}
inline void BaseStatus::_internal_set_api_control_initialized(bool value) {
  
  api_control_initialized_ = value;
}
inline void BaseStatus::set_api_control_initialized(bool value) {
  _internal_set_api_control_initialized(value);
  // @@protoc_insertion_point(field_set:BaseStatus.api_control_initialized)
}

// float battery_voltage = 3;
inline void BaseStatus::clear_battery_voltage() {
  battery_voltage_ = 0;
}
inline float BaseStatus::_internal_battery_voltage() const {
  return battery_voltage_;
}
inline float BaseStatus::battery_voltage() const {
  // @@protoc_insertion_point(field_get:BaseStatus.battery_voltage)
  return _internal_battery_voltage();
}
inline void BaseStatus::_internal_set_battery_voltage(float value) {
  
  battery_voltage_ = value;
}
inline void BaseStatus::set_battery_voltage(float value) {
  _internal_set_battery_voltage(value);
  // @@protoc_insertion_point(field_set:BaseStatus.battery_voltage)
}

// uint32 battery_thousandth = 4;
inline void BaseStatus::clear_battery_thousandth() {
  battery_thousandth_ = 0u;
}
inline uint32_t BaseStatus::_internal_battery_thousandth() const {
  return battery_thousandth_;
}
inline uint32_t BaseStatus::battery_thousandth() const {
  // @@protoc_insertion_point(field_get:BaseStatus.battery_thousandth)
  return _internal_battery_thousandth();
}
inline void BaseStatus::_internal_set_battery_thousandth(uint32_t value) {
  
  battery_thousandth_ = value;
}
inline void BaseStatus::set_battery_thousandth(uint32_t value) {
  _internal_set_battery_thousandth(value);
  // @@protoc_insertion_point(field_set:BaseStatus.battery_thousandth)
}

// repeated .MotorStatus motor_status = 5;
inline int BaseStatus::_internal_motor_status_size() const {
  return motor_status_.size();
}
inline int BaseStatus::motor_status_size() const {
  return _internal_motor_status_size();
}
inline void BaseStatus::clear_motor_status() {
  motor_status_.Clear();
}
inline ::MotorStatus* BaseStatus::mutable_motor_status(int index) {
  // @@protoc_insertion_point(field_mutable:BaseStatus.motor_status)
  return motor_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
BaseStatus::mutable_motor_status() {
  // @@protoc_insertion_point(field_mutable_list:BaseStatus.motor_status)
  return &motor_status_;
}
inline const ::MotorStatus& BaseStatus::_internal_motor_status(int index) const {
  return motor_status_.Get(index);
}
inline const ::MotorStatus& BaseStatus::motor_status(int index) const {
  // @@protoc_insertion_point(field_get:BaseStatus.motor_status)
  return _internal_motor_status(index);
}
inline ::MotorStatus* BaseStatus::_internal_add_motor_status() {
  return motor_status_.Add();
}
inline ::MotorStatus* BaseStatus::add_motor_status() {
  ::MotorStatus* _add = _internal_add_motor_status();
  // @@protoc_insertion_point(field_add:BaseStatus.motor_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
BaseStatus::motor_status() const {
  // @@protoc_insertion_point(field_list:BaseStatus.motor_status)
  return motor_status_;
}

// uint32 session_holder = 6;
inline void BaseStatus::clear_session_holder() {
  session_holder_ = 0u;
}
inline uint32_t BaseStatus::_internal_session_holder() const {
  return session_holder_;
}
inline uint32_t BaseStatus::session_holder() const {
  // @@protoc_insertion_point(field_get:BaseStatus.session_holder)
  return _internal_session_holder();
}
inline void BaseStatus::_internal_set_session_holder(uint32_t value) {
  
  session_holder_ = value;
}
inline void BaseStatus::set_session_holder(uint32_t value) {
  _internal_set_session_holder(value);
  // @@protoc_insertion_point(field_set:BaseStatus.session_holder)
}

// optional bool battery_charging = 10;
inline bool BaseStatus::_internal_has_battery_charging() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaseStatus::has_battery_charging() const {
  return _internal_has_battery_charging();
}
inline void BaseStatus::clear_battery_charging() {
  battery_charging_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool BaseStatus::_internal_battery_charging() const {
  return battery_charging_;
}
inline bool BaseStatus::battery_charging() const {
  // @@protoc_insertion_point(field_get:BaseStatus.battery_charging)
  return _internal_battery_charging();
}
inline void BaseStatus::_internal_set_battery_charging(bool value) {
  _has_bits_[0] |= 0x00000004u;
  battery_charging_ = value;
}
inline void BaseStatus::set_battery_charging(bool value) {
  _internal_set_battery_charging(value);
  // @@protoc_insertion_point(field_set:BaseStatus.battery_charging)
}

// optional .ParkingStopDetail parking_stop_detail = 11;
inline bool BaseStatus::_internal_has_parking_stop_detail() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || parking_stop_detail_ != nullptr);
  return value;
}
inline bool BaseStatus::has_parking_stop_detail() const {
  return _internal_has_parking_stop_detail();
}
inline void BaseStatus::clear_parking_stop_detail() {
  if (parking_stop_detail_ != nullptr) parking_stop_detail_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ParkingStopDetail& BaseStatus::_internal_parking_stop_detail() const {
  const ::ParkingStopDetail* p = parking_stop_detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::ParkingStopDetail&>(
      ::_ParkingStopDetail_default_instance_);
}
inline const ::ParkingStopDetail& BaseStatus::parking_stop_detail() const {
  // @@protoc_insertion_point(field_get:BaseStatus.parking_stop_detail)
  return _internal_parking_stop_detail();
}
inline void BaseStatus::unsafe_arena_set_allocated_parking_stop_detail(
    ::ParkingStopDetail* parking_stop_detail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parking_stop_detail_);
  }
  parking_stop_detail_ = parking_stop_detail;
  if (parking_stop_detail) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseStatus.parking_stop_detail)
}
inline ::ParkingStopDetail* BaseStatus::release_parking_stop_detail() {
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ParkingStopDetail* BaseStatus::unsafe_arena_release_parking_stop_detail() {
  // @@protoc_insertion_point(field_release:BaseStatus.parking_stop_detail)
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
  return temp;
}
inline ::ParkingStopDetail* BaseStatus::_internal_mutable_parking_stop_detail() {
  _has_bits_[0] |= 0x00000001u;
  if (parking_stop_detail_ == nullptr) {
    auto* p = CreateMaybeMessage<::ParkingStopDetail>(GetArenaForAllocation());
    parking_stop_detail_ = p;
  }
  return parking_stop_detail_;
}
inline ::ParkingStopDetail* BaseStatus::mutable_parking_stop_detail() {
  ::ParkingStopDetail* _msg = _internal_mutable_parking_stop_detail();
  // @@protoc_insertion_point(field_mutable:BaseStatus.parking_stop_detail)
  return _msg;
}
inline void BaseStatus::set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete parking_stop_detail_;
  }
  if (parking_stop_detail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ParkingStopDetail>::GetOwningArena(parking_stop_detail);
    if (message_arena != submessage_arena) {
      parking_stop_detail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_stop_detail, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parking_stop_detail_ = parking_stop_detail;
  // @@protoc_insertion_point(field_set_allocated:BaseStatus.parking_stop_detail)
}

// optional .WarningCategory warning = 12;
inline bool BaseStatus::_internal_has_warning() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaseStatus::has_warning() const {
  return _internal_has_warning();
}
inline void BaseStatus::clear_warning() {
  warning_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::WarningCategory BaseStatus::_internal_warning() const {
  return static_cast< ::WarningCategory >(warning_);
}
inline ::WarningCategory BaseStatus::warning() const {
  // @@protoc_insertion_point(field_get:BaseStatus.warning)
  return _internal_warning();
}
inline void BaseStatus::_internal_set_warning(::WarningCategory value) {
  _has_bits_[0] |= 0x00000008u;
  warning_ = value;
}
inline void BaseStatus::set_warning(::WarningCategory value) {
  _internal_set_warning(value);
  // @@protoc_insertion_point(field_set:BaseStatus.warning)
}

// optional .BaseEstimatedOdometry estimated_odometry = 13;
inline bool BaseStatus::_internal_has_estimated_odometry() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || estimated_odometry_ != nullptr);
  return value;
}
inline bool BaseStatus::has_estimated_odometry() const {
  return _internal_has_estimated_odometry();
}
inline void BaseStatus::clear_estimated_odometry() {
  if (estimated_odometry_ != nullptr) estimated_odometry_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::BaseEstimatedOdometry& BaseStatus::_internal_estimated_odometry() const {
  const ::BaseEstimatedOdometry* p = estimated_odometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::BaseEstimatedOdometry&>(
      ::_BaseEstimatedOdometry_default_instance_);
}
inline const ::BaseEstimatedOdometry& BaseStatus::estimated_odometry() const {
  // @@protoc_insertion_point(field_get:BaseStatus.estimated_odometry)
  return _internal_estimated_odometry();
}
inline void BaseStatus::unsafe_arena_set_allocated_estimated_odometry(
    ::BaseEstimatedOdometry* estimated_odometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimated_odometry_);
  }
  estimated_odometry_ = estimated_odometry;
  if (estimated_odometry) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseStatus.estimated_odometry)
}
inline ::BaseEstimatedOdometry* BaseStatus::release_estimated_odometry() {
  _has_bits_[0] &= ~0x00000002u;
  ::BaseEstimatedOdometry* temp = estimated_odometry_;
  estimated_odometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BaseEstimatedOdometry* BaseStatus::unsafe_arena_release_estimated_odometry() {
  // @@protoc_insertion_point(field_release:BaseStatus.estimated_odometry)
  _has_bits_[0] &= ~0x00000002u;
  ::BaseEstimatedOdometry* temp = estimated_odometry_;
  estimated_odometry_ = nullptr;
  return temp;
}
inline ::BaseEstimatedOdometry* BaseStatus::_internal_mutable_estimated_odometry() {
  _has_bits_[0] |= 0x00000002u;
  if (estimated_odometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::BaseEstimatedOdometry>(GetArenaForAllocation());
    estimated_odometry_ = p;
  }
  return estimated_odometry_;
}
inline ::BaseEstimatedOdometry* BaseStatus::mutable_estimated_odometry() {
  ::BaseEstimatedOdometry* _msg = _internal_mutable_estimated_odometry();
  // @@protoc_insertion_point(field_mutable:BaseStatus.estimated_odometry)
  return _msg;
}
inline void BaseStatus::set_allocated_estimated_odometry(::BaseEstimatedOdometry* estimated_odometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete estimated_odometry_;
  }
  if (estimated_odometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::BaseEstimatedOdometry>::GetOwningArena(estimated_odometry);
    if (message_arena != submessage_arena) {
      estimated_odometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, estimated_odometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  estimated_odometry_ = estimated_odometry;
  // @@protoc_insertion_point(field_set_allocated:BaseStatus.estimated_odometry)
}

// -------------------------------------------------------------------

// XyzSpeed

// float speed_x = 1;
inline void XyzSpeed::clear_speed_x() {
  speed_x_ = 0;
}
inline float XyzSpeed::_internal_speed_x() const {
  return speed_x_;
}
inline float XyzSpeed::speed_x() const {
  // @@protoc_insertion_point(field_get:XyzSpeed.speed_x)
  return _internal_speed_x();
}
inline void XyzSpeed::_internal_set_speed_x(float value) {
  
  speed_x_ = value;
}
inline void XyzSpeed::set_speed_x(float value) {
  _internal_set_speed_x(value);
  // @@protoc_insertion_point(field_set:XyzSpeed.speed_x)
}

// float speed_y = 2;
inline void XyzSpeed::clear_speed_y() {
  speed_y_ = 0;
}
inline float XyzSpeed::_internal_speed_y() const {
  return speed_y_;
}
inline float XyzSpeed::speed_y() const {
  // @@protoc_insertion_point(field_get:XyzSpeed.speed_y)
  return _internal_speed_y();
}
inline void XyzSpeed::_internal_set_speed_y(float value) {
  
  speed_y_ = value;
}
inline void XyzSpeed::set_speed_y(float value) {
  _internal_set_speed_y(value);
  // @@protoc_insertion_point(field_set:XyzSpeed.speed_y)
}

// float speed_z = 3;
inline void XyzSpeed::clear_speed_z() {
  speed_z_ = 0;
}
inline float XyzSpeed::_internal_speed_z() const {
  return speed_z_;
}
inline float XyzSpeed::speed_z() const {
  // @@protoc_insertion_point(field_get:XyzSpeed.speed_z)
  return _internal_speed_z();
}
inline void XyzSpeed::_internal_set_speed_z(float value) {
  
  speed_z_ = value;
}
inline void XyzSpeed::set_speed_z(float value) {
  _internal_set_speed_z(value);
  // @@protoc_insertion_point(field_set:XyzSpeed.speed_z)
}

// -------------------------------------------------------------------

// SimpleBaseMoveCommand

// .XyzSpeed xyz_speed = 1;
inline bool SimpleBaseMoveCommand::_internal_has_xyz_speed() const {
  return command_case() == kXyzSpeed;
}
inline bool SimpleBaseMoveCommand::has_xyz_speed() const {
  return _internal_has_xyz_speed();
}
inline void SimpleBaseMoveCommand::set_has_xyz_speed() {
  _oneof_case_[0] = kXyzSpeed;
}
inline void SimpleBaseMoveCommand::clear_xyz_speed() {
  if (_internal_has_xyz_speed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.xyz_speed_;
    }
    clear_has_command();
  }
}
inline ::XyzSpeed* SimpleBaseMoveCommand::release_xyz_speed() {
  // @@protoc_insertion_point(field_release:SimpleBaseMoveCommand.xyz_speed)
  if (_internal_has_xyz_speed()) {
    clear_has_command();
      ::XyzSpeed* temp = command_.xyz_speed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.xyz_speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::XyzSpeed& SimpleBaseMoveCommand::_internal_xyz_speed() const {
  return _internal_has_xyz_speed()
      ? *command_.xyz_speed_
      : reinterpret_cast< ::XyzSpeed&>(::_XyzSpeed_default_instance_);
}
inline const ::XyzSpeed& SimpleBaseMoveCommand::xyz_speed() const {
  // @@protoc_insertion_point(field_get:SimpleBaseMoveCommand.xyz_speed)
  return _internal_xyz_speed();
}
inline ::XyzSpeed* SimpleBaseMoveCommand::unsafe_arena_release_xyz_speed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SimpleBaseMoveCommand.xyz_speed)
  if (_internal_has_xyz_speed()) {
    clear_has_command();
    ::XyzSpeed* temp = command_.xyz_speed_;
    command_.xyz_speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SimpleBaseMoveCommand::unsafe_arena_set_allocated_xyz_speed(::XyzSpeed* xyz_speed) {
  clear_command();
  if (xyz_speed) {
    set_has_xyz_speed();
    command_.xyz_speed_ = xyz_speed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SimpleBaseMoveCommand.xyz_speed)
}
inline ::XyzSpeed* SimpleBaseMoveCommand::_internal_mutable_xyz_speed() {
  if (!_internal_has_xyz_speed()) {
    clear_command();
    set_has_xyz_speed();
    command_.xyz_speed_ = CreateMaybeMessage< ::XyzSpeed >(GetArenaForAllocation());
  }
  return command_.xyz_speed_;
}
inline ::XyzSpeed* SimpleBaseMoveCommand::mutable_xyz_speed() {
  ::XyzSpeed* _msg = _internal_mutable_xyz_speed();
  // @@protoc_insertion_point(field_mutable:SimpleBaseMoveCommand.xyz_speed)
  return _msg;
}

// bool zero_resistance = 2;
inline bool SimpleBaseMoveCommand::_internal_has_zero_resistance() const {
  return command_case() == kZeroResistance;
}
inline bool SimpleBaseMoveCommand::has_zero_resistance() const {
  return _internal_has_zero_resistance();
}
inline void SimpleBaseMoveCommand::set_has_zero_resistance() {
  _oneof_case_[0] = kZeroResistance;
}
inline void SimpleBaseMoveCommand::clear_zero_resistance() {
  if (_internal_has_zero_resistance()) {
    command_.zero_resistance_ = false;
    clear_has_command();
  }
}
inline bool SimpleBaseMoveCommand::_internal_zero_resistance() const {
  if (_internal_has_zero_resistance()) {
    return command_.zero_resistance_;
  }
  return false;
}
inline void SimpleBaseMoveCommand::_internal_set_zero_resistance(bool value) {
  if (!_internal_has_zero_resistance()) {
    clear_command();
    set_has_zero_resistance();
  }
  command_.zero_resistance_ = value;
}
inline bool SimpleBaseMoveCommand::zero_resistance() const {
  // @@protoc_insertion_point(field_get:SimpleBaseMoveCommand.zero_resistance)
  return _internal_zero_resistance();
}
inline void SimpleBaseMoveCommand::set_zero_resistance(bool value) {
  _internal_set_zero_resistance(value);
  // @@protoc_insertion_point(field_set:SimpleBaseMoveCommand.zero_resistance)
}

// bool brake = 3;
inline bool SimpleBaseMoveCommand::_internal_has_brake() const {
  return command_case() == kBrake;
}
inline bool SimpleBaseMoveCommand::has_brake() const {
  return _internal_has_brake();
}
inline void SimpleBaseMoveCommand::set_has_brake() {
  _oneof_case_[0] = kBrake;
}
inline void SimpleBaseMoveCommand::clear_brake() {
  if (_internal_has_brake()) {
    command_.brake_ = false;
    clear_has_command();
  }
}
inline bool SimpleBaseMoveCommand::_internal_brake() const {
  if (_internal_has_brake()) {
    return command_.brake_;
  }
  return false;
}
inline void SimpleBaseMoveCommand::_internal_set_brake(bool value) {
  if (!_internal_has_brake()) {
    clear_command();
    set_has_brake();
  }
  command_.brake_ = value;
}
inline bool SimpleBaseMoveCommand::brake() const {
  // @@protoc_insertion_point(field_get:SimpleBaseMoveCommand.brake)
  return _internal_brake();
}
inline void SimpleBaseMoveCommand::set_brake(bool value) {
  _internal_set_brake(value);
  // @@protoc_insertion_point(field_set:SimpleBaseMoveCommand.brake)
}

inline bool SimpleBaseMoveCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void SimpleBaseMoveCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline SimpleBaseMoveCommand::CommandCase SimpleBaseMoveCommand::command_case() const {
  return SimpleBaseMoveCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BaseCommand

// bool api_control_initialize = 1;
inline bool BaseCommand::_internal_has_api_control_initialize() const {
  return command_case() == kApiControlInitialize;
}
inline bool BaseCommand::has_api_control_initialize() const {
  return _internal_has_api_control_initialize();
}
inline void BaseCommand::set_has_api_control_initialize() {
  _oneof_case_[0] = kApiControlInitialize;
}
inline void BaseCommand::clear_api_control_initialize() {
  if (_internal_has_api_control_initialize()) {
    command_.api_control_initialize_ = false;
    clear_has_command();
  }
}
inline bool BaseCommand::_internal_api_control_initialize() const {
  if (_internal_has_api_control_initialize()) {
    return command_.api_control_initialize_;
  }
  return false;
}
inline void BaseCommand::_internal_set_api_control_initialize(bool value) {
  if (!_internal_has_api_control_initialize()) {
    clear_command();
    set_has_api_control_initialize();
  }
  command_.api_control_initialize_ = value;
}
inline bool BaseCommand::api_control_initialize() const {
  // @@protoc_insertion_point(field_get:BaseCommand.api_control_initialize)
  return _internal_api_control_initialize();
}
inline void BaseCommand::set_api_control_initialize(bool value) {
  _internal_set_api_control_initialize(value);
  // @@protoc_insertion_point(field_set:BaseCommand.api_control_initialize)
}

// bool clear_parking_stop = 2;
inline bool BaseCommand::_internal_has_clear_parking_stop() const {
  return command_case() == kClearParkingStop;
}
inline bool BaseCommand::has_clear_parking_stop() const {
  return _internal_has_clear_parking_stop();
}
inline void BaseCommand::set_has_clear_parking_stop() {
  _oneof_case_[0] = kClearParkingStop;
}
inline void BaseCommand::clear_clear_parking_stop() {
  if (_internal_has_clear_parking_stop()) {
    command_.clear_parking_stop_ = false;
    clear_has_command();
  }
}
inline bool BaseCommand::_internal_clear_parking_stop() const {
  if (_internal_has_clear_parking_stop()) {
    return command_.clear_parking_stop_;
  }
  return false;
}
inline void BaseCommand::_internal_set_clear_parking_stop(bool value) {
  if (!_internal_has_clear_parking_stop()) {
    clear_command();
    set_has_clear_parking_stop();
  }
  command_.clear_parking_stop_ = value;
}
inline bool BaseCommand::clear_parking_stop() const {
  // @@protoc_insertion_point(field_get:BaseCommand.clear_parking_stop)
  return _internal_clear_parking_stop();
}
inline void BaseCommand::set_clear_parking_stop(bool value) {
  _internal_set_clear_parking_stop(value);
  // @@protoc_insertion_point(field_set:BaseCommand.clear_parking_stop)
}

// .MotorTargets motor_targets = 3;
inline bool BaseCommand::_internal_has_motor_targets() const {
  return command_case() == kMotorTargets;
}
inline bool BaseCommand::has_motor_targets() const {
  return _internal_has_motor_targets();
}
inline void BaseCommand::set_has_motor_targets() {
  _oneof_case_[0] = kMotorTargets;
}
inline void BaseCommand::clear_motor_targets() {
  if (_internal_has_motor_targets()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.motor_targets_;
    }
    clear_has_command();
  }
}
inline ::MotorTargets* BaseCommand::release_motor_targets() {
  // @@protoc_insertion_point(field_release:BaseCommand.motor_targets)
  if (_internal_has_motor_targets()) {
    clear_has_command();
      ::MotorTargets* temp = command_.motor_targets_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.motor_targets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MotorTargets& BaseCommand::_internal_motor_targets() const {
  return _internal_has_motor_targets()
      ? *command_.motor_targets_
      : reinterpret_cast< ::MotorTargets&>(::_MotorTargets_default_instance_);
}
inline const ::MotorTargets& BaseCommand::motor_targets() const {
  // @@protoc_insertion_point(field_get:BaseCommand.motor_targets)
  return _internal_motor_targets();
}
inline ::MotorTargets* BaseCommand::unsafe_arena_release_motor_targets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseCommand.motor_targets)
  if (_internal_has_motor_targets()) {
    clear_has_command();
    ::MotorTargets* temp = command_.motor_targets_;
    command_.motor_targets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseCommand::unsafe_arena_set_allocated_motor_targets(::MotorTargets* motor_targets) {
  clear_command();
  if (motor_targets) {
    set_has_motor_targets();
    command_.motor_targets_ = motor_targets;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseCommand.motor_targets)
}
inline ::MotorTargets* BaseCommand::_internal_mutable_motor_targets() {
  if (!_internal_has_motor_targets()) {
    clear_command();
    set_has_motor_targets();
    command_.motor_targets_ = CreateMaybeMessage< ::MotorTargets >(GetArenaForAllocation());
  }
  return command_.motor_targets_;
}
inline ::MotorTargets* BaseCommand::mutable_motor_targets() {
  ::MotorTargets* _msg = _internal_mutable_motor_targets();
  // @@protoc_insertion_point(field_mutable:BaseCommand.motor_targets)
  return _msg;
}

// .SimpleBaseMoveCommand simple_move_command = 5;
inline bool BaseCommand::_internal_has_simple_move_command() const {
  return command_case() == kSimpleMoveCommand;
}
inline bool BaseCommand::has_simple_move_command() const {
  return _internal_has_simple_move_command();
}
inline void BaseCommand::set_has_simple_move_command() {
  _oneof_case_[0] = kSimpleMoveCommand;
}
inline void BaseCommand::clear_simple_move_command() {
  if (_internal_has_simple_move_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.simple_move_command_;
    }
    clear_has_command();
  }
}
inline ::SimpleBaseMoveCommand* BaseCommand::release_simple_move_command() {
  // @@protoc_insertion_point(field_release:BaseCommand.simple_move_command)
  if (_internal_has_simple_move_command()) {
    clear_has_command();
      ::SimpleBaseMoveCommand* temp = command_.simple_move_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.simple_move_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SimpleBaseMoveCommand& BaseCommand::_internal_simple_move_command() const {
  return _internal_has_simple_move_command()
      ? *command_.simple_move_command_
      : reinterpret_cast< ::SimpleBaseMoveCommand&>(::_SimpleBaseMoveCommand_default_instance_);
}
inline const ::SimpleBaseMoveCommand& BaseCommand::simple_move_command() const {
  // @@protoc_insertion_point(field_get:BaseCommand.simple_move_command)
  return _internal_simple_move_command();
}
inline ::SimpleBaseMoveCommand* BaseCommand::unsafe_arena_release_simple_move_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:BaseCommand.simple_move_command)
  if (_internal_has_simple_move_command()) {
    clear_has_command();
    ::SimpleBaseMoveCommand* temp = command_.simple_move_command_;
    command_.simple_move_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BaseCommand::unsafe_arena_set_allocated_simple_move_command(::SimpleBaseMoveCommand* simple_move_command) {
  clear_command();
  if (simple_move_command) {
    set_has_simple_move_command();
    command_.simple_move_command_ = simple_move_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BaseCommand.simple_move_command)
}
inline ::SimpleBaseMoveCommand* BaseCommand::_internal_mutable_simple_move_command() {
  if (!_internal_has_simple_move_command()) {
    clear_command();
    set_has_simple_move_command();
    command_.simple_move_command_ = CreateMaybeMessage< ::SimpleBaseMoveCommand >(GetArenaForAllocation());
  }
  return command_.simple_move_command_;
}
inline ::SimpleBaseMoveCommand* BaseCommand::mutable_simple_move_command() {
  ::SimpleBaseMoveCommand* _msg = _internal_mutable_simple_move_command();
  // @@protoc_insertion_point(field_mutable:BaseCommand.simple_move_command)
  return _msg;
}

inline bool BaseCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void BaseCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline BaseCommand::CommandCase BaseCommand::command_case() const {
  return BaseCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RotateLiftStatus

// bool calibrated = 1;
inline void RotateLiftStatus::clear_calibrated() {
  calibrated_ = false;
}
inline bool RotateLiftStatus::_internal_calibrated() const {
  return calibrated_;
}
inline bool RotateLiftStatus::calibrated() const {
  // @@protoc_insertion_point(field_get:RotateLiftStatus.calibrated)
  return _internal_calibrated();
}
inline void RotateLiftStatus::_internal_set_calibrated(bool value) {
  
  calibrated_ = value;
}
inline void RotateLiftStatus::set_calibrated(bool value) {
  _internal_set_calibrated(value);
  // @@protoc_insertion_point(field_set:RotateLiftStatus.calibrated)
}

// .LiftState state = 2;
inline void RotateLiftStatus::clear_state() {
  state_ = 0;
}
inline ::LiftState RotateLiftStatus::_internal_state() const {
  return static_cast< ::LiftState >(state_);
}
inline ::LiftState RotateLiftStatus::state() const {
  // @@protoc_insertion_point(field_get:RotateLiftStatus.state)
  return _internal_state();
}
inline void RotateLiftStatus::_internal_set_state(::LiftState value) {
  
  state_ = value;
}
inline void RotateLiftStatus::set_state(::LiftState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:RotateLiftStatus.state)
}

// repeated .MotorStatus motor_status = 3;
inline int RotateLiftStatus::_internal_motor_status_size() const {
  return motor_status_.size();
}
inline int RotateLiftStatus::motor_status_size() const {
  return _internal_motor_status_size();
}
inline void RotateLiftStatus::clear_motor_status() {
  motor_status_.Clear();
}
inline ::MotorStatus* RotateLiftStatus::mutable_motor_status(int index) {
  // @@protoc_insertion_point(field_mutable:RotateLiftStatus.motor_status)
  return motor_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
RotateLiftStatus::mutable_motor_status() {
  // @@protoc_insertion_point(field_mutable_list:RotateLiftStatus.motor_status)
  return &motor_status_;
}
inline const ::MotorStatus& RotateLiftStatus::_internal_motor_status(int index) const {
  return motor_status_.Get(index);
}
inline const ::MotorStatus& RotateLiftStatus::motor_status(int index) const {
  // @@protoc_insertion_point(field_get:RotateLiftStatus.motor_status)
  return _internal_motor_status(index);
}
inline ::MotorStatus* RotateLiftStatus::_internal_add_motor_status() {
  return motor_status_.Add();
}
inline ::MotorStatus* RotateLiftStatus::add_motor_status() {
  ::MotorStatus* _add = _internal_add_motor_status();
  // @@protoc_insertion_point(field_add:RotateLiftStatus.motor_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
RotateLiftStatus::motor_status() const {
  // @@protoc_insertion_point(field_list:RotateLiftStatus.motor_status)
  return motor_status_;
}

// repeated int32 max_pos = 4;
inline int RotateLiftStatus::_internal_max_pos_size() const {
  return max_pos_.size();
}
inline int RotateLiftStatus::max_pos_size() const {
  return _internal_max_pos_size();
}
inline void RotateLiftStatus::clear_max_pos() {
  max_pos_.Clear();
}
inline int32_t RotateLiftStatus::_internal_max_pos(int index) const {
  return max_pos_.Get(index);
}
inline int32_t RotateLiftStatus::max_pos(int index) const {
  // @@protoc_insertion_point(field_get:RotateLiftStatus.max_pos)
  return _internal_max_pos(index);
}
inline void RotateLiftStatus::set_max_pos(int index, int32_t value) {
  max_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:RotateLiftStatus.max_pos)
}
inline void RotateLiftStatus::_internal_add_max_pos(int32_t value) {
  max_pos_.Add(value);
}
inline void RotateLiftStatus::add_max_pos(int32_t value) {
  _internal_add_max_pos(value);
  // @@protoc_insertion_point(field_add:RotateLiftStatus.max_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RotateLiftStatus::_internal_max_pos() const {
  return max_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RotateLiftStatus::max_pos() const {
  // @@protoc_insertion_point(field_list:RotateLiftStatus.max_pos)
  return _internal_max_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RotateLiftStatus::_internal_mutable_max_pos() {
  return &max_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RotateLiftStatus::mutable_max_pos() {
  // @@protoc_insertion_point(field_mutable_list:RotateLiftStatus.max_pos)
  return _internal_mutable_max_pos();
}

// repeated int32 min_pos = 5;
inline int RotateLiftStatus::_internal_min_pos_size() const {
  return min_pos_.size();
}
inline int RotateLiftStatus::min_pos_size() const {
  return _internal_min_pos_size();
}
inline void RotateLiftStatus::clear_min_pos() {
  min_pos_.Clear();
}
inline int32_t RotateLiftStatus::_internal_min_pos(int index) const {
  return min_pos_.Get(index);
}
inline int32_t RotateLiftStatus::min_pos(int index) const {
  // @@protoc_insertion_point(field_get:RotateLiftStatus.min_pos)
  return _internal_min_pos(index);
}
inline void RotateLiftStatus::set_min_pos(int index, int32_t value) {
  min_pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:RotateLiftStatus.min_pos)
}
inline void RotateLiftStatus::_internal_add_min_pos(int32_t value) {
  min_pos_.Add(value);
}
inline void RotateLiftStatus::add_min_pos(int32_t value) {
  _internal_add_min_pos(value);
  // @@protoc_insertion_point(field_add:RotateLiftStatus.min_pos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RotateLiftStatus::_internal_min_pos() const {
  return min_pos_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RotateLiftStatus::min_pos() const {
  // @@protoc_insertion_point(field_list:RotateLiftStatus.min_pos)
  return _internal_min_pos();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RotateLiftStatus::_internal_mutable_min_pos() {
  return &min_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RotateLiftStatus::mutable_min_pos() {
  // @@protoc_insertion_point(field_mutable_list:RotateLiftStatus.min_pos)
  return _internal_mutable_min_pos();
}

// optional .ParkingStopDetail parking_stop_detail = 10;
inline bool RotateLiftStatus::_internal_has_parking_stop_detail() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || parking_stop_detail_ != nullptr);
  return value;
}
inline bool RotateLiftStatus::has_parking_stop_detail() const {
  return _internal_has_parking_stop_detail();
}
inline void RotateLiftStatus::clear_parking_stop_detail() {
  if (parking_stop_detail_ != nullptr) parking_stop_detail_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ParkingStopDetail& RotateLiftStatus::_internal_parking_stop_detail() const {
  const ::ParkingStopDetail* p = parking_stop_detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::ParkingStopDetail&>(
      ::_ParkingStopDetail_default_instance_);
}
inline const ::ParkingStopDetail& RotateLiftStatus::parking_stop_detail() const {
  // @@protoc_insertion_point(field_get:RotateLiftStatus.parking_stop_detail)
  return _internal_parking_stop_detail();
}
inline void RotateLiftStatus::unsafe_arena_set_allocated_parking_stop_detail(
    ::ParkingStopDetail* parking_stop_detail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parking_stop_detail_);
  }
  parking_stop_detail_ = parking_stop_detail;
  if (parking_stop_detail) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RotateLiftStatus.parking_stop_detail)
}
inline ::ParkingStopDetail* RotateLiftStatus::release_parking_stop_detail() {
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ParkingStopDetail* RotateLiftStatus::unsafe_arena_release_parking_stop_detail() {
  // @@protoc_insertion_point(field_release:RotateLiftStatus.parking_stop_detail)
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
  return temp;
}
inline ::ParkingStopDetail* RotateLiftStatus::_internal_mutable_parking_stop_detail() {
  _has_bits_[0] |= 0x00000001u;
  if (parking_stop_detail_ == nullptr) {
    auto* p = CreateMaybeMessage<::ParkingStopDetail>(GetArenaForAllocation());
    parking_stop_detail_ = p;
  }
  return parking_stop_detail_;
}
inline ::ParkingStopDetail* RotateLiftStatus::mutable_parking_stop_detail() {
  ::ParkingStopDetail* _msg = _internal_mutable_parking_stop_detail();
  // @@protoc_insertion_point(field_mutable:RotateLiftStatus.parking_stop_detail)
  return _msg;
}
inline void RotateLiftStatus::set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete parking_stop_detail_;
  }
  if (parking_stop_detail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ParkingStopDetail>::GetOwningArena(parking_stop_detail);
    if (message_arena != submessage_arena) {
      parking_stop_detail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_stop_detail, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parking_stop_detail_ = parking_stop_detail;
  // @@protoc_insertion_point(field_set_allocated:RotateLiftStatus.parking_stop_detail)
}

// -------------------------------------------------------------------

// RotateLiftRuntimeConfig

// repeated double pos_mode_max_speed = 1;
inline int RotateLiftRuntimeConfig::_internal_pos_mode_max_speed_size() const {
  return pos_mode_max_speed_.size();
}
inline int RotateLiftRuntimeConfig::pos_mode_max_speed_size() const {
  return _internal_pos_mode_max_speed_size();
}
inline void RotateLiftRuntimeConfig::clear_pos_mode_max_speed() {
  pos_mode_max_speed_.Clear();
}
inline double RotateLiftRuntimeConfig::_internal_pos_mode_max_speed(int index) const {
  return pos_mode_max_speed_.Get(index);
}
inline double RotateLiftRuntimeConfig::pos_mode_max_speed(int index) const {
  // @@protoc_insertion_point(field_get:RotateLiftRuntimeConfig.pos_mode_max_speed)
  return _internal_pos_mode_max_speed(index);
}
inline void RotateLiftRuntimeConfig::set_pos_mode_max_speed(int index, double value) {
  pos_mode_max_speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:RotateLiftRuntimeConfig.pos_mode_max_speed)
}
inline void RotateLiftRuntimeConfig::_internal_add_pos_mode_max_speed(double value) {
  pos_mode_max_speed_.Add(value);
}
inline void RotateLiftRuntimeConfig::add_pos_mode_max_speed(double value) {
  _internal_add_pos_mode_max_speed(value);
  // @@protoc_insertion_point(field_add:RotateLiftRuntimeConfig.pos_mode_max_speed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RotateLiftRuntimeConfig::_internal_pos_mode_max_speed() const {
  return pos_mode_max_speed_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RotateLiftRuntimeConfig::pos_mode_max_speed() const {
  // @@protoc_insertion_point(field_list:RotateLiftRuntimeConfig.pos_mode_max_speed)
  return _internal_pos_mode_max_speed();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RotateLiftRuntimeConfig::_internal_mutable_pos_mode_max_speed() {
  return &pos_mode_max_speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RotateLiftRuntimeConfig::mutable_pos_mode_max_speed() {
  // @@protoc_insertion_point(field_mutable_list:RotateLiftRuntimeConfig.pos_mode_max_speed)
  return _internal_mutable_pos_mode_max_speed();
}

// -------------------------------------------------------------------

// RotateLiftCommand

// bool calibrate = 1;
inline bool RotateLiftCommand::_internal_has_calibrate() const {
  return command_case() == kCalibrate;
}
inline bool RotateLiftCommand::has_calibrate() const {
  return _internal_has_calibrate();
}
inline void RotateLiftCommand::set_has_calibrate() {
  _oneof_case_[0] = kCalibrate;
}
inline void RotateLiftCommand::clear_calibrate() {
  if (_internal_has_calibrate()) {
    command_.calibrate_ = false;
    clear_has_command();
  }
}
inline bool RotateLiftCommand::_internal_calibrate() const {
  if (_internal_has_calibrate()) {
    return command_.calibrate_;
  }
  return false;
}
inline void RotateLiftCommand::_internal_set_calibrate(bool value) {
  if (!_internal_has_calibrate()) {
    clear_command();
    set_has_calibrate();
  }
  command_.calibrate_ = value;
}
inline bool RotateLiftCommand::calibrate() const {
  // @@protoc_insertion_point(field_get:RotateLiftCommand.calibrate)
  return _internal_calibrate();
}
inline void RotateLiftCommand::set_calibrate(bool value) {
  _internal_set_calibrate(value);
  // @@protoc_insertion_point(field_set:RotateLiftCommand.calibrate)
}

// .MotorTargets motor_targets = 2;
inline bool RotateLiftCommand::_internal_has_motor_targets() const {
  return command_case() == kMotorTargets;
}
inline bool RotateLiftCommand::has_motor_targets() const {
  return _internal_has_motor_targets();
}
inline void RotateLiftCommand::set_has_motor_targets() {
  _oneof_case_[0] = kMotorTargets;
}
inline void RotateLiftCommand::clear_motor_targets() {
  if (_internal_has_motor_targets()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.motor_targets_;
    }
    clear_has_command();
  }
}
inline ::MotorTargets* RotateLiftCommand::release_motor_targets() {
  // @@protoc_insertion_point(field_release:RotateLiftCommand.motor_targets)
  if (_internal_has_motor_targets()) {
    clear_has_command();
      ::MotorTargets* temp = command_.motor_targets_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.motor_targets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MotorTargets& RotateLiftCommand::_internal_motor_targets() const {
  return _internal_has_motor_targets()
      ? *command_.motor_targets_
      : reinterpret_cast< ::MotorTargets&>(::_MotorTargets_default_instance_);
}
inline const ::MotorTargets& RotateLiftCommand::motor_targets() const {
  // @@protoc_insertion_point(field_get:RotateLiftCommand.motor_targets)
  return _internal_motor_targets();
}
inline ::MotorTargets* RotateLiftCommand::unsafe_arena_release_motor_targets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RotateLiftCommand.motor_targets)
  if (_internal_has_motor_targets()) {
    clear_has_command();
    ::MotorTargets* temp = command_.motor_targets_;
    command_.motor_targets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotateLiftCommand::unsafe_arena_set_allocated_motor_targets(::MotorTargets* motor_targets) {
  clear_command();
  if (motor_targets) {
    set_has_motor_targets();
    command_.motor_targets_ = motor_targets;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RotateLiftCommand.motor_targets)
}
inline ::MotorTargets* RotateLiftCommand::_internal_mutable_motor_targets() {
  if (!_internal_has_motor_targets()) {
    clear_command();
    set_has_motor_targets();
    command_.motor_targets_ = CreateMaybeMessage< ::MotorTargets >(GetArenaForAllocation());
  }
  return command_.motor_targets_;
}
inline ::MotorTargets* RotateLiftCommand::mutable_motor_targets() {
  ::MotorTargets* _msg = _internal_mutable_motor_targets();
  // @@protoc_insertion_point(field_mutable:RotateLiftCommand.motor_targets)
  return _msg;
}

// .RotateLiftRuntimeConfig runtime_config = 3;
inline bool RotateLiftCommand::_internal_has_runtime_config() const {
  return command_case() == kRuntimeConfig;
}
inline bool RotateLiftCommand::has_runtime_config() const {
  return _internal_has_runtime_config();
}
inline void RotateLiftCommand::set_has_runtime_config() {
  _oneof_case_[0] = kRuntimeConfig;
}
inline void RotateLiftCommand::clear_runtime_config() {
  if (_internal_has_runtime_config()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.runtime_config_;
    }
    clear_has_command();
  }
}
inline ::RotateLiftRuntimeConfig* RotateLiftCommand::release_runtime_config() {
  // @@protoc_insertion_point(field_release:RotateLiftCommand.runtime_config)
  if (_internal_has_runtime_config()) {
    clear_has_command();
      ::RotateLiftRuntimeConfig* temp = command_.runtime_config_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.runtime_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RotateLiftRuntimeConfig& RotateLiftCommand::_internal_runtime_config() const {
  return _internal_has_runtime_config()
      ? *command_.runtime_config_
      : reinterpret_cast< ::RotateLiftRuntimeConfig&>(::_RotateLiftRuntimeConfig_default_instance_);
}
inline const ::RotateLiftRuntimeConfig& RotateLiftCommand::runtime_config() const {
  // @@protoc_insertion_point(field_get:RotateLiftCommand.runtime_config)
  return _internal_runtime_config();
}
inline ::RotateLiftRuntimeConfig* RotateLiftCommand::unsafe_arena_release_runtime_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RotateLiftCommand.runtime_config)
  if (_internal_has_runtime_config()) {
    clear_has_command();
    ::RotateLiftRuntimeConfig* temp = command_.runtime_config_;
    command_.runtime_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotateLiftCommand::unsafe_arena_set_allocated_runtime_config(::RotateLiftRuntimeConfig* runtime_config) {
  clear_command();
  if (runtime_config) {
    set_has_runtime_config();
    command_.runtime_config_ = runtime_config;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RotateLiftCommand.runtime_config)
}
inline ::RotateLiftRuntimeConfig* RotateLiftCommand::_internal_mutable_runtime_config() {
  if (!_internal_has_runtime_config()) {
    clear_command();
    set_has_runtime_config();
    command_.runtime_config_ = CreateMaybeMessage< ::RotateLiftRuntimeConfig >(GetArenaForAllocation());
  }
  return command_.runtime_config_;
}
inline ::RotateLiftRuntimeConfig* RotateLiftCommand::mutable_runtime_config() {
  ::RotateLiftRuntimeConfig* _msg = _internal_mutable_runtime_config();
  // @@protoc_insertion_point(field_mutable:RotateLiftCommand.runtime_config)
  return _msg;
}

inline bool RotateLiftCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void RotateLiftCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline RotateLiftCommand::CommandCase RotateLiftCommand::command_case() const {
  return RotateLiftCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinearLiftStatus

// bool calibrated = 1;
inline void LinearLiftStatus::clear_calibrated() {
  calibrated_ = false;
}
inline bool LinearLiftStatus::_internal_calibrated() const {
  return calibrated_;
}
inline bool LinearLiftStatus::calibrated() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.calibrated)
  return _internal_calibrated();
}
inline void LinearLiftStatus::_internal_set_calibrated(bool value) {
  
  calibrated_ = value;
}
inline void LinearLiftStatus::set_calibrated(bool value) {
  _internal_set_calibrated(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.calibrated)
}

// .LiftState state = 2;
inline void LinearLiftStatus::clear_state() {
  state_ = 0;
}
inline ::LiftState LinearLiftStatus::_internal_state() const {
  return static_cast< ::LiftState >(state_);
}
inline ::LiftState LinearLiftStatus::state() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.state)
  return _internal_state();
}
inline void LinearLiftStatus::_internal_set_state(::LiftState value) {
  
  state_ = value;
}
inline void LinearLiftStatus::set_state(::LiftState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.state)
}

// int64 max_pos = 3;
inline void LinearLiftStatus::clear_max_pos() {
  max_pos_ = int64_t{0};
}
inline int64_t LinearLiftStatus::_internal_max_pos() const {
  return max_pos_;
}
inline int64_t LinearLiftStatus::max_pos() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.max_pos)
  return _internal_max_pos();
}
inline void LinearLiftStatus::_internal_set_max_pos(int64_t value) {
  
  max_pos_ = value;
}
inline void LinearLiftStatus::set_max_pos(int64_t value) {
  _internal_set_max_pos(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.max_pos)
}

// int64 current_pos = 4;
inline void LinearLiftStatus::clear_current_pos() {
  current_pos_ = int64_t{0};
}
inline int64_t LinearLiftStatus::_internal_current_pos() const {
  return current_pos_;
}
inline int64_t LinearLiftStatus::current_pos() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.current_pos)
  return _internal_current_pos();
}
inline void LinearLiftStatus::_internal_set_current_pos(int64_t value) {
  
  current_pos_ = value;
}
inline void LinearLiftStatus::set_current_pos(int64_t value) {
  _internal_set_current_pos(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.current_pos)
}

// uint32 pulse_per_rotation = 5;
inline void LinearLiftStatus::clear_pulse_per_rotation() {
  pulse_per_rotation_ = 0u;
}
inline uint32_t LinearLiftStatus::_internal_pulse_per_rotation() const {
  return pulse_per_rotation_;
}
inline uint32_t LinearLiftStatus::pulse_per_rotation() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.pulse_per_rotation)
  return _internal_pulse_per_rotation();
}
inline void LinearLiftStatus::_internal_set_pulse_per_rotation(uint32_t value) {
  
  pulse_per_rotation_ = value;
}
inline void LinearLiftStatus::set_pulse_per_rotation(uint32_t value) {
  _internal_set_pulse_per_rotation(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.pulse_per_rotation)
}

// uint32 max_speed = 6;
inline void LinearLiftStatus::clear_max_speed() {
  max_speed_ = 0u;
}
inline uint32_t LinearLiftStatus::_internal_max_speed() const {
  return max_speed_;
}
inline uint32_t LinearLiftStatus::max_speed() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.max_speed)
  return _internal_max_speed();
}
inline void LinearLiftStatus::_internal_set_max_speed(uint32_t value) {
  
  max_speed_ = value;
}
inline void LinearLiftStatus::set_max_speed(uint32_t value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.max_speed)
}

// uint32 speed = 7;
inline void LinearLiftStatus::clear_speed() {
  speed_ = 0u;
}
inline uint32_t LinearLiftStatus::_internal_speed() const {
  return speed_;
}
inline uint32_t LinearLiftStatus::speed() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.speed)
  return _internal_speed();
}
inline void LinearLiftStatus::_internal_set_speed(uint32_t value) {
  
  speed_ = value;
}
inline void LinearLiftStatus::set_speed(uint32_t value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.speed)
}

// optional .ParkingStopDetail parking_stop_detail = 10;
inline bool LinearLiftStatus::_internal_has_parking_stop_detail() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || parking_stop_detail_ != nullptr);
  return value;
}
inline bool LinearLiftStatus::has_parking_stop_detail() const {
  return _internal_has_parking_stop_detail();
}
inline void LinearLiftStatus::clear_parking_stop_detail() {
  if (parking_stop_detail_ != nullptr) parking_stop_detail_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ParkingStopDetail& LinearLiftStatus::_internal_parking_stop_detail() const {
  const ::ParkingStopDetail* p = parking_stop_detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::ParkingStopDetail&>(
      ::_ParkingStopDetail_default_instance_);
}
inline const ::ParkingStopDetail& LinearLiftStatus::parking_stop_detail() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.parking_stop_detail)
  return _internal_parking_stop_detail();
}
inline void LinearLiftStatus::unsafe_arena_set_allocated_parking_stop_detail(
    ::ParkingStopDetail* parking_stop_detail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parking_stop_detail_);
  }
  parking_stop_detail_ = parking_stop_detail;
  if (parking_stop_detail) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LinearLiftStatus.parking_stop_detail)
}
inline ::ParkingStopDetail* LinearLiftStatus::release_parking_stop_detail() {
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ParkingStopDetail* LinearLiftStatus::unsafe_arena_release_parking_stop_detail() {
  // @@protoc_insertion_point(field_release:LinearLiftStatus.parking_stop_detail)
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
  return temp;
}
inline ::ParkingStopDetail* LinearLiftStatus::_internal_mutable_parking_stop_detail() {
  _has_bits_[0] |= 0x00000001u;
  if (parking_stop_detail_ == nullptr) {
    auto* p = CreateMaybeMessage<::ParkingStopDetail>(GetArenaForAllocation());
    parking_stop_detail_ = p;
  }
  return parking_stop_detail_;
}
inline ::ParkingStopDetail* LinearLiftStatus::mutable_parking_stop_detail() {
  ::ParkingStopDetail* _msg = _internal_mutable_parking_stop_detail();
  // @@protoc_insertion_point(field_mutable:LinearLiftStatus.parking_stop_detail)
  return _msg;
}
inline void LinearLiftStatus::set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete parking_stop_detail_;
  }
  if (parking_stop_detail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ParkingStopDetail>::GetOwningArena(parking_stop_detail);
    if (message_arena != submessage_arena) {
      parking_stop_detail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_stop_detail, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parking_stop_detail_ = parking_stop_detail;
  // @@protoc_insertion_point(field_set_allocated:LinearLiftStatus.parking_stop_detail)
}

// optional bool custom_button_pressed = 11;
inline bool LinearLiftStatus::_internal_has_custom_button_pressed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LinearLiftStatus::has_custom_button_pressed() const {
  return _internal_has_custom_button_pressed();
}
inline void LinearLiftStatus::clear_custom_button_pressed() {
  custom_button_pressed_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool LinearLiftStatus::_internal_custom_button_pressed() const {
  return custom_button_pressed_;
}
inline bool LinearLiftStatus::custom_button_pressed() const {
  // @@protoc_insertion_point(field_get:LinearLiftStatus.custom_button_pressed)
  return _internal_custom_button_pressed();
}
inline void LinearLiftStatus::_internal_set_custom_button_pressed(bool value) {
  _has_bits_[0] |= 0x00000002u;
  custom_button_pressed_ = value;
}
inline void LinearLiftStatus::set_custom_button_pressed(bool value) {
  _internal_set_custom_button_pressed(value);
  // @@protoc_insertion_point(field_set:LinearLiftStatus.custom_button_pressed)
}

// -------------------------------------------------------------------

// LinearLiftCommand

// bool calibrate = 1;
inline bool LinearLiftCommand::_internal_has_calibrate() const {
  return command_case() == kCalibrate;
}
inline bool LinearLiftCommand::has_calibrate() const {
  return _internal_has_calibrate();
}
inline void LinearLiftCommand::set_has_calibrate() {
  _oneof_case_[0] = kCalibrate;
}
inline void LinearLiftCommand::clear_calibrate() {
  if (_internal_has_calibrate()) {
    command_.calibrate_ = false;
    clear_has_command();
  }
}
inline bool LinearLiftCommand::_internal_calibrate() const {
  if (_internal_has_calibrate()) {
    return command_.calibrate_;
  }
  return false;
}
inline void LinearLiftCommand::_internal_set_calibrate(bool value) {
  if (!_internal_has_calibrate()) {
    clear_command();
    set_has_calibrate();
  }
  command_.calibrate_ = value;
}
inline bool LinearLiftCommand::calibrate() const {
  // @@protoc_insertion_point(field_get:LinearLiftCommand.calibrate)
  return _internal_calibrate();
}
inline void LinearLiftCommand::set_calibrate(bool value) {
  _internal_set_calibrate(value);
  // @@protoc_insertion_point(field_set:LinearLiftCommand.calibrate)
}

// int64 target_pos = 2;
inline bool LinearLiftCommand::_internal_has_target_pos() const {
  return command_case() == kTargetPos;
}
inline bool LinearLiftCommand::has_target_pos() const {
  return _internal_has_target_pos();
}
inline void LinearLiftCommand::set_has_target_pos() {
  _oneof_case_[0] = kTargetPos;
}
inline void LinearLiftCommand::clear_target_pos() {
  if (_internal_has_target_pos()) {
    command_.target_pos_ = int64_t{0};
    clear_has_command();
  }
}
inline int64_t LinearLiftCommand::_internal_target_pos() const {
  if (_internal_has_target_pos()) {
    return command_.target_pos_;
  }
  return int64_t{0};
}
inline void LinearLiftCommand::_internal_set_target_pos(int64_t value) {
  if (!_internal_has_target_pos()) {
    clear_command();
    set_has_target_pos();
  }
  command_.target_pos_ = value;
}
inline int64_t LinearLiftCommand::target_pos() const {
  // @@protoc_insertion_point(field_get:LinearLiftCommand.target_pos)
  return _internal_target_pos();
}
inline void LinearLiftCommand::set_target_pos(int64_t value) {
  _internal_set_target_pos(value);
  // @@protoc_insertion_point(field_set:LinearLiftCommand.target_pos)
}

// bool brake = 3;
inline bool LinearLiftCommand::_internal_has_brake() const {
  return command_case() == kBrake;
}
inline bool LinearLiftCommand::has_brake() const {
  return _internal_has_brake();
}
inline void LinearLiftCommand::set_has_brake() {
  _oneof_case_[0] = kBrake;
}
inline void LinearLiftCommand::clear_brake() {
  if (_internal_has_brake()) {
    command_.brake_ = false;
    clear_has_command();
  }
}
inline bool LinearLiftCommand::_internal_brake() const {
  if (_internal_has_brake()) {
    return command_.brake_;
  }
  return false;
}
inline void LinearLiftCommand::_internal_set_brake(bool value) {
  if (!_internal_has_brake()) {
    clear_command();
    set_has_brake();
  }
  command_.brake_ = value;
}
inline bool LinearLiftCommand::brake() const {
  // @@protoc_insertion_point(field_get:LinearLiftCommand.brake)
  return _internal_brake();
}
inline void LinearLiftCommand::set_brake(bool value) {
  _internal_set_brake(value);
  // @@protoc_insertion_point(field_set:LinearLiftCommand.brake)
}

// uint32 set_speed = 4;
inline bool LinearLiftCommand::_internal_has_set_speed() const {
  return command_case() == kSetSpeed;
}
inline bool LinearLiftCommand::has_set_speed() const {
  return _internal_has_set_speed();
}
inline void LinearLiftCommand::set_has_set_speed() {
  _oneof_case_[0] = kSetSpeed;
}
inline void LinearLiftCommand::clear_set_speed() {
  if (_internal_has_set_speed()) {
    command_.set_speed_ = 0u;
    clear_has_command();
  }
}
inline uint32_t LinearLiftCommand::_internal_set_speed() const {
  if (_internal_has_set_speed()) {
    return command_.set_speed_;
  }
  return 0u;
}
inline void LinearLiftCommand::_internal_set_set_speed(uint32_t value) {
  if (!_internal_has_set_speed()) {
    clear_command();
    set_has_set_speed();
  }
  command_.set_speed_ = value;
}
inline uint32_t LinearLiftCommand::set_speed() const {
  // @@protoc_insertion_point(field_get:LinearLiftCommand.set_speed)
  return _internal_set_speed();
}
inline void LinearLiftCommand::set_set_speed(uint32_t value) {
  _internal_set_set_speed(value);
  // @@protoc_insertion_point(field_set:LinearLiftCommand.set_speed)
}

inline bool LinearLiftCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void LinearLiftCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline LinearLiftCommand::CommandCase LinearLiftCommand::command_case() const {
  return LinearLiftCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArmStatus

// bool api_control_initialized = 1;
inline void ArmStatus::clear_api_control_initialized() {
  api_control_initialized_ = false;
}
inline bool ArmStatus::_internal_api_control_initialized() const {
  return api_control_initialized_;
}
inline bool ArmStatus::api_control_initialized() const {
  // @@protoc_insertion_point(field_get:ArmStatus.api_control_initialized)
  return _internal_api_control_initialized();
}
inline void ArmStatus::_internal_set_api_control_initialized(bool value) {
  
  api_control_initialized_ = value;
}
inline void ArmStatus::set_api_control_initialized(bool value) {
  _internal_set_api_control_initialized(value);
  // @@protoc_insertion_point(field_set:ArmStatus.api_control_initialized)
}

// bool calibrated = 3;
inline void ArmStatus::clear_calibrated() {
  calibrated_ = false;
}
inline bool ArmStatus::_internal_calibrated() const {
  return calibrated_;
}
inline bool ArmStatus::calibrated() const {
  // @@protoc_insertion_point(field_get:ArmStatus.calibrated)
  return _internal_calibrated();
}
inline void ArmStatus::_internal_set_calibrated(bool value) {
  
  calibrated_ = value;
}
inline void ArmStatus::set_calibrated(bool value) {
  _internal_set_calibrated(value);
  // @@protoc_insertion_point(field_set:ArmStatus.calibrated)
}

// repeated .MotorStatus motor_status = 4;
inline int ArmStatus::_internal_motor_status_size() const {
  return motor_status_.size();
}
inline int ArmStatus::motor_status_size() const {
  return _internal_motor_status_size();
}
inline void ArmStatus::clear_motor_status() {
  motor_status_.Clear();
}
inline ::MotorStatus* ArmStatus::mutable_motor_status(int index) {
  // @@protoc_insertion_point(field_mutable:ArmStatus.motor_status)
  return motor_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
ArmStatus::mutable_motor_status() {
  // @@protoc_insertion_point(field_mutable_list:ArmStatus.motor_status)
  return &motor_status_;
}
inline const ::MotorStatus& ArmStatus::_internal_motor_status(int index) const {
  return motor_status_.Get(index);
}
inline const ::MotorStatus& ArmStatus::motor_status(int index) const {
  // @@protoc_insertion_point(field_get:ArmStatus.motor_status)
  return _internal_motor_status(index);
}
inline ::MotorStatus* ArmStatus::_internal_add_motor_status() {
  return motor_status_.Add();
}
inline ::MotorStatus* ArmStatus::add_motor_status() {
  ::MotorStatus* _add = _internal_add_motor_status();
  // @@protoc_insertion_point(field_add:ArmStatus.motor_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
ArmStatus::motor_status() const {
  // @@protoc_insertion_point(field_list:ArmStatus.motor_status)
  return motor_status_;
}

// uint32 session_holder = 6;
inline void ArmStatus::clear_session_holder() {
  session_holder_ = 0u;
}
inline uint32_t ArmStatus::_internal_session_holder() const {
  return session_holder_;
}
inline uint32_t ArmStatus::session_holder() const {
  // @@protoc_insertion_point(field_get:ArmStatus.session_holder)
  return _internal_session_holder();
}
inline void ArmStatus::_internal_set_session_holder(uint32_t value) {
  
  session_holder_ = value;
}
inline void ArmStatus::set_session_holder(uint32_t value) {
  _internal_set_session_holder(value);
  // @@protoc_insertion_point(field_set:ArmStatus.session_holder)
}

// optional .ParkingStopDetail parking_stop_detail = 5;
inline bool ArmStatus::_internal_has_parking_stop_detail() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || parking_stop_detail_ != nullptr);
  return value;
}
inline bool ArmStatus::has_parking_stop_detail() const {
  return _internal_has_parking_stop_detail();
}
inline void ArmStatus::clear_parking_stop_detail() {
  if (parking_stop_detail_ != nullptr) parking_stop_detail_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ParkingStopDetail& ArmStatus::_internal_parking_stop_detail() const {
  const ::ParkingStopDetail* p = parking_stop_detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::ParkingStopDetail&>(
      ::_ParkingStopDetail_default_instance_);
}
inline const ::ParkingStopDetail& ArmStatus::parking_stop_detail() const {
  // @@protoc_insertion_point(field_get:ArmStatus.parking_stop_detail)
  return _internal_parking_stop_detail();
}
inline void ArmStatus::unsafe_arena_set_allocated_parking_stop_detail(
    ::ParkingStopDetail* parking_stop_detail) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parking_stop_detail_);
  }
  parking_stop_detail_ = parking_stop_detail;
  if (parking_stop_detail) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmStatus.parking_stop_detail)
}
inline ::ParkingStopDetail* ArmStatus::release_parking_stop_detail() {
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ParkingStopDetail* ArmStatus::unsafe_arena_release_parking_stop_detail() {
  // @@protoc_insertion_point(field_release:ArmStatus.parking_stop_detail)
  _has_bits_[0] &= ~0x00000001u;
  ::ParkingStopDetail* temp = parking_stop_detail_;
  parking_stop_detail_ = nullptr;
  return temp;
}
inline ::ParkingStopDetail* ArmStatus::_internal_mutable_parking_stop_detail() {
  _has_bits_[0] |= 0x00000001u;
  if (parking_stop_detail_ == nullptr) {
    auto* p = CreateMaybeMessage<::ParkingStopDetail>(GetArenaForAllocation());
    parking_stop_detail_ = p;
  }
  return parking_stop_detail_;
}
inline ::ParkingStopDetail* ArmStatus::mutable_parking_stop_detail() {
  ::ParkingStopDetail* _msg = _internal_mutable_parking_stop_detail();
  // @@protoc_insertion_point(field_mutable:ArmStatus.parking_stop_detail)
  return _msg;
}
inline void ArmStatus::set_allocated_parking_stop_detail(::ParkingStopDetail* parking_stop_detail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete parking_stop_detail_;
  }
  if (parking_stop_detail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ParkingStopDetail>::GetOwningArena(parking_stop_detail);
    if (message_arena != submessage_arena) {
      parking_stop_detail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_stop_detail, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parking_stop_detail_ = parking_stop_detail;
  // @@protoc_insertion_point(field_set_allocated:ArmStatus.parking_stop_detail)
}

// -------------------------------------------------------------------

// HandStatus

// repeated .MotorStatus motor_status = 2;
inline int HandStatus::_internal_motor_status_size() const {
  return motor_status_.size();
}
inline int HandStatus::motor_status_size() const {
  return _internal_motor_status_size();
}
inline void HandStatus::clear_motor_status() {
  motor_status_.Clear();
}
inline ::MotorStatus* HandStatus::mutable_motor_status(int index) {
  // @@protoc_insertion_point(field_mutable:HandStatus.motor_status)
  return motor_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >*
HandStatus::mutable_motor_status() {
  // @@protoc_insertion_point(field_mutable_list:HandStatus.motor_status)
  return &motor_status_;
}
inline const ::MotorStatus& HandStatus::_internal_motor_status(int index) const {
  return motor_status_.Get(index);
}
inline const ::MotorStatus& HandStatus::motor_status(int index) const {
  // @@protoc_insertion_point(field_get:HandStatus.motor_status)
  return _internal_motor_status(index);
}
inline ::MotorStatus* HandStatus::_internal_add_motor_status() {
  return motor_status_.Add();
}
inline ::MotorStatus* HandStatus::add_motor_status() {
  ::MotorStatus* _add = _internal_add_motor_status();
  // @@protoc_insertion_point(field_add:HandStatus.motor_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorStatus >&
HandStatus::motor_status() const {
  // @@protoc_insertion_point(field_list:HandStatus.motor_status)
  return motor_status_;
}

// -------------------------------------------------------------------

// HandCommand

// .MotorTargets motor_targets = 1;
inline bool HandCommand::_internal_has_motor_targets() const {
  return this != internal_default_instance() && motor_targets_ != nullptr;
}
inline bool HandCommand::has_motor_targets() const {
  return _internal_has_motor_targets();
}
inline void HandCommand::clear_motor_targets() {
  if (GetArenaForAllocation() == nullptr && motor_targets_ != nullptr) {
    delete motor_targets_;
  }
  motor_targets_ = nullptr;
}
inline const ::MotorTargets& HandCommand::_internal_motor_targets() const {
  const ::MotorTargets* p = motor_targets_;
  return p != nullptr ? *p : reinterpret_cast<const ::MotorTargets&>(
      ::_MotorTargets_default_instance_);
}
inline const ::MotorTargets& HandCommand::motor_targets() const {
  // @@protoc_insertion_point(field_get:HandCommand.motor_targets)
  return _internal_motor_targets();
}
inline void HandCommand::unsafe_arena_set_allocated_motor_targets(
    ::MotorTargets* motor_targets) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motor_targets_);
  }
  motor_targets_ = motor_targets;
  if (motor_targets) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HandCommand.motor_targets)
}
inline ::MotorTargets* HandCommand::release_motor_targets() {
  
  ::MotorTargets* temp = motor_targets_;
  motor_targets_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MotorTargets* HandCommand::unsafe_arena_release_motor_targets() {
  // @@protoc_insertion_point(field_release:HandCommand.motor_targets)
  
  ::MotorTargets* temp = motor_targets_;
  motor_targets_ = nullptr;
  return temp;
}
inline ::MotorTargets* HandCommand::_internal_mutable_motor_targets() {
  
  if (motor_targets_ == nullptr) {
    auto* p = CreateMaybeMessage<::MotorTargets>(GetArenaForAllocation());
    motor_targets_ = p;
  }
  return motor_targets_;
}
inline ::MotorTargets* HandCommand::mutable_motor_targets() {
  ::MotorTargets* _msg = _internal_mutable_motor_targets();
  // @@protoc_insertion_point(field_mutable:HandCommand.motor_targets)
  return _msg;
}
inline void HandCommand::set_allocated_motor_targets(::MotorTargets* motor_targets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete motor_targets_;
  }
  if (motor_targets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MotorTargets>::GetOwningArena(motor_targets);
    if (message_arena != submessage_arena) {
      motor_targets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motor_targets, submessage_arena);
    }
    
  } else {
    
  }
  motor_targets_ = motor_targets;
  // @@protoc_insertion_point(field_set_allocated:HandCommand.motor_targets)
}

// -------------------------------------------------------------------

// ArmApiFreeDragCommand

// -------------------------------------------------------------------

// ArmApiZeroCurrentCommand

// -------------------------------------------------------------------

// ArmApiControlCommand

// .MotorTargets motor_targets = 1;
inline bool ArmApiControlCommand::_internal_has_motor_targets() const {
  return command_case() == kMotorTargets;
}
inline bool ArmApiControlCommand::has_motor_targets() const {
  return _internal_has_motor_targets();
}
inline void ArmApiControlCommand::set_has_motor_targets() {
  _oneof_case_[0] = kMotorTargets;
}
inline void ArmApiControlCommand::clear_motor_targets() {
  if (_internal_has_motor_targets()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.motor_targets_;
    }
    clear_has_command();
  }
}
inline ::MotorTargets* ArmApiControlCommand::release_motor_targets() {
  // @@protoc_insertion_point(field_release:ArmApiControlCommand.motor_targets)
  if (_internal_has_motor_targets()) {
    clear_has_command();
      ::MotorTargets* temp = command_.motor_targets_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.motor_targets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MotorTargets& ArmApiControlCommand::_internal_motor_targets() const {
  return _internal_has_motor_targets()
      ? *command_.motor_targets_
      : reinterpret_cast< ::MotorTargets&>(::_MotorTargets_default_instance_);
}
inline const ::MotorTargets& ArmApiControlCommand::motor_targets() const {
  // @@protoc_insertion_point(field_get:ArmApiControlCommand.motor_targets)
  return _internal_motor_targets();
}
inline ::MotorTargets* ArmApiControlCommand::unsafe_arena_release_motor_targets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmApiControlCommand.motor_targets)
  if (_internal_has_motor_targets()) {
    clear_has_command();
    ::MotorTargets* temp = command_.motor_targets_;
    command_.motor_targets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArmApiControlCommand::unsafe_arena_set_allocated_motor_targets(::MotorTargets* motor_targets) {
  clear_command();
  if (motor_targets) {
    set_has_motor_targets();
    command_.motor_targets_ = motor_targets;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmApiControlCommand.motor_targets)
}
inline ::MotorTargets* ArmApiControlCommand::_internal_mutable_motor_targets() {
  if (!_internal_has_motor_targets()) {
    clear_command();
    set_has_motor_targets();
    command_.motor_targets_ = CreateMaybeMessage< ::MotorTargets >(GetArenaForAllocation());
  }
  return command_.motor_targets_;
}
inline ::MotorTargets* ArmApiControlCommand::mutable_motor_targets() {
  ::MotorTargets* _msg = _internal_mutable_motor_targets();
  // @@protoc_insertion_point(field_mutable:ArmApiControlCommand.motor_targets)
  return _msg;
}

// .ArmApiFreeDragCommand arm_api_free_drag_command = 2;
inline bool ArmApiControlCommand::_internal_has_arm_api_free_drag_command() const {
  return command_case() == kArmApiFreeDragCommand;
}
inline bool ArmApiControlCommand::has_arm_api_free_drag_command() const {
  return _internal_has_arm_api_free_drag_command();
}
inline void ArmApiControlCommand::set_has_arm_api_free_drag_command() {
  _oneof_case_[0] = kArmApiFreeDragCommand;
}
inline void ArmApiControlCommand::clear_arm_api_free_drag_command() {
  if (_internal_has_arm_api_free_drag_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.arm_api_free_drag_command_;
    }
    clear_has_command();
  }
}
inline ::ArmApiFreeDragCommand* ArmApiControlCommand::release_arm_api_free_drag_command() {
  // @@protoc_insertion_point(field_release:ArmApiControlCommand.arm_api_free_drag_command)
  if (_internal_has_arm_api_free_drag_command()) {
    clear_has_command();
      ::ArmApiFreeDragCommand* temp = command_.arm_api_free_drag_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.arm_api_free_drag_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmApiFreeDragCommand& ArmApiControlCommand::_internal_arm_api_free_drag_command() const {
  return _internal_has_arm_api_free_drag_command()
      ? *command_.arm_api_free_drag_command_
      : reinterpret_cast< ::ArmApiFreeDragCommand&>(::_ArmApiFreeDragCommand_default_instance_);
}
inline const ::ArmApiFreeDragCommand& ArmApiControlCommand::arm_api_free_drag_command() const {
  // @@protoc_insertion_point(field_get:ArmApiControlCommand.arm_api_free_drag_command)
  return _internal_arm_api_free_drag_command();
}
inline ::ArmApiFreeDragCommand* ArmApiControlCommand::unsafe_arena_release_arm_api_free_drag_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmApiControlCommand.arm_api_free_drag_command)
  if (_internal_has_arm_api_free_drag_command()) {
    clear_has_command();
    ::ArmApiFreeDragCommand* temp = command_.arm_api_free_drag_command_;
    command_.arm_api_free_drag_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArmApiControlCommand::unsafe_arena_set_allocated_arm_api_free_drag_command(::ArmApiFreeDragCommand* arm_api_free_drag_command) {
  clear_command();
  if (arm_api_free_drag_command) {
    set_has_arm_api_free_drag_command();
    command_.arm_api_free_drag_command_ = arm_api_free_drag_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmApiControlCommand.arm_api_free_drag_command)
}
inline ::ArmApiFreeDragCommand* ArmApiControlCommand::_internal_mutable_arm_api_free_drag_command() {
  if (!_internal_has_arm_api_free_drag_command()) {
    clear_command();
    set_has_arm_api_free_drag_command();
    command_.arm_api_free_drag_command_ = CreateMaybeMessage< ::ArmApiFreeDragCommand >(GetArenaForAllocation());
  }
  return command_.arm_api_free_drag_command_;
}
inline ::ArmApiFreeDragCommand* ArmApiControlCommand::mutable_arm_api_free_drag_command() {
  ::ArmApiFreeDragCommand* _msg = _internal_mutable_arm_api_free_drag_command();
  // @@protoc_insertion_point(field_mutable:ArmApiControlCommand.arm_api_free_drag_command)
  return _msg;
}

// .ArmApiZeroCurrentCommand arm_api_zero_current_command = 3;
inline bool ArmApiControlCommand::_internal_has_arm_api_zero_current_command() const {
  return command_case() == kArmApiZeroCurrentCommand;
}
inline bool ArmApiControlCommand::has_arm_api_zero_current_command() const {
  return _internal_has_arm_api_zero_current_command();
}
inline void ArmApiControlCommand::set_has_arm_api_zero_current_command() {
  _oneof_case_[0] = kArmApiZeroCurrentCommand;
}
inline void ArmApiControlCommand::clear_arm_api_zero_current_command() {
  if (_internal_has_arm_api_zero_current_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.arm_api_zero_current_command_;
    }
    clear_has_command();
  }
}
inline ::ArmApiZeroCurrentCommand* ArmApiControlCommand::release_arm_api_zero_current_command() {
  // @@protoc_insertion_point(field_release:ArmApiControlCommand.arm_api_zero_current_command)
  if (_internal_has_arm_api_zero_current_command()) {
    clear_has_command();
      ::ArmApiZeroCurrentCommand* temp = command_.arm_api_zero_current_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.arm_api_zero_current_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmApiZeroCurrentCommand& ArmApiControlCommand::_internal_arm_api_zero_current_command() const {
  return _internal_has_arm_api_zero_current_command()
      ? *command_.arm_api_zero_current_command_
      : reinterpret_cast< ::ArmApiZeroCurrentCommand&>(::_ArmApiZeroCurrentCommand_default_instance_);
}
inline const ::ArmApiZeroCurrentCommand& ArmApiControlCommand::arm_api_zero_current_command() const {
  // @@protoc_insertion_point(field_get:ArmApiControlCommand.arm_api_zero_current_command)
  return _internal_arm_api_zero_current_command();
}
inline ::ArmApiZeroCurrentCommand* ArmApiControlCommand::unsafe_arena_release_arm_api_zero_current_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmApiControlCommand.arm_api_zero_current_command)
  if (_internal_has_arm_api_zero_current_command()) {
    clear_has_command();
    ::ArmApiZeroCurrentCommand* temp = command_.arm_api_zero_current_command_;
    command_.arm_api_zero_current_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArmApiControlCommand::unsafe_arena_set_allocated_arm_api_zero_current_command(::ArmApiZeroCurrentCommand* arm_api_zero_current_command) {
  clear_command();
  if (arm_api_zero_current_command) {
    set_has_arm_api_zero_current_command();
    command_.arm_api_zero_current_command_ = arm_api_zero_current_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmApiControlCommand.arm_api_zero_current_command)
}
inline ::ArmApiZeroCurrentCommand* ArmApiControlCommand::_internal_mutable_arm_api_zero_current_command() {
  if (!_internal_has_arm_api_zero_current_command()) {
    clear_command();
    set_has_arm_api_zero_current_command();
    command_.arm_api_zero_current_command_ = CreateMaybeMessage< ::ArmApiZeroCurrentCommand >(GetArenaForAllocation());
  }
  return command_.arm_api_zero_current_command_;
}
inline ::ArmApiZeroCurrentCommand* ArmApiControlCommand::mutable_arm_api_zero_current_command() {
  ::ArmApiZeroCurrentCommand* _msg = _internal_mutable_arm_api_zero_current_command();
  // @@protoc_insertion_point(field_mutable:ArmApiControlCommand.arm_api_zero_current_command)
  return _msg;
}

inline bool ArmApiControlCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void ArmApiControlCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline ArmApiControlCommand::CommandCase ArmApiControlCommand::command_case() const {
  return ArmApiControlCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArmSharedCommand

// bool clear_parking_stop = 1;
inline bool ArmSharedCommand::_internal_has_clear_parking_stop() const {
  return command_case() == kClearParkingStop;
}
inline bool ArmSharedCommand::has_clear_parking_stop() const {
  return _internal_has_clear_parking_stop();
}
inline void ArmSharedCommand::set_has_clear_parking_stop() {
  _oneof_case_[0] = kClearParkingStop;
}
inline void ArmSharedCommand::clear_clear_parking_stop() {
  if (_internal_has_clear_parking_stop()) {
    command_.clear_parking_stop_ = false;
    clear_has_command();
  }
}
inline bool ArmSharedCommand::_internal_clear_parking_stop() const {
  if (_internal_has_clear_parking_stop()) {
    return command_.clear_parking_stop_;
  }
  return false;
}
inline void ArmSharedCommand::_internal_set_clear_parking_stop(bool value) {
  if (!_internal_has_clear_parking_stop()) {
    clear_command();
    set_has_clear_parking_stop();
  }
  command_.clear_parking_stop_ = value;
}
inline bool ArmSharedCommand::clear_parking_stop() const {
  // @@protoc_insertion_point(field_get:ArmSharedCommand.clear_parking_stop)
  return _internal_clear_parking_stop();
}
inline void ArmSharedCommand::set_clear_parking_stop(bool value) {
  _internal_set_clear_parking_stop(value);
  // @@protoc_insertion_point(field_set:ArmSharedCommand.clear_parking_stop)
}

// .ParkingStopDetail enter_parking_stop = 2;
inline bool ArmSharedCommand::_internal_has_enter_parking_stop() const {
  return command_case() == kEnterParkingStop;
}
inline bool ArmSharedCommand::has_enter_parking_stop() const {
  return _internal_has_enter_parking_stop();
}
inline void ArmSharedCommand::set_has_enter_parking_stop() {
  _oneof_case_[0] = kEnterParkingStop;
}
inline void ArmSharedCommand::clear_enter_parking_stop() {
  if (_internal_has_enter_parking_stop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.enter_parking_stop_;
    }
    clear_has_command();
  }
}
inline ::ParkingStopDetail* ArmSharedCommand::release_enter_parking_stop() {
  // @@protoc_insertion_point(field_release:ArmSharedCommand.enter_parking_stop)
  if (_internal_has_enter_parking_stop()) {
    clear_has_command();
      ::ParkingStopDetail* temp = command_.enter_parking_stop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.enter_parking_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ParkingStopDetail& ArmSharedCommand::_internal_enter_parking_stop() const {
  return _internal_has_enter_parking_stop()
      ? *command_.enter_parking_stop_
      : reinterpret_cast< ::ParkingStopDetail&>(::_ParkingStopDetail_default_instance_);
}
inline const ::ParkingStopDetail& ArmSharedCommand::enter_parking_stop() const {
  // @@protoc_insertion_point(field_get:ArmSharedCommand.enter_parking_stop)
  return _internal_enter_parking_stop();
}
inline ::ParkingStopDetail* ArmSharedCommand::unsafe_arena_release_enter_parking_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmSharedCommand.enter_parking_stop)
  if (_internal_has_enter_parking_stop()) {
    clear_has_command();
    ::ParkingStopDetail* temp = command_.enter_parking_stop_;
    command_.enter_parking_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArmSharedCommand::unsafe_arena_set_allocated_enter_parking_stop(::ParkingStopDetail* enter_parking_stop) {
  clear_command();
  if (enter_parking_stop) {
    set_has_enter_parking_stop();
    command_.enter_parking_stop_ = enter_parking_stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmSharedCommand.enter_parking_stop)
}
inline ::ParkingStopDetail* ArmSharedCommand::_internal_mutable_enter_parking_stop() {
  if (!_internal_has_enter_parking_stop()) {
    clear_command();
    set_has_enter_parking_stop();
    command_.enter_parking_stop_ = CreateMaybeMessage< ::ParkingStopDetail >(GetArenaForAllocation());
  }
  return command_.enter_parking_stop_;
}
inline ::ParkingStopDetail* ArmSharedCommand::mutable_enter_parking_stop() {
  ::ParkingStopDetail* _msg = _internal_mutable_enter_parking_stop();
  // @@protoc_insertion_point(field_mutable:ArmSharedCommand.enter_parking_stop)
  return _msg;
}

inline bool ArmSharedCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void ArmSharedCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline ArmSharedCommand::CommandCase ArmSharedCommand::command_case() const {
  return ArmSharedCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArmExclusiveCommand

// bool api_control_initialize = 1;
inline bool ArmExclusiveCommand::_internal_has_api_control_initialize() const {
  return exclusive_command_case() == kApiControlInitialize;
}
inline bool ArmExclusiveCommand::has_api_control_initialize() const {
  return _internal_has_api_control_initialize();
}
inline void ArmExclusiveCommand::set_has_api_control_initialize() {
  _oneof_case_[0] = kApiControlInitialize;
}
inline void ArmExclusiveCommand::clear_api_control_initialize() {
  if (_internal_has_api_control_initialize()) {
    exclusive_command_.api_control_initialize_ = false;
    clear_has_exclusive_command();
  }
}
inline bool ArmExclusiveCommand::_internal_api_control_initialize() const {
  if (_internal_has_api_control_initialize()) {
    return exclusive_command_.api_control_initialize_;
  }
  return false;
}
inline void ArmExclusiveCommand::_internal_set_api_control_initialize(bool value) {
  if (!_internal_has_api_control_initialize()) {
    clear_exclusive_command();
    set_has_api_control_initialize();
  }
  exclusive_command_.api_control_initialize_ = value;
}
inline bool ArmExclusiveCommand::api_control_initialize() const {
  // @@protoc_insertion_point(field_get:ArmExclusiveCommand.api_control_initialize)
  return _internal_api_control_initialize();
}
inline void ArmExclusiveCommand::set_api_control_initialize(bool value) {
  _internal_set_api_control_initialize(value);
  // @@protoc_insertion_point(field_set:ArmExclusiveCommand.api_control_initialize)
}

// .ArmApiControlCommand arm_api_control_command = 6;
inline bool ArmExclusiveCommand::_internal_has_arm_api_control_command() const {
  return exclusive_command_case() == kArmApiControlCommand;
}
inline bool ArmExclusiveCommand::has_arm_api_control_command() const {
  return _internal_has_arm_api_control_command();
}
inline void ArmExclusiveCommand::set_has_arm_api_control_command() {
  _oneof_case_[0] = kArmApiControlCommand;
}
inline void ArmExclusiveCommand::clear_arm_api_control_command() {
  if (_internal_has_arm_api_control_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete exclusive_command_.arm_api_control_command_;
    }
    clear_has_exclusive_command();
  }
}
inline ::ArmApiControlCommand* ArmExclusiveCommand::release_arm_api_control_command() {
  // @@protoc_insertion_point(field_release:ArmExclusiveCommand.arm_api_control_command)
  if (_internal_has_arm_api_control_command()) {
    clear_has_exclusive_command();
      ::ArmApiControlCommand* temp = exclusive_command_.arm_api_control_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    exclusive_command_.arm_api_control_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmApiControlCommand& ArmExclusiveCommand::_internal_arm_api_control_command() const {
  return _internal_has_arm_api_control_command()
      ? *exclusive_command_.arm_api_control_command_
      : reinterpret_cast< ::ArmApiControlCommand&>(::_ArmApiControlCommand_default_instance_);
}
inline const ::ArmApiControlCommand& ArmExclusiveCommand::arm_api_control_command() const {
  // @@protoc_insertion_point(field_get:ArmExclusiveCommand.arm_api_control_command)
  return _internal_arm_api_control_command();
}
inline ::ArmApiControlCommand* ArmExclusiveCommand::unsafe_arena_release_arm_api_control_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmExclusiveCommand.arm_api_control_command)
  if (_internal_has_arm_api_control_command()) {
    clear_has_exclusive_command();
    ::ArmApiControlCommand* temp = exclusive_command_.arm_api_control_command_;
    exclusive_command_.arm_api_control_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArmExclusiveCommand::unsafe_arena_set_allocated_arm_api_control_command(::ArmApiControlCommand* arm_api_control_command) {
  clear_exclusive_command();
  if (arm_api_control_command) {
    set_has_arm_api_control_command();
    exclusive_command_.arm_api_control_command_ = arm_api_control_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmExclusiveCommand.arm_api_control_command)
}
inline ::ArmApiControlCommand* ArmExclusiveCommand::_internal_mutable_arm_api_control_command() {
  if (!_internal_has_arm_api_control_command()) {
    clear_exclusive_command();
    set_has_arm_api_control_command();
    exclusive_command_.arm_api_control_command_ = CreateMaybeMessage< ::ArmApiControlCommand >(GetArenaForAllocation());
  }
  return exclusive_command_.arm_api_control_command_;
}
inline ::ArmApiControlCommand* ArmExclusiveCommand::mutable_arm_api_control_command() {
  ::ArmApiControlCommand* _msg = _internal_mutable_arm_api_control_command();
  // @@protoc_insertion_point(field_mutable:ArmExclusiveCommand.arm_api_control_command)
  return _msg;
}

// bool calibrate = 4;
inline bool ArmExclusiveCommand::_internal_has_calibrate() const {
  return exclusive_command_case() == kCalibrate;
}
inline bool ArmExclusiveCommand::has_calibrate() const {
  return _internal_has_calibrate();
}
inline void ArmExclusiveCommand::set_has_calibrate() {
  _oneof_case_[0] = kCalibrate;
}
inline void ArmExclusiveCommand::clear_calibrate() {
  if (_internal_has_calibrate()) {
    exclusive_command_.calibrate_ = false;
    clear_has_exclusive_command();
  }
}
inline bool ArmExclusiveCommand::_internal_calibrate() const {
  if (_internal_has_calibrate()) {
    return exclusive_command_.calibrate_;
  }
  return false;
}
inline void ArmExclusiveCommand::_internal_set_calibrate(bool value) {
  if (!_internal_has_calibrate()) {
    clear_exclusive_command();
    set_has_calibrate();
  }
  exclusive_command_.calibrate_ = value;
}
inline bool ArmExclusiveCommand::calibrate() const {
  // @@protoc_insertion_point(field_get:ArmExclusiveCommand.calibrate)
  return _internal_calibrate();
}
inline void ArmExclusiveCommand::set_calibrate(bool value) {
  _internal_set_calibrate(value);
  // @@protoc_insertion_point(field_set:ArmExclusiveCommand.calibrate)
}

inline bool ArmExclusiveCommand::has_exclusive_command() const {
  return exclusive_command_case() != EXCLUSIVE_COMMAND_NOT_SET;
}
inline void ArmExclusiveCommand::clear_has_exclusive_command() {
  _oneof_case_[0] = EXCLUSIVE_COMMAND_NOT_SET;
}
inline ArmExclusiveCommand::ExclusiveCommandCase ArmExclusiveCommand::exclusive_command_case() const {
  return ArmExclusiveCommand::ExclusiveCommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArmCommand

// .ArmExclusiveCommand arm_exclusive_command = 1;
inline bool ArmCommand::_internal_has_arm_exclusive_command() const {
  return command_case() == kArmExclusiveCommand;
}
inline bool ArmCommand::has_arm_exclusive_command() const {
  return _internal_has_arm_exclusive_command();
}
inline void ArmCommand::set_has_arm_exclusive_command() {
  _oneof_case_[0] = kArmExclusiveCommand;
}
inline void ArmCommand::clear_arm_exclusive_command() {
  if (_internal_has_arm_exclusive_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.arm_exclusive_command_;
    }
    clear_has_command();
  }
}
inline ::ArmExclusiveCommand* ArmCommand::release_arm_exclusive_command() {
  // @@protoc_insertion_point(field_release:ArmCommand.arm_exclusive_command)
  if (_internal_has_arm_exclusive_command()) {
    clear_has_command();
      ::ArmExclusiveCommand* temp = command_.arm_exclusive_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.arm_exclusive_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmExclusiveCommand& ArmCommand::_internal_arm_exclusive_command() const {
  return _internal_has_arm_exclusive_command()
      ? *command_.arm_exclusive_command_
      : reinterpret_cast< ::ArmExclusiveCommand&>(::_ArmExclusiveCommand_default_instance_);
}
inline const ::ArmExclusiveCommand& ArmCommand::arm_exclusive_command() const {
  // @@protoc_insertion_point(field_get:ArmCommand.arm_exclusive_command)
  return _internal_arm_exclusive_command();
}
inline ::ArmExclusiveCommand* ArmCommand::unsafe_arena_release_arm_exclusive_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmCommand.arm_exclusive_command)
  if (_internal_has_arm_exclusive_command()) {
    clear_has_command();
    ::ArmExclusiveCommand* temp = command_.arm_exclusive_command_;
    command_.arm_exclusive_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArmCommand::unsafe_arena_set_allocated_arm_exclusive_command(::ArmExclusiveCommand* arm_exclusive_command) {
  clear_command();
  if (arm_exclusive_command) {
    set_has_arm_exclusive_command();
    command_.arm_exclusive_command_ = arm_exclusive_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmCommand.arm_exclusive_command)
}
inline ::ArmExclusiveCommand* ArmCommand::_internal_mutable_arm_exclusive_command() {
  if (!_internal_has_arm_exclusive_command()) {
    clear_command();
    set_has_arm_exclusive_command();
    command_.arm_exclusive_command_ = CreateMaybeMessage< ::ArmExclusiveCommand >(GetArenaForAllocation());
  }
  return command_.arm_exclusive_command_;
}
inline ::ArmExclusiveCommand* ArmCommand::mutable_arm_exclusive_command() {
  ::ArmExclusiveCommand* _msg = _internal_mutable_arm_exclusive_command();
  // @@protoc_insertion_point(field_mutable:ArmCommand.arm_exclusive_command)
  return _msg;
}

// .ArmSharedCommand arm_shared_command = 2;
inline bool ArmCommand::_internal_has_arm_shared_command() const {
  return command_case() == kArmSharedCommand;
}
inline bool ArmCommand::has_arm_shared_command() const {
  return _internal_has_arm_shared_command();
}
inline void ArmCommand::set_has_arm_shared_command() {
  _oneof_case_[0] = kArmSharedCommand;
}
inline void ArmCommand::clear_arm_shared_command() {
  if (_internal_has_arm_shared_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.arm_shared_command_;
    }
    clear_has_command();
  }
}
inline ::ArmSharedCommand* ArmCommand::release_arm_shared_command() {
  // @@protoc_insertion_point(field_release:ArmCommand.arm_shared_command)
  if (_internal_has_arm_shared_command()) {
    clear_has_command();
      ::ArmSharedCommand* temp = command_.arm_shared_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.arm_shared_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ArmSharedCommand& ArmCommand::_internal_arm_shared_command() const {
  return _internal_has_arm_shared_command()
      ? *command_.arm_shared_command_
      : reinterpret_cast< ::ArmSharedCommand&>(::_ArmSharedCommand_default_instance_);
}
inline const ::ArmSharedCommand& ArmCommand::arm_shared_command() const {
  // @@protoc_insertion_point(field_get:ArmCommand.arm_shared_command)
  return _internal_arm_shared_command();
}
inline ::ArmSharedCommand* ArmCommand::unsafe_arena_release_arm_shared_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ArmCommand.arm_shared_command)
  if (_internal_has_arm_shared_command()) {
    clear_has_command();
    ::ArmSharedCommand* temp = command_.arm_shared_command_;
    command_.arm_shared_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ArmCommand::unsafe_arena_set_allocated_arm_shared_command(::ArmSharedCommand* arm_shared_command) {
  clear_command();
  if (arm_shared_command) {
    set_has_arm_shared_command();
    command_.arm_shared_command_ = arm_shared_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ArmCommand.arm_shared_command)
}
inline ::ArmSharedCommand* ArmCommand::_internal_mutable_arm_shared_command() {
  if (!_internal_has_arm_shared_command()) {
    clear_command();
    set_has_arm_shared_command();
    command_.arm_shared_command_ = CreateMaybeMessage< ::ArmSharedCommand >(GetArenaForAllocation());
  }
  return command_.arm_shared_command_;
}
inline ::ArmSharedCommand* ArmCommand::mutable_arm_shared_command() {
  ::ArmSharedCommand* _msg = _internal_mutable_arm_shared_command();
  // @@protoc_insertion_point(field_mutable:ArmCommand.arm_shared_command)
  return _msg;
}

inline bool ArmCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void ArmCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline ArmCommand::CommandCase ArmCommand::command_case() const {
  return ArmCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GamepadRead

// float left_stick_x = 1;
inline void GamepadRead::clear_left_stick_x() {
  left_stick_x_ = 0;
}
inline float GamepadRead::_internal_left_stick_x() const {
  return left_stick_x_;
}
inline float GamepadRead::left_stick_x() const {
  // @@protoc_insertion_point(field_get:GamepadRead.left_stick_x)
  return _internal_left_stick_x();
}
inline void GamepadRead::_internal_set_left_stick_x(float value) {
  
  left_stick_x_ = value;
}
inline void GamepadRead::set_left_stick_x(float value) {
  _internal_set_left_stick_x(value);
  // @@protoc_insertion_point(field_set:GamepadRead.left_stick_x)
}

// float left_stick_y = 2;
inline void GamepadRead::clear_left_stick_y() {
  left_stick_y_ = 0;
}
inline float GamepadRead::_internal_left_stick_y() const {
  return left_stick_y_;
}
inline float GamepadRead::left_stick_y() const {
  // @@protoc_insertion_point(field_get:GamepadRead.left_stick_y)
  return _internal_left_stick_y();
}
inline void GamepadRead::_internal_set_left_stick_y(float value) {
  
  left_stick_y_ = value;
}
inline void GamepadRead::set_left_stick_y(float value) {
  _internal_set_left_stick_y(value);
  // @@protoc_insertion_point(field_set:GamepadRead.left_stick_y)
}

// float right_stick_x = 3;
inline void GamepadRead::clear_right_stick_x() {
  right_stick_x_ = 0;
}
inline float GamepadRead::_internal_right_stick_x() const {
  return right_stick_x_;
}
inline float GamepadRead::right_stick_x() const {
  // @@protoc_insertion_point(field_get:GamepadRead.right_stick_x)
  return _internal_right_stick_x();
}
inline void GamepadRead::_internal_set_right_stick_x(float value) {
  
  right_stick_x_ = value;
}
inline void GamepadRead::set_right_stick_x(float value) {
  _internal_set_right_stick_x(value);
  // @@protoc_insertion_point(field_set:GamepadRead.right_stick_x)
}

// float right_stick_y = 4;
inline void GamepadRead::clear_right_stick_y() {
  right_stick_y_ = 0;
}
inline float GamepadRead::_internal_right_stick_y() const {
  return right_stick_y_;
}
inline float GamepadRead::right_stick_y() const {
  // @@protoc_insertion_point(field_get:GamepadRead.right_stick_y)
  return _internal_right_stick_y();
}
inline void GamepadRead::_internal_set_right_stick_y(float value) {
  
  right_stick_y_ = value;
}
inline void GamepadRead::set_right_stick_y(float value) {
  _internal_set_right_stick_y(value);
  // @@protoc_insertion_point(field_set:GamepadRead.right_stick_y)
}

// bool left_bumper = 5;
inline void GamepadRead::clear_left_bumper() {
  left_bumper_ = false;
}
inline bool GamepadRead::_internal_left_bumper() const {
  return left_bumper_;
}
inline bool GamepadRead::left_bumper() const {
  // @@protoc_insertion_point(field_get:GamepadRead.left_bumper)
  return _internal_left_bumper();
}
inline void GamepadRead::_internal_set_left_bumper(bool value) {
  
  left_bumper_ = value;
}
inline void GamepadRead::set_left_bumper(bool value) {
  _internal_set_left_bumper(value);
  // @@protoc_insertion_point(field_set:GamepadRead.left_bumper)
}

// bool right_bumper = 6;
inline void GamepadRead::clear_right_bumper() {
  right_bumper_ = false;
}
inline bool GamepadRead::_internal_right_bumper() const {
  return right_bumper_;
}
inline bool GamepadRead::right_bumper() const {
  // @@protoc_insertion_point(field_get:GamepadRead.right_bumper)
  return _internal_right_bumper();
}
inline void GamepadRead::_internal_set_right_bumper(bool value) {
  
  right_bumper_ = value;
}
inline void GamepadRead::set_right_bumper(bool value) {
  _internal_set_right_bumper(value);
  // @@protoc_insertion_point(field_set:GamepadRead.right_bumper)
}

// float left_trigger = 7;
inline void GamepadRead::clear_left_trigger() {
  left_trigger_ = 0;
}
inline float GamepadRead::_internal_left_trigger() const {
  return left_trigger_;
}
inline float GamepadRead::left_trigger() const {
  // @@protoc_insertion_point(field_get:GamepadRead.left_trigger)
  return _internal_left_trigger();
}
inline void GamepadRead::_internal_set_left_trigger(float value) {
  
  left_trigger_ = value;
}
inline void GamepadRead::set_left_trigger(float value) {
  _internal_set_left_trigger(value);
  // @@protoc_insertion_point(field_set:GamepadRead.left_trigger)
}

// float right_trigger = 8;
inline void GamepadRead::clear_right_trigger() {
  right_trigger_ = 0;
}
inline float GamepadRead::_internal_right_trigger() const {
  return right_trigger_;
}
inline float GamepadRead::right_trigger() const {
  // @@protoc_insertion_point(field_get:GamepadRead.right_trigger)
  return _internal_right_trigger();
}
inline void GamepadRead::_internal_set_right_trigger(float value) {
  
  right_trigger_ = value;
}
inline void GamepadRead::set_right_trigger(float value) {
  _internal_set_right_trigger(value);
  // @@protoc_insertion_point(field_set:GamepadRead.right_trigger)
}

// bool a_button = 9;
inline void GamepadRead::clear_a_button() {
  a_button_ = false;
}
inline bool GamepadRead::_internal_a_button() const {
  return a_button_;
}
inline bool GamepadRead::a_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.a_button)
  return _internal_a_button();
}
inline void GamepadRead::_internal_set_a_button(bool value) {
  
  a_button_ = value;
}
inline void GamepadRead::set_a_button(bool value) {
  _internal_set_a_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.a_button)
}

// bool b_button = 10;
inline void GamepadRead::clear_b_button() {
  b_button_ = false;
}
inline bool GamepadRead::_internal_b_button() const {
  return b_button_;
}
inline bool GamepadRead::b_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.b_button)
  return _internal_b_button();
}
inline void GamepadRead::_internal_set_b_button(bool value) {
  
  b_button_ = value;
}
inline void GamepadRead::set_b_button(bool value) {
  _internal_set_b_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.b_button)
}

// bool x_button = 11;
inline void GamepadRead::clear_x_button() {
  x_button_ = false;
}
inline bool GamepadRead::_internal_x_button() const {
  return x_button_;
}
inline bool GamepadRead::x_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.x_button)
  return _internal_x_button();
}
inline void GamepadRead::_internal_set_x_button(bool value) {
  
  x_button_ = value;
}
inline void GamepadRead::set_x_button(bool value) {
  _internal_set_x_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.x_button)
}

// bool y_button = 12;
inline void GamepadRead::clear_y_button() {
  y_button_ = false;
}
inline bool GamepadRead::_internal_y_button() const {
  return y_button_;
}
inline bool GamepadRead::y_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.y_button)
  return _internal_y_button();
}
inline void GamepadRead::_internal_set_y_button(bool value) {
  
  y_button_ = value;
}
inline void GamepadRead::set_y_button(bool value) {
  _internal_set_y_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.y_button)
}

// bool select_button = 13;
inline void GamepadRead::clear_select_button() {
  select_button_ = false;
}
inline bool GamepadRead::_internal_select_button() const {
  return select_button_;
}
inline bool GamepadRead::select_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.select_button)
  return _internal_select_button();
}
inline void GamepadRead::_internal_set_select_button(bool value) {
  
  select_button_ = value;
}
inline void GamepadRead::set_select_button(bool value) {
  _internal_set_select_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.select_button)
}

// bool start_button = 14;
inline void GamepadRead::clear_start_button() {
  start_button_ = false;
}
inline bool GamepadRead::_internal_start_button() const {
  return start_button_;
}
inline bool GamepadRead::start_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.start_button)
  return _internal_start_button();
}
inline void GamepadRead::_internal_set_start_button(bool value) {
  
  start_button_ = value;
}
inline void GamepadRead::set_start_button(bool value) {
  _internal_set_start_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.start_button)
}

// bool left_stick_button = 15;
inline void GamepadRead::clear_left_stick_button() {
  left_stick_button_ = false;
}
inline bool GamepadRead::_internal_left_stick_button() const {
  return left_stick_button_;
}
inline bool GamepadRead::left_stick_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.left_stick_button)
  return _internal_left_stick_button();
}
inline void GamepadRead::_internal_set_left_stick_button(bool value) {
  
  left_stick_button_ = value;
}
inline void GamepadRead::set_left_stick_button(bool value) {
  _internal_set_left_stick_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.left_stick_button)
}

// bool right_stick_button = 16;
inline void GamepadRead::clear_right_stick_button() {
  right_stick_button_ = false;
}
inline bool GamepadRead::_internal_right_stick_button() const {
  return right_stick_button_;
}
inline bool GamepadRead::right_stick_button() const {
  // @@protoc_insertion_point(field_get:GamepadRead.right_stick_button)
  return _internal_right_stick_button();
}
inline void GamepadRead::_internal_set_right_stick_button(bool value) {
  
  right_stick_button_ = value;
}
inline void GamepadRead::set_right_stick_button(bool value) {
  _internal_set_right_stick_button(value);
  // @@protoc_insertion_point(field_set:GamepadRead.right_stick_button)
}

// bool dpad_up = 17;
inline void GamepadRead::clear_dpad_up() {
  dpad_up_ = false;
}
inline bool GamepadRead::_internal_dpad_up() const {
  return dpad_up_;
}
inline bool GamepadRead::dpad_up() const {
  // @@protoc_insertion_point(field_get:GamepadRead.dpad_up)
  return _internal_dpad_up();
}
inline void GamepadRead::_internal_set_dpad_up(bool value) {
  
  dpad_up_ = value;
}
inline void GamepadRead::set_dpad_up(bool value) {
  _internal_set_dpad_up(value);
  // @@protoc_insertion_point(field_set:GamepadRead.dpad_up)
}

// bool dpad_down = 18;
inline void GamepadRead::clear_dpad_down() {
  dpad_down_ = false;
}
inline bool GamepadRead::_internal_dpad_down() const {
  return dpad_down_;
}
inline bool GamepadRead::dpad_down() const {
  // @@protoc_insertion_point(field_get:GamepadRead.dpad_down)
  return _internal_dpad_down();
}
inline void GamepadRead::_internal_set_dpad_down(bool value) {
  
  dpad_down_ = value;
}
inline void GamepadRead::set_dpad_down(bool value) {
  _internal_set_dpad_down(value);
  // @@protoc_insertion_point(field_set:GamepadRead.dpad_down)
}

// bool dpad_left = 19;
inline void GamepadRead::clear_dpad_left() {
  dpad_left_ = false;
}
inline bool GamepadRead::_internal_dpad_left() const {
  return dpad_left_;
}
inline bool GamepadRead::dpad_left() const {
  // @@protoc_insertion_point(field_get:GamepadRead.dpad_left)
  return _internal_dpad_left();
}
inline void GamepadRead::_internal_set_dpad_left(bool value) {
  
  dpad_left_ = value;
}
inline void GamepadRead::set_dpad_left(bool value) {
  _internal_set_dpad_left(value);
  // @@protoc_insertion_point(field_set:GamepadRead.dpad_left)
}

// bool dpad_right = 20;
inline void GamepadRead::clear_dpad_right() {
  dpad_right_ = false;
}
inline bool GamepadRead::_internal_dpad_right() const {
  return dpad_right_;
}
inline bool GamepadRead::dpad_right() const {
  // @@protoc_insertion_point(field_get:GamepadRead.dpad_right)
  return _internal_dpad_right();
}
inline void GamepadRead::_internal_set_dpad_right(bool value) {
  
  dpad_right_ = value;
}
inline void GamepadRead::set_dpad_right(bool value) {
  _internal_set_dpad_right(value);
  // @@protoc_insertion_point(field_set:GamepadRead.dpad_right)
}

// -------------------------------------------------------------------

// EnableKcp

// uint32 client_peer_port = 1;
inline void EnableKcp::clear_client_peer_port() {
  client_peer_port_ = 0u;
}
inline uint32_t EnableKcp::_internal_client_peer_port() const {
  return client_peer_port_;
}
inline uint32_t EnableKcp::client_peer_port() const {
  // @@protoc_insertion_point(field_get:EnableKcp.client_peer_port)
  return _internal_client_peer_port();
}
inline void EnableKcp::_internal_set_client_peer_port(uint32_t value) {
  
  client_peer_port_ = value;
}
inline void EnableKcp::set_client_peer_port(uint32_t value) {
  _internal_set_client_peer_port(value);
  // @@protoc_insertion_point(field_set:EnableKcp.client_peer_port)
}

// .KcpConfig kcp_config = 2;
inline bool EnableKcp::_internal_has_kcp_config() const {
  return this != internal_default_instance() && kcp_config_ != nullptr;
}
inline bool EnableKcp::has_kcp_config() const {
  return _internal_has_kcp_config();
}
inline void EnableKcp::clear_kcp_config() {
  if (GetArenaForAllocation() == nullptr && kcp_config_ != nullptr) {
    delete kcp_config_;
  }
  kcp_config_ = nullptr;
}
inline const ::KcpConfig& EnableKcp::_internal_kcp_config() const {
  const ::KcpConfig* p = kcp_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::KcpConfig&>(
      ::_KcpConfig_default_instance_);
}
inline const ::KcpConfig& EnableKcp::kcp_config() const {
  // @@protoc_insertion_point(field_get:EnableKcp.kcp_config)
  return _internal_kcp_config();
}
inline void EnableKcp::unsafe_arena_set_allocated_kcp_config(
    ::KcpConfig* kcp_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kcp_config_);
  }
  kcp_config_ = kcp_config;
  if (kcp_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EnableKcp.kcp_config)
}
inline ::KcpConfig* EnableKcp::release_kcp_config() {
  
  ::KcpConfig* temp = kcp_config_;
  kcp_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KcpConfig* EnableKcp::unsafe_arena_release_kcp_config() {
  // @@protoc_insertion_point(field_release:EnableKcp.kcp_config)
  
  ::KcpConfig* temp = kcp_config_;
  kcp_config_ = nullptr;
  return temp;
}
inline ::KcpConfig* EnableKcp::_internal_mutable_kcp_config() {
  
  if (kcp_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::KcpConfig>(GetArenaForAllocation());
    kcp_config_ = p;
  }
  return kcp_config_;
}
inline ::KcpConfig* EnableKcp::mutable_kcp_config() {
  ::KcpConfig* _msg = _internal_mutable_kcp_config();
  // @@protoc_insertion_point(field_mutable:EnableKcp.kcp_config)
  return _msg;
}
inline void EnableKcp::set_allocated_kcp_config(::KcpConfig* kcp_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kcp_config_;
  }
  if (kcp_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KcpConfig>::GetOwningArena(kcp_config);
    if (message_arena != submessage_arena) {
      kcp_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kcp_config, submessage_arena);
    }
    
  } else {
    
  }
  kcp_config_ = kcp_config;
  // @@protoc_insertion_point(field_set_allocated:EnableKcp.kcp_config)
}

// -------------------------------------------------------------------

// KcpServerStatus

// uint32 server_port = 1;
inline void KcpServerStatus::clear_server_port() {
  server_port_ = 0u;
}
inline uint32_t KcpServerStatus::_internal_server_port() const {
  return server_port_;
}
inline uint32_t KcpServerStatus::server_port() const {
  // @@protoc_insertion_point(field_get:KcpServerStatus.server_port)
  return _internal_server_port();
}
inline void KcpServerStatus::_internal_set_server_port(uint32_t value) {
  
  server_port_ = value;
}
inline void KcpServerStatus::set_server_port(uint32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:KcpServerStatus.server_port)
}

// .KcpConfig kcp_config = 2;
inline bool KcpServerStatus::_internal_has_kcp_config() const {
  return this != internal_default_instance() && kcp_config_ != nullptr;
}
inline bool KcpServerStatus::has_kcp_config() const {
  return _internal_has_kcp_config();
}
inline void KcpServerStatus::clear_kcp_config() {
  if (GetArenaForAllocation() == nullptr && kcp_config_ != nullptr) {
    delete kcp_config_;
  }
  kcp_config_ = nullptr;
}
inline const ::KcpConfig& KcpServerStatus::_internal_kcp_config() const {
  const ::KcpConfig* p = kcp_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::KcpConfig&>(
      ::_KcpConfig_default_instance_);
}
inline const ::KcpConfig& KcpServerStatus::kcp_config() const {
  // @@protoc_insertion_point(field_get:KcpServerStatus.kcp_config)
  return _internal_kcp_config();
}
inline void KcpServerStatus::unsafe_arena_set_allocated_kcp_config(
    ::KcpConfig* kcp_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kcp_config_);
  }
  kcp_config_ = kcp_config;
  if (kcp_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:KcpServerStatus.kcp_config)
}
inline ::KcpConfig* KcpServerStatus::release_kcp_config() {
  
  ::KcpConfig* temp = kcp_config_;
  kcp_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::KcpConfig* KcpServerStatus::unsafe_arena_release_kcp_config() {
  // @@protoc_insertion_point(field_release:KcpServerStatus.kcp_config)
  
  ::KcpConfig* temp = kcp_config_;
  kcp_config_ = nullptr;
  return temp;
}
inline ::KcpConfig* KcpServerStatus::_internal_mutable_kcp_config() {
  
  if (kcp_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::KcpConfig>(GetArenaForAllocation());
    kcp_config_ = p;
  }
  return kcp_config_;
}
inline ::KcpConfig* KcpServerStatus::mutable_kcp_config() {
  ::KcpConfig* _msg = _internal_mutable_kcp_config();
  // @@protoc_insertion_point(field_mutable:KcpServerStatus.kcp_config)
  return _msg;
}
inline void KcpServerStatus::set_allocated_kcp_config(::KcpConfig* kcp_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kcp_config_;
  }
  if (kcp_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::KcpConfig>::GetOwningArena(kcp_config);
    if (message_arena != submessage_arena) {
      kcp_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kcp_config, submessage_arena);
    }
    
  } else {
    
  }
  kcp_config_ = kcp_config;
  // @@protoc_insertion_point(field_set_allocated:KcpServerStatus.kcp_config)
}

// -------------------------------------------------------------------

// KcpConfig

// int32 window_size_snd_wnd = 1;
inline void KcpConfig::clear_window_size_snd_wnd() {
  window_size_snd_wnd_ = 0;
}
inline int32_t KcpConfig::_internal_window_size_snd_wnd() const {
  return window_size_snd_wnd_;
}
inline int32_t KcpConfig::window_size_snd_wnd() const {
  // @@protoc_insertion_point(field_get:KcpConfig.window_size_snd_wnd)
  return _internal_window_size_snd_wnd();
}
inline void KcpConfig::_internal_set_window_size_snd_wnd(int32_t value) {
  
  window_size_snd_wnd_ = value;
}
inline void KcpConfig::set_window_size_snd_wnd(int32_t value) {
  _internal_set_window_size_snd_wnd(value);
  // @@protoc_insertion_point(field_set:KcpConfig.window_size_snd_wnd)
}

// int32 window_size_rcv_wnd = 2;
inline void KcpConfig::clear_window_size_rcv_wnd() {
  window_size_rcv_wnd_ = 0;
}
inline int32_t KcpConfig::_internal_window_size_rcv_wnd() const {
  return window_size_rcv_wnd_;
}
inline int32_t KcpConfig::window_size_rcv_wnd() const {
  // @@protoc_insertion_point(field_get:KcpConfig.window_size_rcv_wnd)
  return _internal_window_size_rcv_wnd();
}
inline void KcpConfig::_internal_set_window_size_rcv_wnd(int32_t value) {
  
  window_size_rcv_wnd_ = value;
}
inline void KcpConfig::set_window_size_rcv_wnd(int32_t value) {
  _internal_set_window_size_rcv_wnd(value);
  // @@protoc_insertion_point(field_set:KcpConfig.window_size_rcv_wnd)
}

// int32 interval_ms = 3;
inline void KcpConfig::clear_interval_ms() {
  interval_ms_ = 0;
}
inline int32_t KcpConfig::_internal_interval_ms() const {
  return interval_ms_;
}
inline int32_t KcpConfig::interval_ms() const {
  // @@protoc_insertion_point(field_get:KcpConfig.interval_ms)
  return _internal_interval_ms();
}
inline void KcpConfig::_internal_set_interval_ms(int32_t value) {
  
  interval_ms_ = value;
}
inline void KcpConfig::set_interval_ms(int32_t value) {
  _internal_set_interval_ms(value);
  // @@protoc_insertion_point(field_set:KcpConfig.interval_ms)
}

// bool no_delay = 4;
inline void KcpConfig::clear_no_delay() {
  no_delay_ = false;
}
inline bool KcpConfig::_internal_no_delay() const {
  return no_delay_;
}
inline bool KcpConfig::no_delay() const {
  // @@protoc_insertion_point(field_get:KcpConfig.no_delay)
  return _internal_no_delay();
}
inline void KcpConfig::_internal_set_no_delay(bool value) {
  
  no_delay_ = value;
}
inline void KcpConfig::set_no_delay(bool value) {
  _internal_set_no_delay(value);
  // @@protoc_insertion_point(field_set:KcpConfig.no_delay)
}

// bool nc = 5;
inline void KcpConfig::clear_nc() {
  nc_ = false;
}
inline bool KcpConfig::_internal_nc() const {
  return nc_;
}
inline bool KcpConfig::nc() const {
  // @@protoc_insertion_point(field_get:KcpConfig.nc)
  return _internal_nc();
}
inline void KcpConfig::_internal_set_nc(bool value) {
  
  nc_ = value;
}
inline void KcpConfig::set_nc(bool value) {
  _internal_set_nc(value);
  // @@protoc_insertion_point(field_set:KcpConfig.nc)
}

// int32 resend = 6;
inline void KcpConfig::clear_resend() {
  resend_ = 0;
}
inline int32_t KcpConfig::_internal_resend() const {
  return resend_;
}
inline int32_t KcpConfig::resend() const {
  // @@protoc_insertion_point(field_get:KcpConfig.resend)
  return _internal_resend();
}
inline void KcpConfig::_internal_set_resend(int32_t value) {
  
  resend_ = value;
}
inline void KcpConfig::set_resend(int32_t value) {
  _internal_set_resend(value);
  // @@protoc_insertion_point(field_set:KcpConfig.resend)
}

// -------------------------------------------------------------------

// ImuAcceleration

// float ax = 1;
inline void ImuAcceleration::clear_ax() {
  ax_ = 0;
}
inline float ImuAcceleration::_internal_ax() const {
  return ax_;
}
inline float ImuAcceleration::ax() const {
  // @@protoc_insertion_point(field_get:ImuAcceleration.ax)
  return _internal_ax();
}
inline void ImuAcceleration::_internal_set_ax(float value) {
  
  ax_ = value;
}
inline void ImuAcceleration::set_ax(float value) {
  _internal_set_ax(value);
  // @@protoc_insertion_point(field_set:ImuAcceleration.ax)
}

// float ay = 2;
inline void ImuAcceleration::clear_ay() {
  ay_ = 0;
}
inline float ImuAcceleration::_internal_ay() const {
  return ay_;
}
inline float ImuAcceleration::ay() const {
  // @@protoc_insertion_point(field_get:ImuAcceleration.ay)
  return _internal_ay();
}
inline void ImuAcceleration::_internal_set_ay(float value) {
  
  ay_ = value;
}
inline void ImuAcceleration::set_ay(float value) {
  _internal_set_ay(value);
  // @@protoc_insertion_point(field_set:ImuAcceleration.ay)
}

// float az = 3;
inline void ImuAcceleration::clear_az() {
  az_ = 0;
}
inline float ImuAcceleration::_internal_az() const {
  return az_;
}
inline float ImuAcceleration::az() const {
  // @@protoc_insertion_point(field_get:ImuAcceleration.az)
  return _internal_az();
}
inline void ImuAcceleration::_internal_set_az(float value) {
  
  az_ = value;
}
inline void ImuAcceleration::set_az(float value) {
  _internal_set_az(value);
  // @@protoc_insertion_point(field_set:ImuAcceleration.az)
}

// -------------------------------------------------------------------

// ImuAngularVelocity

// float wx = 1;
inline void ImuAngularVelocity::clear_wx() {
  wx_ = 0;
}
inline float ImuAngularVelocity::_internal_wx() const {
  return wx_;
}
inline float ImuAngularVelocity::wx() const {
  // @@protoc_insertion_point(field_get:ImuAngularVelocity.wx)
  return _internal_wx();
}
inline void ImuAngularVelocity::_internal_set_wx(float value) {
  
  wx_ = value;
}
inline void ImuAngularVelocity::set_wx(float value) {
  _internal_set_wx(value);
  // @@protoc_insertion_point(field_set:ImuAngularVelocity.wx)
}

// float wy = 2;
inline void ImuAngularVelocity::clear_wy() {
  wy_ = 0;
}
inline float ImuAngularVelocity::_internal_wy() const {
  return wy_;
}
inline float ImuAngularVelocity::wy() const {
  // @@protoc_insertion_point(field_get:ImuAngularVelocity.wy)
  return _internal_wy();
}
inline void ImuAngularVelocity::_internal_set_wy(float value) {
  
  wy_ = value;
}
inline void ImuAngularVelocity::set_wy(float value) {
  _internal_set_wy(value);
  // @@protoc_insertion_point(field_set:ImuAngularVelocity.wy)
}

// float wz = 3;
inline void ImuAngularVelocity::clear_wz() {
  wz_ = 0;
}
inline float ImuAngularVelocity::_internal_wz() const {
  return wz_;
}
inline float ImuAngularVelocity::wz() const {
  // @@protoc_insertion_point(field_get:ImuAngularVelocity.wz)
  return _internal_wz();
}
inline void ImuAngularVelocity::_internal_set_wz(float value) {
  
  wz_ = value;
}
inline void ImuAngularVelocity::set_wz(float value) {
  _internal_set_wz(value);
  // @@protoc_insertion_point(field_set:ImuAngularVelocity.wz)
}

// -------------------------------------------------------------------

// ImuQuaternion

// float qx = 1;
inline void ImuQuaternion::clear_qx() {
  qx_ = 0;
}
inline float ImuQuaternion::_internal_qx() const {
  return qx_;
}
inline float ImuQuaternion::qx() const {
  // @@protoc_insertion_point(field_get:ImuQuaternion.qx)
  return _internal_qx();
}
inline void ImuQuaternion::_internal_set_qx(float value) {
  
  qx_ = value;
}
inline void ImuQuaternion::set_qx(float value) {
  _internal_set_qx(value);
  // @@protoc_insertion_point(field_set:ImuQuaternion.qx)
}

// float qy = 2;
inline void ImuQuaternion::clear_qy() {
  qy_ = 0;
}
inline float ImuQuaternion::_internal_qy() const {
  return qy_;
}
inline float ImuQuaternion::qy() const {
  // @@protoc_insertion_point(field_get:ImuQuaternion.qy)
  return _internal_qy();
}
inline void ImuQuaternion::_internal_set_qy(float value) {
  
  qy_ = value;
}
inline void ImuQuaternion::set_qy(float value) {
  _internal_set_qy(value);
  // @@protoc_insertion_point(field_set:ImuQuaternion.qy)
}

// float qz = 3;
inline void ImuQuaternion::clear_qz() {
  qz_ = 0;
}
inline float ImuQuaternion::_internal_qz() const {
  return qz_;
}
inline float ImuQuaternion::qz() const {
  // @@protoc_insertion_point(field_get:ImuQuaternion.qz)
  return _internal_qz();
}
inline void ImuQuaternion::_internal_set_qz(float value) {
  
  qz_ = value;
}
inline void ImuQuaternion::set_qz(float value) {
  _internal_set_qz(value);
  // @@protoc_insertion_point(field_set:ImuQuaternion.qz)
}

// float qw = 4;
inline void ImuQuaternion::clear_qw() {
  qw_ = 0;
}
inline float ImuQuaternion::_internal_qw() const {
  return qw_;
}
inline float ImuQuaternion::qw() const {
  // @@protoc_insertion_point(field_get:ImuQuaternion.qw)
  return _internal_qw();
}
inline void ImuQuaternion::_internal_set_qw(float value) {
  
  qw_ = value;
}
inline void ImuQuaternion::set_qw(float value) {
  _internal_set_qw(value);
  // @@protoc_insertion_point(field_set:ImuQuaternion.qw)
}

// -------------------------------------------------------------------

// ImuData

// .ImuAcceleration acceleration = 1;
inline bool ImuData::_internal_has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != nullptr;
}
inline bool ImuData::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void ImuData::clear_acceleration() {
  if (GetArenaForAllocation() == nullptr && acceleration_ != nullptr) {
    delete acceleration_;
  }
  acceleration_ = nullptr;
}
inline const ::ImuAcceleration& ImuData::_internal_acceleration() const {
  const ::ImuAcceleration* p = acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::ImuAcceleration&>(
      ::_ImuAcceleration_default_instance_);
}
inline const ::ImuAcceleration& ImuData::acceleration() const {
  // @@protoc_insertion_point(field_get:ImuData.acceleration)
  return _internal_acceleration();
}
inline void ImuData::unsafe_arena_set_allocated_acceleration(
    ::ImuAcceleration* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ImuData.acceleration)
}
inline ::ImuAcceleration* ImuData::release_acceleration() {
  
  ::ImuAcceleration* temp = acceleration_;
  acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ImuAcceleration* ImuData::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:ImuData.acceleration)
  
  ::ImuAcceleration* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline ::ImuAcceleration* ImuData::_internal_mutable_acceleration() {
  
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImuAcceleration>(GetArenaForAllocation());
    acceleration_ = p;
  }
  return acceleration_;
}
inline ::ImuAcceleration* ImuData::mutable_acceleration() {
  ::ImuAcceleration* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:ImuData.acceleration)
  return _msg;
}
inline void ImuData::set_allocated_acceleration(::ImuAcceleration* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ImuAcceleration>::GetOwningArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:ImuData.acceleration)
}

// .ImuAngularVelocity angular_velocity = 2;
inline bool ImuData::_internal_has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != nullptr;
}
inline bool ImuData::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void ImuData::clear_angular_velocity() {
  if (GetArenaForAllocation() == nullptr && angular_velocity_ != nullptr) {
    delete angular_velocity_;
  }
  angular_velocity_ = nullptr;
}
inline const ::ImuAngularVelocity& ImuData::_internal_angular_velocity() const {
  const ::ImuAngularVelocity* p = angular_velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::ImuAngularVelocity&>(
      ::_ImuAngularVelocity_default_instance_);
}
inline const ::ImuAngularVelocity& ImuData::angular_velocity() const {
  // @@protoc_insertion_point(field_get:ImuData.angular_velocity)
  return _internal_angular_velocity();
}
inline void ImuData::unsafe_arena_set_allocated_angular_velocity(
    ::ImuAngularVelocity* angular_velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_velocity_);
  }
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ImuData.angular_velocity)
}
inline ::ImuAngularVelocity* ImuData::release_angular_velocity() {
  
  ::ImuAngularVelocity* temp = angular_velocity_;
  angular_velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ImuAngularVelocity* ImuData::unsafe_arena_release_angular_velocity() {
  // @@protoc_insertion_point(field_release:ImuData.angular_velocity)
  
  ::ImuAngularVelocity* temp = angular_velocity_;
  angular_velocity_ = nullptr;
  return temp;
}
inline ::ImuAngularVelocity* ImuData::_internal_mutable_angular_velocity() {
  
  if (angular_velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImuAngularVelocity>(GetArenaForAllocation());
    angular_velocity_ = p;
  }
  return angular_velocity_;
}
inline ::ImuAngularVelocity* ImuData::mutable_angular_velocity() {
  ::ImuAngularVelocity* _msg = _internal_mutable_angular_velocity();
  // @@protoc_insertion_point(field_mutable:ImuData.angular_velocity)
  return _msg;
}
inline void ImuData::set_allocated_angular_velocity(::ImuAngularVelocity* angular_velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ImuAngularVelocity>::GetOwningArena(angular_velocity);
    if (message_arena != submessage_arena) {
      angular_velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:ImuData.angular_velocity)
}

// .ImuQuaternion quaternion = 3;
inline bool ImuData::_internal_has_quaternion() const {
  return this != internal_default_instance() && quaternion_ != nullptr;
}
inline bool ImuData::has_quaternion() const {
  return _internal_has_quaternion();
}
inline void ImuData::clear_quaternion() {
  if (GetArenaForAllocation() == nullptr && quaternion_ != nullptr) {
    delete quaternion_;
  }
  quaternion_ = nullptr;
}
inline const ::ImuQuaternion& ImuData::_internal_quaternion() const {
  const ::ImuQuaternion* p = quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::ImuQuaternion&>(
      ::_ImuQuaternion_default_instance_);
}
inline const ::ImuQuaternion& ImuData::quaternion() const {
  // @@protoc_insertion_point(field_get:ImuData.quaternion)
  return _internal_quaternion();
}
inline void ImuData::unsafe_arena_set_allocated_quaternion(
    ::ImuQuaternion* quaternion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quaternion_);
  }
  quaternion_ = quaternion;
  if (quaternion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ImuData.quaternion)
}
inline ::ImuQuaternion* ImuData::release_quaternion() {
  
  ::ImuQuaternion* temp = quaternion_;
  quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ImuQuaternion* ImuData::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_release:ImuData.quaternion)
  
  ::ImuQuaternion* temp = quaternion_;
  quaternion_ = nullptr;
  return temp;
}
inline ::ImuQuaternion* ImuData::_internal_mutable_quaternion() {
  
  if (quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImuQuaternion>(GetArenaForAllocation());
    quaternion_ = p;
  }
  return quaternion_;
}
inline ::ImuQuaternion* ImuData::mutable_quaternion() {
  ::ImuQuaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:ImuData.quaternion)
  return _msg;
}
inline void ImuData::set_allocated_quaternion(::ImuQuaternion* quaternion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete quaternion_;
  }
  if (quaternion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ImuQuaternion>::GetOwningArena(quaternion);
    if (message_arena != submessage_arena) {
      quaternion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    
  } else {
    
  }
  quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:ImuData.quaternion)
}

// -------------------------------------------------------------------

// ParkingStopDetail

// string reason = 1;
inline void ParkingStopDetail::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& ParkingStopDetail::reason() const {
  // @@protoc_insertion_point(field_get:ParkingStopDetail.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParkingStopDetail::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ParkingStopDetail.reason)
}
inline std::string* ParkingStopDetail::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:ParkingStopDetail.reason)
  return _s;
}
inline const std::string& ParkingStopDetail::_internal_reason() const {
  return reason_.Get();
}
inline void ParkingStopDetail::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParkingStopDetail::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParkingStopDetail::release_reason() {
  // @@protoc_insertion_point(field_release:ParkingStopDetail.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParkingStopDetail::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ParkingStopDetail.reason)
}

// .ParkingStopCategory category = 2;
inline void ParkingStopDetail::clear_category() {
  category_ = 0;
}
inline ::ParkingStopCategory ParkingStopDetail::_internal_category() const {
  return static_cast< ::ParkingStopCategory >(category_);
}
inline ::ParkingStopCategory ParkingStopDetail::category() const {
  // @@protoc_insertion_point(field_get:ParkingStopDetail.category)
  return _internal_category();
}
inline void ParkingStopDetail::_internal_set_category(::ParkingStopCategory value) {
  
  category_ = value;
}
inline void ParkingStopDetail::set_category(::ParkingStopCategory value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:ParkingStopDetail.category)
}

// bool is_remotely_clearable = 3;
inline void ParkingStopDetail::clear_is_remotely_clearable() {
  is_remotely_clearable_ = false;
}
inline bool ParkingStopDetail::_internal_is_remotely_clearable() const {
  return is_remotely_clearable_;
}
inline bool ParkingStopDetail::is_remotely_clearable() const {
  // @@protoc_insertion_point(field_get:ParkingStopDetail.is_remotely_clearable)
  return _internal_is_remotely_clearable();
}
inline void ParkingStopDetail::_internal_set_is_remotely_clearable(bool value) {
  
  is_remotely_clearable_ = value;
}
inline void ParkingStopDetail::set_is_remotely_clearable(bool value) {
  _internal_set_is_remotely_clearable(value);
  // @@protoc_insertion_point(field_set:ParkingStopDetail.is_remotely_clearable)
}

// -------------------------------------------------------------------

// SingleMotorTarget

// double torque = 1;
inline bool SingleMotorTarget::_internal_has_torque() const {
  return target_case() == kTorque;
}
inline bool SingleMotorTarget::has_torque() const {
  return _internal_has_torque();
}
inline void SingleMotorTarget::set_has_torque() {
  _oneof_case_[0] = kTorque;
}
inline void SingleMotorTarget::clear_torque() {
  if (_internal_has_torque()) {
    target_.torque_ = 0;
    clear_has_target();
  }
}
inline double SingleMotorTarget::_internal_torque() const {
  if (_internal_has_torque()) {
    return target_.torque_;
  }
  return 0;
}
inline void SingleMotorTarget::_internal_set_torque(double value) {
  if (!_internal_has_torque()) {
    clear_target();
    set_has_torque();
  }
  target_.torque_ = value;
}
inline double SingleMotorTarget::torque() const {
  // @@protoc_insertion_point(field_get:SingleMotorTarget.torque)
  return _internal_torque();
}
inline void SingleMotorTarget::set_torque(double value) {
  _internal_set_torque(value);
  // @@protoc_insertion_point(field_set:SingleMotorTarget.torque)
}

// double speed = 2;
inline bool SingleMotorTarget::_internal_has_speed() const {
  return target_case() == kSpeed;
}
inline bool SingleMotorTarget::has_speed() const {
  return _internal_has_speed();
}
inline void SingleMotorTarget::set_has_speed() {
  _oneof_case_[0] = kSpeed;
}
inline void SingleMotorTarget::clear_speed() {
  if (_internal_has_speed()) {
    target_.speed_ = 0;
    clear_has_target();
  }
}
inline double SingleMotorTarget::_internal_speed() const {
  if (_internal_has_speed()) {
    return target_.speed_;
  }
  return 0;
}
inline void SingleMotorTarget::_internal_set_speed(double value) {
  if (!_internal_has_speed()) {
    clear_target();
    set_has_speed();
  }
  target_.speed_ = value;
}
inline double SingleMotorTarget::speed() const {
  // @@protoc_insertion_point(field_get:SingleMotorTarget.speed)
  return _internal_speed();
}
inline void SingleMotorTarget::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:SingleMotorTarget.speed)
}

// int64 position = 3;
inline bool SingleMotorTarget::_internal_has_position() const {
  return target_case() == kPosition;
}
inline bool SingleMotorTarget::has_position() const {
  return _internal_has_position();
}
inline void SingleMotorTarget::set_has_position() {
  _oneof_case_[0] = kPosition;
}
inline void SingleMotorTarget::clear_position() {
  if (_internal_has_position()) {
    target_.position_ = int64_t{0};
    clear_has_target();
  }
}
inline int64_t SingleMotorTarget::_internal_position() const {
  if (_internal_has_position()) {
    return target_.position_;
  }
  return int64_t{0};
}
inline void SingleMotorTarget::_internal_set_position(int64_t value) {
  if (!_internal_has_position()) {
    clear_target();
    set_has_position();
  }
  target_.position_ = value;
}
inline int64_t SingleMotorTarget::position() const {
  // @@protoc_insertion_point(field_get:SingleMotorTarget.position)
  return _internal_position();
}
inline void SingleMotorTarget::set_position(int64_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:SingleMotorTarget.position)
}

// bool brake = 4;
inline bool SingleMotorTarget::_internal_has_brake() const {
  return target_case() == kBrake;
}
inline bool SingleMotorTarget::has_brake() const {
  return _internal_has_brake();
}
inline void SingleMotorTarget::set_has_brake() {
  _oneof_case_[0] = kBrake;
}
inline void SingleMotorTarget::clear_brake() {
  if (_internal_has_brake()) {
    target_.brake_ = false;
    clear_has_target();
  }
}
inline bool SingleMotorTarget::_internal_brake() const {
  if (_internal_has_brake()) {
    return target_.brake_;
  }
  return false;
}
inline void SingleMotorTarget::_internal_set_brake(bool value) {
  if (!_internal_has_brake()) {
    clear_target();
    set_has_brake();
  }
  target_.brake_ = value;
}
inline bool SingleMotorTarget::brake() const {
  // @@protoc_insertion_point(field_get:SingleMotorTarget.brake)
  return _internal_brake();
}
inline void SingleMotorTarget::set_brake(bool value) {
  _internal_set_brake(value);
  // @@protoc_insertion_point(field_set:SingleMotorTarget.brake)
}

// .MitMotorTarget mit_target = 5;
inline bool SingleMotorTarget::_internal_has_mit_target() const {
  return target_case() == kMitTarget;
}
inline bool SingleMotorTarget::has_mit_target() const {
  return _internal_has_mit_target();
}
inline void SingleMotorTarget::set_has_mit_target() {
  _oneof_case_[0] = kMitTarget;
}
inline void SingleMotorTarget::clear_mit_target() {
  if (_internal_has_mit_target()) {
    if (GetArenaForAllocation() == nullptr) {
      delete target_.mit_target_;
    }
    clear_has_target();
  }
}
inline ::MitMotorTarget* SingleMotorTarget::release_mit_target() {
  // @@protoc_insertion_point(field_release:SingleMotorTarget.mit_target)
  if (_internal_has_mit_target()) {
    clear_has_target();
      ::MitMotorTarget* temp = target_.mit_target_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    target_.mit_target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MitMotorTarget& SingleMotorTarget::_internal_mit_target() const {
  return _internal_has_mit_target()
      ? *target_.mit_target_
      : reinterpret_cast< ::MitMotorTarget&>(::_MitMotorTarget_default_instance_);
}
inline const ::MitMotorTarget& SingleMotorTarget::mit_target() const {
  // @@protoc_insertion_point(field_get:SingleMotorTarget.mit_target)
  return _internal_mit_target();
}
inline ::MitMotorTarget* SingleMotorTarget::unsafe_arena_release_mit_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SingleMotorTarget.mit_target)
  if (_internal_has_mit_target()) {
    clear_has_target();
    ::MitMotorTarget* temp = target_.mit_target_;
    target_.mit_target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SingleMotorTarget::unsafe_arena_set_allocated_mit_target(::MitMotorTarget* mit_target) {
  clear_target();
  if (mit_target) {
    set_has_mit_target();
    target_.mit_target_ = mit_target;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SingleMotorTarget.mit_target)
}
inline ::MitMotorTarget* SingleMotorTarget::_internal_mutable_mit_target() {
  if (!_internal_has_mit_target()) {
    clear_target();
    set_has_mit_target();
    target_.mit_target_ = CreateMaybeMessage< ::MitMotorTarget >(GetArenaForAllocation());
  }
  return target_.mit_target_;
}
inline ::MitMotorTarget* SingleMotorTarget::mutable_mit_target() {
  ::MitMotorTarget* _msg = _internal_mutable_mit_target();
  // @@protoc_insertion_point(field_mutable:SingleMotorTarget.mit_target)
  return _msg;
}

inline bool SingleMotorTarget::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void SingleMotorTarget::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline SingleMotorTarget::TargetCase SingleMotorTarget::target_case() const {
  return SingleMotorTarget::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MitMotorTarget

// double torque = 1;
inline void MitMotorTarget::clear_torque() {
  torque_ = 0;
}
inline double MitMotorTarget::_internal_torque() const {
  return torque_;
}
inline double MitMotorTarget::torque() const {
  // @@protoc_insertion_point(field_get:MitMotorTarget.torque)
  return _internal_torque();
}
inline void MitMotorTarget::_internal_set_torque(double value) {
  
  torque_ = value;
}
inline void MitMotorTarget::set_torque(double value) {
  _internal_set_torque(value);
  // @@protoc_insertion_point(field_set:MitMotorTarget.torque)
}

// double speed = 2;
inline void MitMotorTarget::clear_speed() {
  speed_ = 0;
}
inline double MitMotorTarget::_internal_speed() const {
  return speed_;
}
inline double MitMotorTarget::speed() const {
  // @@protoc_insertion_point(field_get:MitMotorTarget.speed)
  return _internal_speed();
}
inline void MitMotorTarget::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MitMotorTarget::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:MitMotorTarget.speed)
}

// double position = 3;
inline void MitMotorTarget::clear_position() {
  position_ = 0;
}
inline double MitMotorTarget::_internal_position() const {
  return position_;
}
inline double MitMotorTarget::position() const {
  // @@protoc_insertion_point(field_get:MitMotorTarget.position)
  return _internal_position();
}
inline void MitMotorTarget::_internal_set_position(double value) {
  
  position_ = value;
}
inline void MitMotorTarget::set_position(double value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:MitMotorTarget.position)
}

// double kp = 4;
inline void MitMotorTarget::clear_kp() {
  kp_ = 0;
}
inline double MitMotorTarget::_internal_kp() const {
  return kp_;
}
inline double MitMotorTarget::kp() const {
  // @@protoc_insertion_point(field_get:MitMotorTarget.kp)
  return _internal_kp();
}
inline void MitMotorTarget::_internal_set_kp(double value) {
  
  kp_ = value;
}
inline void MitMotorTarget::set_kp(double value) {
  _internal_set_kp(value);
  // @@protoc_insertion_point(field_set:MitMotorTarget.kp)
}

// double kd = 5;
inline void MitMotorTarget::clear_kd() {
  kd_ = 0;
}
inline double MitMotorTarget::_internal_kd() const {
  return kd_;
}
inline double MitMotorTarget::kd() const {
  // @@protoc_insertion_point(field_get:MitMotorTarget.kd)
  return _internal_kd();
}
inline void MitMotorTarget::_internal_set_kd(double value) {
  
  kd_ = value;
}
inline void MitMotorTarget::set_kd(double value) {
  _internal_set_kd(value);
  // @@protoc_insertion_point(field_set:MitMotorTarget.kd)
}

// -------------------------------------------------------------------

// MotorTargets

// repeated .SingleMotorTarget targets = 1;
inline int MotorTargets::_internal_targets_size() const {
  return targets_.size();
}
inline int MotorTargets::targets_size() const {
  return _internal_targets_size();
}
inline void MotorTargets::clear_targets() {
  targets_.Clear();
}
inline ::SingleMotorTarget* MotorTargets::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:MotorTargets.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SingleMotorTarget >*
MotorTargets::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:MotorTargets.targets)
  return &targets_;
}
inline const ::SingleMotorTarget& MotorTargets::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::SingleMotorTarget& MotorTargets::targets(int index) const {
  // @@protoc_insertion_point(field_get:MotorTargets.targets)
  return _internal_targets(index);
}
inline ::SingleMotorTarget* MotorTargets::_internal_add_targets() {
  return targets_.Add();
}
inline ::SingleMotorTarget* MotorTargets::add_targets() {
  ::SingleMotorTarget* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:MotorTargets.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SingleMotorTarget >&
MotorTargets::targets() const {
  // @@protoc_insertion_point(field_list:MotorTargets.targets)
  return targets_;
}

// -------------------------------------------------------------------

// MotorStatus

// double torque = 2;
inline void MotorStatus::clear_torque() {
  torque_ = 0;
}
inline double MotorStatus::_internal_torque() const {
  return torque_;
}
inline double MotorStatus::torque() const {
  // @@protoc_insertion_point(field_get:MotorStatus.torque)
  return _internal_torque();
}
inline void MotorStatus::_internal_set_torque(double value) {
  
  torque_ = value;
}
inline void MotorStatus::set_torque(double value) {
  _internal_set_torque(value);
  // @@protoc_insertion_point(field_set:MotorStatus.torque)
}

// double speed = 3;
inline void MotorStatus::clear_speed() {
  speed_ = 0;
}
inline double MotorStatus::_internal_speed() const {
  return speed_;
}
inline double MotorStatus::speed() const {
  // @@protoc_insertion_point(field_get:MotorStatus.speed)
  return _internal_speed();
}
inline void MotorStatus::_internal_set_speed(double value) {
  
  speed_ = value;
}
inline void MotorStatus::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:MotorStatus.speed)
}

// int64 position = 4;
inline void MotorStatus::clear_position() {
  position_ = int64_t{0};
}
inline int64_t MotorStatus::_internal_position() const {
  return position_;
}
inline int64_t MotorStatus::position() const {
  // @@protoc_insertion_point(field_get:MotorStatus.position)
  return _internal_position();
}
inline void MotorStatus::_internal_set_position(int64_t value) {
  
  position_ = value;
}
inline void MotorStatus::set_position(int64_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:MotorStatus.position)
}

// uint32 pulse_per_rotation = 5;
inline void MotorStatus::clear_pulse_per_rotation() {
  pulse_per_rotation_ = 0u;
}
inline uint32_t MotorStatus::_internal_pulse_per_rotation() const {
  return pulse_per_rotation_;
}
inline uint32_t MotorStatus::pulse_per_rotation() const {
  // @@protoc_insertion_point(field_get:MotorStatus.pulse_per_rotation)
  return _internal_pulse_per_rotation();
}
inline void MotorStatus::_internal_set_pulse_per_rotation(uint32_t value) {
  
  pulse_per_rotation_ = value;
}
inline void MotorStatus::set_pulse_per_rotation(uint32_t value) {
  _internal_set_pulse_per_rotation(value);
  // @@protoc_insertion_point(field_set:MotorStatus.pulse_per_rotation)
}

// double wheel_radius = 6;
inline void MotorStatus::clear_wheel_radius() {
  wheel_radius_ = 0;
}
inline double MotorStatus::_internal_wheel_radius() const {
  return wheel_radius_;
}
inline double MotorStatus::wheel_radius() const {
  // @@protoc_insertion_point(field_get:MotorStatus.wheel_radius)
  return _internal_wheel_radius();
}
inline void MotorStatus::_internal_set_wheel_radius(double value) {
  
  wheel_radius_ = value;
}
inline void MotorStatus::set_wheel_radius(double value) {
  _internal_set_wheel_radius(value);
  // @@protoc_insertion_point(field_set:MotorStatus.wheel_radius)
}

// repeated .MotorError error = 7;
inline int MotorStatus::_internal_error_size() const {
  return error_.size();
}
inline int MotorStatus::error_size() const {
  return _internal_error_size();
}
inline void MotorStatus::clear_error() {
  error_.Clear();
}
inline ::MotorError MotorStatus::_internal_error(int index) const {
  return static_cast< ::MotorError >(error_.Get(index));
}
inline ::MotorError MotorStatus::error(int index) const {
  // @@protoc_insertion_point(field_get:MotorStatus.error)
  return _internal_error(index);
}
inline void MotorStatus::set_error(int index, ::MotorError value) {
  error_.Set(index, value);
  // @@protoc_insertion_point(field_set:MotorStatus.error)
}
inline void MotorStatus::_internal_add_error(::MotorError value) {
  error_.Add(value);
}
inline void MotorStatus::add_error(::MotorError value) {
  _internal_add_error(value);
  // @@protoc_insertion_point(field_add:MotorStatus.error)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MotorStatus::error() const {
  // @@protoc_insertion_point(field_list:MotorStatus.error)
  return error_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MotorStatus::_internal_mutable_error() {
  return &error_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MotorStatus::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:MotorStatus.error)
  return _internal_mutable_error();
}

// .SingleMotorTarget current_target = 8;
inline bool MotorStatus::_internal_has_current_target() const {
  return this != internal_default_instance() && current_target_ != nullptr;
}
inline bool MotorStatus::has_current_target() const {
  return _internal_has_current_target();
}
inline void MotorStatus::clear_current_target() {
  if (GetArenaForAllocation() == nullptr && current_target_ != nullptr) {
    delete current_target_;
  }
  current_target_ = nullptr;
}
inline const ::SingleMotorTarget& MotorStatus::_internal_current_target() const {
  const ::SingleMotorTarget* p = current_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::SingleMotorTarget&>(
      ::_SingleMotorTarget_default_instance_);
}
inline const ::SingleMotorTarget& MotorStatus::current_target() const {
  // @@protoc_insertion_point(field_get:MotorStatus.current_target)
  return _internal_current_target();
}
inline void MotorStatus::unsafe_arena_set_allocated_current_target(
    ::SingleMotorTarget* current_target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_target_);
  }
  current_target_ = current_target;
  if (current_target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MotorStatus.current_target)
}
inline ::SingleMotorTarget* MotorStatus::release_current_target() {
  
  ::SingleMotorTarget* temp = current_target_;
  current_target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SingleMotorTarget* MotorStatus::unsafe_arena_release_current_target() {
  // @@protoc_insertion_point(field_release:MotorStatus.current_target)
  
  ::SingleMotorTarget* temp = current_target_;
  current_target_ = nullptr;
  return temp;
}
inline ::SingleMotorTarget* MotorStatus::_internal_mutable_current_target() {
  
  if (current_target_ == nullptr) {
    auto* p = CreateMaybeMessage<::SingleMotorTarget>(GetArenaForAllocation());
    current_target_ = p;
  }
  return current_target_;
}
inline ::SingleMotorTarget* MotorStatus::mutable_current_target() {
  ::SingleMotorTarget* _msg = _internal_mutable_current_target();
  // @@protoc_insertion_point(field_mutable:MotorStatus.current_target)
  return _msg;
}
inline void MotorStatus::set_allocated_current_target(::SingleMotorTarget* current_target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete current_target_;
  }
  if (current_target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SingleMotorTarget>::GetOwningArena(current_target);
    if (message_arena != submessage_arena) {
      current_target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_target, submessage_arena);
    }
    
  } else {
    
  }
  current_target_ = current_target;
  // @@protoc_insertion_point(field_set_allocated:MotorStatus.current_target)
}

// optional float driver_temperature = 11;
inline bool MotorStatus::_internal_has_driver_temperature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotorStatus::has_driver_temperature() const {
  return _internal_has_driver_temperature();
}
inline void MotorStatus::clear_driver_temperature() {
  driver_temperature_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotorStatus::_internal_driver_temperature() const {
  return driver_temperature_;
}
inline float MotorStatus::driver_temperature() const {
  // @@protoc_insertion_point(field_get:MotorStatus.driver_temperature)
  return _internal_driver_temperature();
}
inline void MotorStatus::_internal_set_driver_temperature(float value) {
  _has_bits_[0] |= 0x00000001u;
  driver_temperature_ = value;
}
inline void MotorStatus::set_driver_temperature(float value) {
  _internal_set_driver_temperature(value);
  // @@protoc_insertion_point(field_set:MotorStatus.driver_temperature)
}

// optional float motor_temperature = 12;
inline bool MotorStatus::_internal_has_motor_temperature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotorStatus::has_motor_temperature() const {
  return _internal_has_motor_temperature();
}
inline void MotorStatus::clear_motor_temperature() {
  motor_temperature_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MotorStatus::_internal_motor_temperature() const {
  return motor_temperature_;
}
inline float MotorStatus::motor_temperature() const {
  // @@protoc_insertion_point(field_get:MotorStatus.motor_temperature)
  return _internal_motor_temperature();
}
inline void MotorStatus::_internal_set_motor_temperature(float value) {
  _has_bits_[0] |= 0x00000002u;
  motor_temperature_ = value;
}
inline void MotorStatus::set_motor_temperature(float value) {
  _internal_set_motor_temperature(value);
  // @@protoc_insertion_point(field_set:MotorStatus.motor_temperature)
}

// optional float voltage = 13;
inline bool MotorStatus::_internal_has_voltage() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotorStatus::has_voltage() const {
  return _internal_has_voltage();
}
inline void MotorStatus::clear_voltage() {
  voltage_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotorStatus::_internal_voltage() const {
  return voltage_;
}
inline float MotorStatus::voltage() const {
  // @@protoc_insertion_point(field_get:MotorStatus.voltage)
  return _internal_voltage();
}
inline void MotorStatus::_internal_set_voltage(float value) {
  _has_bits_[0] |= 0x00000004u;
  voltage_ = value;
}
inline void MotorStatus::set_voltage(float value) {
  _internal_set_voltage(value);
  // @@protoc_insertion_point(field_set:MotorStatus.voltage)
}

// -------------------------------------------------------------------

// SecondaryDeviceStatus

// uint32 device_id = 1;
inline void SecondaryDeviceStatus::clear_device_id() {
  device_id_ = 0u;
}
inline uint32_t SecondaryDeviceStatus::_internal_device_id() const {
  return device_id_;
}
inline uint32_t SecondaryDeviceStatus::device_id() const {
  // @@protoc_insertion_point(field_get:SecondaryDeviceStatus.device_id)
  return _internal_device_id();
}
inline void SecondaryDeviceStatus::_internal_set_device_id(uint32_t value) {
  
  device_id_ = value;
}
inline void SecondaryDeviceStatus::set_device_id(uint32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:SecondaryDeviceStatus.device_id)
}

// .SecondaryDeviceType device_type = 2;
inline void SecondaryDeviceStatus::clear_device_type() {
  device_type_ = 0;
}
inline ::SecondaryDeviceType SecondaryDeviceStatus::_internal_device_type() const {
  return static_cast< ::SecondaryDeviceType >(device_type_);
}
inline ::SecondaryDeviceType SecondaryDeviceStatus::device_type() const {
  // @@protoc_insertion_point(field_get:SecondaryDeviceStatus.device_type)
  return _internal_device_type();
}
inline void SecondaryDeviceStatus::_internal_set_device_type(::SecondaryDeviceType value) {
  
  device_type_ = value;
}
inline void SecondaryDeviceStatus::set_device_type(::SecondaryDeviceType value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:SecondaryDeviceStatus.device_type)
}

// .ImuData imu_data = 11;
inline bool SecondaryDeviceStatus::_internal_has_imu_data() const {
  return status_case() == kImuData;
}
inline bool SecondaryDeviceStatus::has_imu_data() const {
  return _internal_has_imu_data();
}
inline void SecondaryDeviceStatus::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline void SecondaryDeviceStatus::clear_imu_data() {
  if (_internal_has_imu_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete status_.imu_data_;
    }
    clear_has_status();
  }
}
inline ::ImuData* SecondaryDeviceStatus::release_imu_data() {
  // @@protoc_insertion_point(field_release:SecondaryDeviceStatus.imu_data)
  if (_internal_has_imu_data()) {
    clear_has_status();
      ::ImuData* temp = status_.imu_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    status_.imu_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ImuData& SecondaryDeviceStatus::_internal_imu_data() const {
  return _internal_has_imu_data()
      ? *status_.imu_data_
      : reinterpret_cast< ::ImuData&>(::_ImuData_default_instance_);
}
inline const ::ImuData& SecondaryDeviceStatus::imu_data() const {
  // @@protoc_insertion_point(field_get:SecondaryDeviceStatus.imu_data)
  return _internal_imu_data();
}
inline ::ImuData* SecondaryDeviceStatus::unsafe_arena_release_imu_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SecondaryDeviceStatus.imu_data)
  if (_internal_has_imu_data()) {
    clear_has_status();
    ::ImuData* temp = status_.imu_data_;
    status_.imu_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SecondaryDeviceStatus::unsafe_arena_set_allocated_imu_data(::ImuData* imu_data) {
  clear_status();
  if (imu_data) {
    set_has_imu_data();
    status_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SecondaryDeviceStatus.imu_data)
}
inline ::ImuData* SecondaryDeviceStatus::_internal_mutable_imu_data() {
  if (!_internal_has_imu_data()) {
    clear_status();
    set_has_imu_data();
    status_.imu_data_ = CreateMaybeMessage< ::ImuData >(GetArenaForAllocation());
  }
  return status_.imu_data_;
}
inline ::ImuData* SecondaryDeviceStatus::mutable_imu_data() {
  ::ImuData* _msg = _internal_mutable_imu_data();
  // @@protoc_insertion_point(field_mutable:SecondaryDeviceStatus.imu_data)
  return _msg;
}

// .HandStatus hand_status = 12;
inline bool SecondaryDeviceStatus::_internal_has_hand_status() const {
  return status_case() == kHandStatus;
}
inline bool SecondaryDeviceStatus::has_hand_status() const {
  return _internal_has_hand_status();
}
inline void SecondaryDeviceStatus::set_has_hand_status() {
  _oneof_case_[0] = kHandStatus;
}
inline void SecondaryDeviceStatus::clear_hand_status() {
  if (_internal_has_hand_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete status_.hand_status_;
    }
    clear_has_status();
  }
}
inline ::HandStatus* SecondaryDeviceStatus::release_hand_status() {
  // @@protoc_insertion_point(field_release:SecondaryDeviceStatus.hand_status)
  if (_internal_has_hand_status()) {
    clear_has_status();
      ::HandStatus* temp = status_.hand_status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    status_.hand_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HandStatus& SecondaryDeviceStatus::_internal_hand_status() const {
  return _internal_has_hand_status()
      ? *status_.hand_status_
      : reinterpret_cast< ::HandStatus&>(::_HandStatus_default_instance_);
}
inline const ::HandStatus& SecondaryDeviceStatus::hand_status() const {
  // @@protoc_insertion_point(field_get:SecondaryDeviceStatus.hand_status)
  return _internal_hand_status();
}
inline ::HandStatus* SecondaryDeviceStatus::unsafe_arena_release_hand_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SecondaryDeviceStatus.hand_status)
  if (_internal_has_hand_status()) {
    clear_has_status();
    ::HandStatus* temp = status_.hand_status_;
    status_.hand_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SecondaryDeviceStatus::unsafe_arena_set_allocated_hand_status(::HandStatus* hand_status) {
  clear_status();
  if (hand_status) {
    set_has_hand_status();
    status_.hand_status_ = hand_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SecondaryDeviceStatus.hand_status)
}
inline ::HandStatus* SecondaryDeviceStatus::_internal_mutable_hand_status() {
  if (!_internal_has_hand_status()) {
    clear_status();
    set_has_hand_status();
    status_.hand_status_ = CreateMaybeMessage< ::HandStatus >(GetArenaForAllocation());
  }
  return status_.hand_status_;
}
inline ::HandStatus* SecondaryDeviceStatus::mutable_hand_status() {
  ::HandStatus* _msg = _internal_mutable_hand_status();
  // @@protoc_insertion_point(field_mutable:SecondaryDeviceStatus.hand_status)
  return _msg;
}

// .GamepadRead gamepad_read = 13;
inline bool SecondaryDeviceStatus::_internal_has_gamepad_read() const {
  return status_case() == kGamepadRead;
}
inline bool SecondaryDeviceStatus::has_gamepad_read() const {
  return _internal_has_gamepad_read();
}
inline void SecondaryDeviceStatus::set_has_gamepad_read() {
  _oneof_case_[0] = kGamepadRead;
}
inline void SecondaryDeviceStatus::clear_gamepad_read() {
  if (_internal_has_gamepad_read()) {
    if (GetArenaForAllocation() == nullptr) {
      delete status_.gamepad_read_;
    }
    clear_has_status();
  }
}
inline ::GamepadRead* SecondaryDeviceStatus::release_gamepad_read() {
  // @@protoc_insertion_point(field_release:SecondaryDeviceStatus.gamepad_read)
  if (_internal_has_gamepad_read()) {
    clear_has_status();
      ::GamepadRead* temp = status_.gamepad_read_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    status_.gamepad_read_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GamepadRead& SecondaryDeviceStatus::_internal_gamepad_read() const {
  return _internal_has_gamepad_read()
      ? *status_.gamepad_read_
      : reinterpret_cast< ::GamepadRead&>(::_GamepadRead_default_instance_);
}
inline const ::GamepadRead& SecondaryDeviceStatus::gamepad_read() const {
  // @@protoc_insertion_point(field_get:SecondaryDeviceStatus.gamepad_read)
  return _internal_gamepad_read();
}
inline ::GamepadRead* SecondaryDeviceStatus::unsafe_arena_release_gamepad_read() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SecondaryDeviceStatus.gamepad_read)
  if (_internal_has_gamepad_read()) {
    clear_has_status();
    ::GamepadRead* temp = status_.gamepad_read_;
    status_.gamepad_read_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SecondaryDeviceStatus::unsafe_arena_set_allocated_gamepad_read(::GamepadRead* gamepad_read) {
  clear_status();
  if (gamepad_read) {
    set_has_gamepad_read();
    status_.gamepad_read_ = gamepad_read;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SecondaryDeviceStatus.gamepad_read)
}
inline ::GamepadRead* SecondaryDeviceStatus::_internal_mutable_gamepad_read() {
  if (!_internal_has_gamepad_read()) {
    clear_status();
    set_has_gamepad_read();
    status_.gamepad_read_ = CreateMaybeMessage< ::GamepadRead >(GetArenaForAllocation());
  }
  return status_.gamepad_read_;
}
inline ::GamepadRead* SecondaryDeviceStatus::mutable_gamepad_read() {
  ::GamepadRead* _msg = _internal_mutable_gamepad_read();
  // @@protoc_insertion_point(field_mutable:SecondaryDeviceStatus.gamepad_read)
  return _msg;
}

inline bool SecondaryDeviceStatus::has_status() const {
  return status_case() != STATUS_NOT_SET;
}
inline void SecondaryDeviceStatus::clear_has_status() {
  _oneof_case_[0] = STATUS_NOT_SET;
}
inline SecondaryDeviceStatus::StatusCase SecondaryDeviceStatus::status_case() const {
  return SecondaryDeviceStatus::StatusCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SecondaryDeviceCommand

// uint32 device_id = 1;
inline void SecondaryDeviceCommand::clear_device_id() {
  device_id_ = 0u;
}
inline uint32_t SecondaryDeviceCommand::_internal_device_id() const {
  return device_id_;
}
inline uint32_t SecondaryDeviceCommand::device_id() const {
  // @@protoc_insertion_point(field_get:SecondaryDeviceCommand.device_id)
  return _internal_device_id();
}
inline void SecondaryDeviceCommand::_internal_set_device_id(uint32_t value) {
  
  device_id_ = value;
}
inline void SecondaryDeviceCommand::set_device_id(uint32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:SecondaryDeviceCommand.device_id)
}

// .HandCommand hand_command = 12;
inline bool SecondaryDeviceCommand::_internal_has_hand_command() const {
  return command_case() == kHandCommand;
}
inline bool SecondaryDeviceCommand::has_hand_command() const {
  return _internal_has_hand_command();
}
inline void SecondaryDeviceCommand::set_has_hand_command() {
  _oneof_case_[0] = kHandCommand;
}
inline void SecondaryDeviceCommand::clear_hand_command() {
  if (_internal_has_hand_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete command_.hand_command_;
    }
    clear_has_command();
  }
}
inline ::HandCommand* SecondaryDeviceCommand::release_hand_command() {
  // @@protoc_insertion_point(field_release:SecondaryDeviceCommand.hand_command)
  if (_internal_has_hand_command()) {
    clear_has_command();
      ::HandCommand* temp = command_.hand_command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.hand_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HandCommand& SecondaryDeviceCommand::_internal_hand_command() const {
  return _internal_has_hand_command()
      ? *command_.hand_command_
      : reinterpret_cast< ::HandCommand&>(::_HandCommand_default_instance_);
}
inline const ::HandCommand& SecondaryDeviceCommand::hand_command() const {
  // @@protoc_insertion_point(field_get:SecondaryDeviceCommand.hand_command)
  return _internal_hand_command();
}
inline ::HandCommand* SecondaryDeviceCommand::unsafe_arena_release_hand_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:SecondaryDeviceCommand.hand_command)
  if (_internal_has_hand_command()) {
    clear_has_command();
    ::HandCommand* temp = command_.hand_command_;
    command_.hand_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SecondaryDeviceCommand::unsafe_arena_set_allocated_hand_command(::HandCommand* hand_command) {
  clear_command();
  if (hand_command) {
    set_has_hand_command();
    command_.hand_command_ = hand_command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SecondaryDeviceCommand.hand_command)
}
inline ::HandCommand* SecondaryDeviceCommand::_internal_mutable_hand_command() {
  if (!_internal_has_hand_command()) {
    clear_command();
    set_has_hand_command();
    command_.hand_command_ = CreateMaybeMessage< ::HandCommand >(GetArenaForAllocation());
  }
  return command_.hand_command_;
}
inline ::HandCommand* SecondaryDeviceCommand::mutable_hand_command() {
  ::HandCommand* _msg = _internal_mutable_hand_command();
  // @@protoc_insertion_point(field_mutable:SecondaryDeviceCommand.hand_command)
  return _msg;
}

inline bool SecondaryDeviceCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void SecondaryDeviceCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline SecondaryDeviceCommand::CommandCase SecondaryDeviceCommand::command_case() const {
  return SecondaryDeviceCommand::CommandCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RobotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotType>() {
  return ::RobotType_descriptor();
}
template <> struct is_proto_enum< ::SecondaryDeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecondaryDeviceType>() {
  return ::SecondaryDeviceType_descriptor();
}
template <> struct is_proto_enum< ::BaseState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BaseState>() {
  return ::BaseState_descriptor();
}
template <> struct is_proto_enum< ::LiftState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LiftState>() {
  return ::LiftState_descriptor();
}
template <> struct is_proto_enum< ::ReportFrequency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ReportFrequency>() {
  return ::ReportFrequency_descriptor();
}
template <> struct is_proto_enum< ::ParkingStopCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ParkingStopCategory>() {
  return ::ParkingStopCategory_descriptor();
}
template <> struct is_proto_enum< ::WarningCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WarningCategory>() {
  return ::WarningCategory_descriptor();
}
template <> struct is_proto_enum< ::MotorError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MotorError>() {
  return ::MotorError_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_public_5fapi_5ftypes_2eproto

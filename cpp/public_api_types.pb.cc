// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: public_api_types.proto

#include "public_api_types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr BaseEstimatedOdometry::BaseEstimatedOdometry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : speed_x_(0)
  , speed_y_(0)
  , pos_x_(0)
  , pos_y_(0)
  , pos_z_(0)
  , speed_z_(0){}
struct BaseEstimatedOdometryDefaultTypeInternal {
  constexpr BaseEstimatedOdometryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BaseEstimatedOdometryDefaultTypeInternal() {}
  union {
    BaseEstimatedOdometry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BaseEstimatedOdometryDefaultTypeInternal _BaseEstimatedOdometry_default_instance_;
constexpr BaseStatus::BaseStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motor_status_()
  , parking_stop_detail_(nullptr)
  , estimated_odometry_(nullptr)
  , state_(0)

  , battery_voltage_(0)
  , battery_thousandth_(0u)
  , session_holder_(0u)
  , api_control_initialized_(false)
  , battery_charging_(false)
  , warning_(0)
{}
struct BaseStatusDefaultTypeInternal {
  constexpr BaseStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BaseStatusDefaultTypeInternal() {}
  union {
    BaseStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BaseStatusDefaultTypeInternal _BaseStatus_default_instance_;
constexpr XyzSpeed::XyzSpeed(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : speed_x_(0)
  , speed_y_(0)
  , speed_z_(0){}
struct XyzSpeedDefaultTypeInternal {
  constexpr XyzSpeedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~XyzSpeedDefaultTypeInternal() {}
  union {
    XyzSpeed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT XyzSpeedDefaultTypeInternal _XyzSpeed_default_instance_;
constexpr SimpleBaseMoveCommand::SimpleBaseMoveCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct SimpleBaseMoveCommandDefaultTypeInternal {
  constexpr SimpleBaseMoveCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimpleBaseMoveCommandDefaultTypeInternal() {}
  union {
    SimpleBaseMoveCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimpleBaseMoveCommandDefaultTypeInternal _SimpleBaseMoveCommand_default_instance_;
constexpr BaseCommand::BaseCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct BaseCommandDefaultTypeInternal {
  constexpr BaseCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BaseCommandDefaultTypeInternal() {}
  union {
    BaseCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BaseCommandDefaultTypeInternal _BaseCommand_default_instance_;
constexpr RotateLiftStatus::RotateLiftStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motor_status_()
  , max_pos_()
  , _max_pos_cached_byte_size_(0)
  , min_pos_()
  , _min_pos_cached_byte_size_(0)
  , parking_stop_detail_(nullptr)
  , calibrated_(false)
  , state_(0)
{}
struct RotateLiftStatusDefaultTypeInternal {
  constexpr RotateLiftStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RotateLiftStatusDefaultTypeInternal() {}
  union {
    RotateLiftStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RotateLiftStatusDefaultTypeInternal _RotateLiftStatus_default_instance_;
constexpr RotateLiftRuntimeConfig::RotateLiftRuntimeConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pos_mode_max_speed_(){}
struct RotateLiftRuntimeConfigDefaultTypeInternal {
  constexpr RotateLiftRuntimeConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RotateLiftRuntimeConfigDefaultTypeInternal() {}
  union {
    RotateLiftRuntimeConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RotateLiftRuntimeConfigDefaultTypeInternal _RotateLiftRuntimeConfig_default_instance_;
constexpr RotateLiftCommand::RotateLiftCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct RotateLiftCommandDefaultTypeInternal {
  constexpr RotateLiftCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RotateLiftCommandDefaultTypeInternal() {}
  union {
    RotateLiftCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RotateLiftCommandDefaultTypeInternal _RotateLiftCommand_default_instance_;
constexpr LinearLiftStatus::LinearLiftStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parking_stop_detail_(nullptr)
  , max_pos_(int64_t{0})
  , state_(0)

  , pulse_per_rotation_(0u)
  , current_pos_(int64_t{0})
  , max_speed_(0u)
  , calibrated_(false)
  , custom_button_pressed_(false)
  , speed_(0u){}
struct LinearLiftStatusDefaultTypeInternal {
  constexpr LinearLiftStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LinearLiftStatusDefaultTypeInternal() {}
  union {
    LinearLiftStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LinearLiftStatusDefaultTypeInternal _LinearLiftStatus_default_instance_;
constexpr LinearLiftCommand::LinearLiftCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct LinearLiftCommandDefaultTypeInternal {
  constexpr LinearLiftCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LinearLiftCommandDefaultTypeInternal() {}
  union {
    LinearLiftCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LinearLiftCommandDefaultTypeInternal _LinearLiftCommand_default_instance_;
constexpr ArmStatus::ArmStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motor_status_()
  , parking_stop_detail_(nullptr)
  , api_control_initialized_(false)
  , calibrated_(false)
  , session_holder_(0u){}
struct ArmStatusDefaultTypeInternal {
  constexpr ArmStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmStatusDefaultTypeInternal() {}
  union {
    ArmStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmStatusDefaultTypeInternal _ArmStatus_default_instance_;
constexpr HandStatus::HandStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motor_status_(){}
struct HandStatusDefaultTypeInternal {
  constexpr HandStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HandStatusDefaultTypeInternal() {}
  union {
    HandStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HandStatusDefaultTypeInternal _HandStatus_default_instance_;
constexpr HandCommand::HandCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motor_targets_(nullptr){}
struct HandCommandDefaultTypeInternal {
  constexpr HandCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HandCommandDefaultTypeInternal() {}
  union {
    HandCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HandCommandDefaultTypeInternal _HandCommand_default_instance_;
constexpr ArmApiFreeDragCommand::ArmApiFreeDragCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ArmApiFreeDragCommandDefaultTypeInternal {
  constexpr ArmApiFreeDragCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmApiFreeDragCommandDefaultTypeInternal() {}
  union {
    ArmApiFreeDragCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmApiFreeDragCommandDefaultTypeInternal _ArmApiFreeDragCommand_default_instance_;
constexpr ArmApiZeroCurrentCommand::ArmApiZeroCurrentCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ArmApiZeroCurrentCommandDefaultTypeInternal {
  constexpr ArmApiZeroCurrentCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmApiZeroCurrentCommandDefaultTypeInternal() {}
  union {
    ArmApiZeroCurrentCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmApiZeroCurrentCommandDefaultTypeInternal _ArmApiZeroCurrentCommand_default_instance_;
constexpr ArmApiControlCommand::ArmApiControlCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ArmApiControlCommandDefaultTypeInternal {
  constexpr ArmApiControlCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmApiControlCommandDefaultTypeInternal() {}
  union {
    ArmApiControlCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmApiControlCommandDefaultTypeInternal _ArmApiControlCommand_default_instance_;
constexpr ArmSharedCommand::ArmSharedCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ArmSharedCommandDefaultTypeInternal {
  constexpr ArmSharedCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmSharedCommandDefaultTypeInternal() {}
  union {
    ArmSharedCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmSharedCommandDefaultTypeInternal _ArmSharedCommand_default_instance_;
constexpr ArmExclusiveCommand::ArmExclusiveCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ArmExclusiveCommandDefaultTypeInternal {
  constexpr ArmExclusiveCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmExclusiveCommandDefaultTypeInternal() {}
  union {
    ArmExclusiveCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmExclusiveCommandDefaultTypeInternal _ArmExclusiveCommand_default_instance_;
constexpr ArmCommand::ArmCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct ArmCommandDefaultTypeInternal {
  constexpr ArmCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ArmCommandDefaultTypeInternal() {}
  union {
    ArmCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ArmCommandDefaultTypeInternal _ArmCommand_default_instance_;
constexpr GamepadRead::GamepadRead(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : left_stick_x_(0)
  , left_stick_y_(0)
  , right_stick_x_(0)
  , right_stick_y_(0)
  , left_trigger_(0)
  , left_bumper_(false)
  , right_bumper_(false)
  , a_button_(false)
  , b_button_(false)
  , right_trigger_(0)
  , x_button_(false)
  , y_button_(false)
  , select_button_(false)
  , start_button_(false)
  , left_stick_button_(false)
  , right_stick_button_(false)
  , dpad_up_(false)
  , dpad_down_(false)
  , dpad_left_(false)
  , dpad_right_(false){}
struct GamepadReadDefaultTypeInternal {
  constexpr GamepadReadDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GamepadReadDefaultTypeInternal() {}
  union {
    GamepadRead _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GamepadReadDefaultTypeInternal _GamepadRead_default_instance_;
constexpr EnableKcp::EnableKcp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : kcp_config_(nullptr)
  , client_peer_port_(0u){}
struct EnableKcpDefaultTypeInternal {
  constexpr EnableKcpDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EnableKcpDefaultTypeInternal() {}
  union {
    EnableKcp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EnableKcpDefaultTypeInternal _EnableKcp_default_instance_;
constexpr KcpServerStatus::KcpServerStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : kcp_config_(nullptr)
  , server_port_(0u){}
struct KcpServerStatusDefaultTypeInternal {
  constexpr KcpServerStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KcpServerStatusDefaultTypeInternal() {}
  union {
    KcpServerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KcpServerStatusDefaultTypeInternal _KcpServerStatus_default_instance_;
constexpr KcpConfig::KcpConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : window_size_snd_wnd_(0)
  , window_size_rcv_wnd_(0)
  , interval_ms_(0)
  , no_delay_(false)
  , nc_(false)
  , resend_(0){}
struct KcpConfigDefaultTypeInternal {
  constexpr KcpConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KcpConfigDefaultTypeInternal() {}
  union {
    KcpConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KcpConfigDefaultTypeInternal _KcpConfig_default_instance_;
constexpr ImuAcceleration::ImuAcceleration(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ax_(0)
  , ay_(0)
  , az_(0){}
struct ImuAccelerationDefaultTypeInternal {
  constexpr ImuAccelerationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImuAccelerationDefaultTypeInternal() {}
  union {
    ImuAcceleration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImuAccelerationDefaultTypeInternal _ImuAcceleration_default_instance_;
constexpr ImuAngularVelocity::ImuAngularVelocity(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : wx_(0)
  , wy_(0)
  , wz_(0){}
struct ImuAngularVelocityDefaultTypeInternal {
  constexpr ImuAngularVelocityDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImuAngularVelocityDefaultTypeInternal() {}
  union {
    ImuAngularVelocity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImuAngularVelocityDefaultTypeInternal _ImuAngularVelocity_default_instance_;
constexpr ImuQuaternion::ImuQuaternion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : qx_(0)
  , qy_(0)
  , qz_(0)
  , qw_(0){}
struct ImuQuaternionDefaultTypeInternal {
  constexpr ImuQuaternionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImuQuaternionDefaultTypeInternal() {}
  union {
    ImuQuaternion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImuQuaternionDefaultTypeInternal _ImuQuaternion_default_instance_;
constexpr ImuData::ImuData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acceleration_(nullptr)
  , angular_velocity_(nullptr)
  , quaternion_(nullptr){}
struct ImuDataDefaultTypeInternal {
  constexpr ImuDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ImuDataDefaultTypeInternal() {}
  union {
    ImuData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImuDataDefaultTypeInternal _ImuData_default_instance_;
constexpr ParkingStopDetail::ParkingStopDetail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : reason_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , category_(0)

  , is_remotely_clearable_(false){}
struct ParkingStopDetailDefaultTypeInternal {
  constexpr ParkingStopDetailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ParkingStopDetailDefaultTypeInternal() {}
  union {
    ParkingStopDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ParkingStopDetailDefaultTypeInternal _ParkingStopDetail_default_instance_;
constexpr SingleMotorTarget::SingleMotorTarget(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct SingleMotorTargetDefaultTypeInternal {
  constexpr SingleMotorTargetDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SingleMotorTargetDefaultTypeInternal() {}
  union {
    SingleMotorTarget _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SingleMotorTargetDefaultTypeInternal _SingleMotorTarget_default_instance_;
constexpr MitMotorTarget::MitMotorTarget(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : torque_(0)
  , speed_(0)
  , position_(0)
  , kp_(0)
  , kd_(0){}
struct MitMotorTargetDefaultTypeInternal {
  constexpr MitMotorTargetDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MitMotorTargetDefaultTypeInternal() {}
  union {
    MitMotorTarget _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MitMotorTargetDefaultTypeInternal _MitMotorTarget_default_instance_;
constexpr MotorTargets::MotorTargets(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : targets_(){}
struct MotorTargetsDefaultTypeInternal {
  constexpr MotorTargetsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotorTargetsDefaultTypeInternal() {}
  union {
    MotorTargets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotorTargetsDefaultTypeInternal _MotorTargets_default_instance_;
constexpr MotorStatus::MotorStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_()
  , _error_cached_byte_size_(0)
  , current_target_(nullptr)
  , torque_(0)
  , speed_(0)
  , position_(int64_t{0})
  , wheel_radius_(0)
  , pulse_per_rotation_(0u)
  , driver_temperature_(0)
  , motor_temperature_(0)
  , voltage_(0){}
struct MotorStatusDefaultTypeInternal {
  constexpr MotorStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotorStatusDefaultTypeInternal() {}
  union {
    MotorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotorStatusDefaultTypeInternal _MotorStatus_default_instance_;
constexpr SecondaryDeviceStatus::SecondaryDeviceStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_id_(0u)
  , device_type_(0)

  , _oneof_case_{}{}
struct SecondaryDeviceStatusDefaultTypeInternal {
  constexpr SecondaryDeviceStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SecondaryDeviceStatusDefaultTypeInternal() {}
  union {
    SecondaryDeviceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SecondaryDeviceStatusDefaultTypeInternal _SecondaryDeviceStatus_default_instance_;
constexpr SecondaryDeviceCommand::SecondaryDeviceCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_id_(0u)
  , _oneof_case_{}{}
struct SecondaryDeviceCommandDefaultTypeInternal {
  constexpr SecondaryDeviceCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SecondaryDeviceCommandDefaultTypeInternal() {}
  union {
    SecondaryDeviceCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SecondaryDeviceCommandDefaultTypeInternal _SecondaryDeviceCommand_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_public_5fapi_5ftypes_2eproto[34];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[8];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_public_5fapi_5ftypes_2eproto = nullptr;

const uint32_t TableStruct_public_5fapi_5ftypes_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::BaseEstimatedOdometry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::BaseEstimatedOdometry, speed_x_),
  PROTOBUF_FIELD_OFFSET(::BaseEstimatedOdometry, speed_y_),
  PROTOBUF_FIELD_OFFSET(::BaseEstimatedOdometry, speed_z_),
  PROTOBUF_FIELD_OFFSET(::BaseEstimatedOdometry, pos_x_),
  PROTOBUF_FIELD_OFFSET(::BaseEstimatedOdometry, pos_y_),
  PROTOBUF_FIELD_OFFSET(::BaseEstimatedOdometry, pos_z_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::BaseStatus, state_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, api_control_initialized_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, battery_voltage_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, battery_thousandth_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, motor_status_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, session_holder_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, battery_charging_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, parking_stop_detail_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, warning_),
  PROTOBUF_FIELD_OFFSET(::BaseStatus, estimated_odometry_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  2,
  0,
  3,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::XyzSpeed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::XyzSpeed, speed_x_),
  PROTOBUF_FIELD_OFFSET(::XyzSpeed, speed_y_),
  PROTOBUF_FIELD_OFFSET(::XyzSpeed, speed_z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SimpleBaseMoveCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SimpleBaseMoveCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SimpleBaseMoveCommand, command_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::BaseCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::BaseCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::BaseCommand, command_),
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, calibrated_),
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, state_),
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, motor_status_),
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, max_pos_),
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, min_pos_),
  PROTOBUF_FIELD_OFFSET(::RotateLiftStatus, parking_stop_detail_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RotateLiftRuntimeConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RotateLiftRuntimeConfig, pos_mode_max_speed_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RotateLiftCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::RotateLiftCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::RotateLiftCommand, command_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, calibrated_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, state_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, max_pos_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, current_pos_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, pulse_per_rotation_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, max_speed_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, speed_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, parking_stop_detail_),
  PROTOBUF_FIELD_OFFSET(::LinearLiftStatus, custom_button_pressed_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LinearLiftCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::LinearLiftCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::LinearLiftCommand, command_),
  PROTOBUF_FIELD_OFFSET(::ArmStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ArmStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ArmStatus, api_control_initialized_),
  PROTOBUF_FIELD_OFFSET(::ArmStatus, calibrated_),
  PROTOBUF_FIELD_OFFSET(::ArmStatus, motor_status_),
  PROTOBUF_FIELD_OFFSET(::ArmStatus, session_holder_),
  PROTOBUF_FIELD_OFFSET(::ArmStatus, parking_stop_detail_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HandStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HandStatus, motor_status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HandCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HandCommand, motor_targets_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ArmApiFreeDragCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ArmApiZeroCurrentCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ArmApiControlCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::ArmApiControlCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::ArmApiControlCommand, command_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ArmSharedCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::ArmSharedCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::ArmSharedCommand, command_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ArmExclusiveCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::ArmExclusiveCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::ArmExclusiveCommand, exclusive_command_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ArmCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::ArmCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::ArmCommand, command_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::GamepadRead, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::GamepadRead, left_stick_x_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, left_stick_y_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, right_stick_x_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, right_stick_y_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, left_bumper_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, right_bumper_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, left_trigger_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, right_trigger_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, a_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, b_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, x_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, y_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, select_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, start_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, left_stick_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, right_stick_button_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, dpad_up_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, dpad_down_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, dpad_left_),
  PROTOBUF_FIELD_OFFSET(::GamepadRead, dpad_right_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::EnableKcp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::EnableKcp, client_peer_port_),
  PROTOBUF_FIELD_OFFSET(::EnableKcp, kcp_config_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::KcpServerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::KcpServerStatus, server_port_),
  PROTOBUF_FIELD_OFFSET(::KcpServerStatus, kcp_config_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::KcpConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::KcpConfig, window_size_snd_wnd_),
  PROTOBUF_FIELD_OFFSET(::KcpConfig, window_size_rcv_wnd_),
  PROTOBUF_FIELD_OFFSET(::KcpConfig, interval_ms_),
  PROTOBUF_FIELD_OFFSET(::KcpConfig, no_delay_),
  PROTOBUF_FIELD_OFFSET(::KcpConfig, nc_),
  PROTOBUF_FIELD_OFFSET(::KcpConfig, resend_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ImuAcceleration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ImuAcceleration, ax_),
  PROTOBUF_FIELD_OFFSET(::ImuAcceleration, ay_),
  PROTOBUF_FIELD_OFFSET(::ImuAcceleration, az_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ImuAngularVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ImuAngularVelocity, wx_),
  PROTOBUF_FIELD_OFFSET(::ImuAngularVelocity, wy_),
  PROTOBUF_FIELD_OFFSET(::ImuAngularVelocity, wz_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ImuQuaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ImuQuaternion, qx_),
  PROTOBUF_FIELD_OFFSET(::ImuQuaternion, qy_),
  PROTOBUF_FIELD_OFFSET(::ImuQuaternion, qz_),
  PROTOBUF_FIELD_OFFSET(::ImuQuaternion, qw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ImuData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ImuData, acceleration_),
  PROTOBUF_FIELD_OFFSET(::ImuData, angular_velocity_),
  PROTOBUF_FIELD_OFFSET(::ImuData, quaternion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ParkingStopDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ParkingStopDetail, reason_),
  PROTOBUF_FIELD_OFFSET(::ParkingStopDetail, category_),
  PROTOBUF_FIELD_OFFSET(::ParkingStopDetail, is_remotely_clearable_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SingleMotorTarget, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SingleMotorTarget, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SingleMotorTarget, target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MitMotorTarget, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MitMotorTarget, torque_),
  PROTOBUF_FIELD_OFFSET(::MitMotorTarget, speed_),
  PROTOBUF_FIELD_OFFSET(::MitMotorTarget, position_),
  PROTOBUF_FIELD_OFFSET(::MitMotorTarget, kp_),
  PROTOBUF_FIELD_OFFSET(::MitMotorTarget, kd_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MotorTargets, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MotorTargets, targets_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MotorStatus, torque_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, speed_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, position_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, pulse_per_rotation_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, wheel_radius_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, error_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, current_target_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, driver_temperature_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, motor_temperature_),
  PROTOBUF_FIELD_OFFSET(::MotorStatus, voltage_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceStatus, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceStatus, device_id_),
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceStatus, device_type_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceStatus, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceCommand, device_id_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::SecondaryDeviceCommand, command_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::BaseEstimatedOdometry)},
  { 12, 28, -1, sizeof(::BaseStatus)},
  { 38, -1, -1, sizeof(::XyzSpeed)},
  { 47, -1, -1, sizeof(::SimpleBaseMoveCommand)},
  { 57, -1, -1, sizeof(::BaseCommand)},
  { 68, 80, -1, sizeof(::RotateLiftStatus)},
  { 86, -1, -1, sizeof(::RotateLiftRuntimeConfig)},
  { 93, -1, -1, sizeof(::RotateLiftCommand)},
  { 103, 118, -1, sizeof(::LinearLiftStatus)},
  { 127, -1, -1, sizeof(::LinearLiftCommand)},
  { 138, 149, -1, sizeof(::ArmStatus)},
  { 154, -1, -1, sizeof(::HandStatus)},
  { 161, -1, -1, sizeof(::HandCommand)},
  { 168, -1, -1, sizeof(::ArmApiFreeDragCommand)},
  { 174, -1, -1, sizeof(::ArmApiZeroCurrentCommand)},
  { 180, -1, -1, sizeof(::ArmApiControlCommand)},
  { 190, -1, -1, sizeof(::ArmSharedCommand)},
  { 199, -1, -1, sizeof(::ArmExclusiveCommand)},
  { 209, -1, -1, sizeof(::ArmCommand)},
  { 218, -1, -1, sizeof(::GamepadRead)},
  { 244, -1, -1, sizeof(::EnableKcp)},
  { 252, -1, -1, sizeof(::KcpServerStatus)},
  { 260, -1, -1, sizeof(::KcpConfig)},
  { 272, -1, -1, sizeof(::ImuAcceleration)},
  { 281, -1, -1, sizeof(::ImuAngularVelocity)},
  { 290, -1, -1, sizeof(::ImuQuaternion)},
  { 300, -1, -1, sizeof(::ImuData)},
  { 309, -1, -1, sizeof(::ParkingStopDetail)},
  { 318, -1, -1, sizeof(::SingleMotorTarget)},
  { 330, -1, -1, sizeof(::MitMotorTarget)},
  { 341, -1, -1, sizeof(::MotorTargets)},
  { 348, 364, -1, sizeof(::MotorStatus)},
  { 374, -1, -1, sizeof(::SecondaryDeviceStatus)},
  { 386, -1, -1, sizeof(::SecondaryDeviceCommand)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_BaseEstimatedOdometry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_BaseStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_XyzSpeed_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SimpleBaseMoveCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_BaseCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RotateLiftStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RotateLiftRuntimeConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_RotateLiftCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_LinearLiftStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_LinearLiftCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ArmStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_HandStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_HandCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ArmApiFreeDragCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ArmApiZeroCurrentCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ArmApiControlCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ArmSharedCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ArmExclusiveCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ArmCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_GamepadRead_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_EnableKcp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_KcpServerStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_KcpConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ImuAcceleration_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ImuAngularVelocity_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ImuQuaternion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ImuData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ParkingStopDetail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SingleMotorTarget_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MitMotorTarget_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MotorTargets_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MotorStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SecondaryDeviceStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SecondaryDeviceCommand_default_instance_),
};

const char descriptor_table_protodef_public_5fapi_5ftypes_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026public_api_types.proto\"w\n\025BaseEstimate"
  "dOdometry\022\017\n\007speed_x\030\001 \001(\002\022\017\n\007speed_y\030\002 "
  "\001(\002\022\017\n\007speed_z\030\003 \001(\002\022\r\n\005pos_x\030\004 \001(\001\022\r\n\005p"
  "os_y\030\005 \001(\001\022\r\n\005pos_z\030\006 \001(\001\"\277\003\n\nBaseStatus"
  "\022\031\n\005state\030\001 \001(\0162\n.BaseState\022\037\n\027api_contr"
  "ol_initialized\030\002 \001(\010\022\027\n\017battery_voltage\030"
  "\003 \001(\002\022\032\n\022battery_thousandth\030\004 \001(\r\022\"\n\014mot"
  "or_status\030\005 \003(\0132\014.MotorStatus\022\026\n\016session"
  "_holder\030\006 \001(\r\022\035\n\020battery_charging\030\n \001(\010H"
  "\000\210\001\001\0224\n\023parking_stop_detail\030\013 \001(\0132\022.Park"
  "ingStopDetailH\001\210\001\001\022&\n\007warning\030\014 \001(\0162\020.Wa"
  "rningCategoryH\002\210\001\001\0227\n\022estimated_odometry"
  "\030\r \001(\0132\026.BaseEstimatedOdometryH\003\210\001\001B\023\n\021_"
  "battery_chargingB\026\n\024_parking_stop_detail"
  "B\n\n\010_warningB\025\n\023_estimated_odometry\"=\n\010X"
  "yzSpeed\022\017\n\007speed_x\030\001 \001(\002\022\017\n\007speed_y\030\002 \001("
  "\002\022\017\n\007speed_z\030\003 \001(\002\"n\n\025SimpleBaseMoveComm"
  "and\022\036\n\txyz_speed\030\001 \001(\0132\t.XyzSpeedH\000\022\031\n\017z"
  "ero_resistance\030\002 \001(\010H\000\022\017\n\005brake\030\003 \001(\010H\000B"
  "\t\n\007command\"\267\001\n\013BaseCommand\022 \n\026api_contro"
  "l_initialize\030\001 \001(\010H\000\022\034\n\022clear_parking_st"
  "op\030\002 \001(\010H\000\022&\n\rmotor_targets\030\003 \001(\0132\r.Moto"
  "rTargetsH\000\0225\n\023simple_move_command\030\005 \001(\0132"
  "\026.SimpleBaseMoveCommandH\000B\t\n\007command\"\325\001\n"
  "\020RotateLiftStatus\022\022\n\ncalibrated\030\001 \001(\010\022\031\n"
  "\005state\030\002 \001(\0162\n.LiftState\022\"\n\014motor_status"
  "\030\003 \003(\0132\014.MotorStatus\022\017\n\007max_pos\030\004 \003(\005\022\017\n"
  "\007min_pos\030\005 \003(\005\0224\n\023parking_stop_detail\030\n "
  "\001(\0132\022.ParkingStopDetailH\000\210\001\001B\026\n\024_parking"
  "_stop_detail\"5\n\027RotateLiftRuntimeConfig\022"
  "\032\n\022pos_mode_max_speed\030\001 \003(\001\"\217\001\n\021RotateLi"
  "ftCommand\022\023\n\tcalibrate\030\001 \001(\010H\000\022&\n\rmotor_"
  "targets\030\002 \001(\0132\r.MotorTargetsH\000\0222\n\016runtim"
  "e_config\030\003 \001(\0132\030.RotateLiftRuntimeConfig"
  "H\000B\t\n\007command\"\261\002\n\020LinearLiftStatus\022\022\n\nca"
  "librated\030\001 \001(\010\022\031\n\005state\030\002 \001(\0162\n.LiftStat"
  "e\022\017\n\007max_pos\030\003 \001(\003\022\023\n\013current_pos\030\004 \001(\003\022"
  "\032\n\022pulse_per_rotation\030\005 \001(\r\022\021\n\tmax_speed"
  "\030\006 \001(\r\022\r\n\005speed\030\007 \001(\r\0224\n\023parking_stop_de"
  "tail\030\n \001(\0132\022.ParkingStopDetailH\000\210\001\001\022\"\n\025c"
  "ustom_button_pressed\030\013 \001(\010H\001\210\001\001B\026\n\024_park"
  "ing_stop_detailB\030\n\026_custom_button_presse"
  "d\"o\n\021LinearLiftCommand\022\023\n\tcalibrate\030\001 \001("
  "\010H\000\022\024\n\ntarget_pos\030\002 \001(\003H\000\022\017\n\005brake\030\003 \001(\010"
  "H\000\022\023\n\tset_speed\030\004 \001(\rH\000B\t\n\007command\"\320\001\n\tA"
  "rmStatus\022\037\n\027api_control_initialized\030\001 \001("
  "\010\022\022\n\ncalibrated\030\003 \001(\010\022\"\n\014motor_status\030\004 "
  "\003(\0132\014.MotorStatus\022\026\n\016session_holder\030\006 \001("
  "\r\0224\n\023parking_stop_detail\030\005 \001(\0132\022.Parking"
  "StopDetailH\000\210\001\001B\026\n\024_parking_stop_detailJ"
  "\004\010\002\020\003\"6\n\nHandStatus\022\"\n\014motor_status\030\002 \003("
  "\0132\014.MotorStatusJ\004\010\001\020\002\"3\n\013HandCommand\022$\n\r"
  "motor_targets\030\001 \001(\0132\r.MotorTargets\"\027\n\025Ar"
  "mApiFreeDragCommand\"\032\n\030ArmApiZeroCurrent"
  "Command\"\311\001\n\024ArmApiControlCommand\022&\n\rmoto"
  "r_targets\030\001 \001(\0132\r.MotorTargetsH\000\022;\n\031arm_"
  "api_free_drag_command\030\002 \001(\0132\026.ArmApiFree"
  "DragCommandH\000\022A\n\034arm_api_zero_current_co"
  "mmand\030\003 \001(\0132\031.ArmApiZeroCurrentCommandH\000"
  "B\t\n\007command\"m\n\020ArmSharedCommand\022\034\n\022clear"
  "_parking_stop\030\001 \001(\010H\000\0220\n\022enter_parking_s"
  "top\030\002 \001(\0132\022.ParkingStopDetailH\000B\t\n\007comma"
  "nd\"\255\001\n\023ArmExclusiveCommand\022 \n\026api_contro"
  "l_initialize\030\001 \001(\010H\000\0228\n\027arm_api_control_"
  "command\030\006 \001(\0132\025.ArmApiControlCommandH\000\022\023"
  "\n\tcalibrate\030\004 \001(\010H\000B\023\n\021exclusive_command"
  "J\004\010\002\020\003J\004\010\003\020\004J\004\010\005\020\006\"\177\n\nArmCommand\0225\n\025arm_"
  "exclusive_command\030\001 \001(\0132\024.ArmExclusiveCo"
  "mmandH\000\022/\n\022arm_shared_command\030\002 \001(\0132\021.Ar"
  "mSharedCommandH\000B\t\n\007command\"\266\003\n\013GamepadR"
  "ead\022\024\n\014left_stick_x\030\001 \001(\002\022\024\n\014left_stick_"
  "y\030\002 \001(\002\022\025\n\rright_stick_x\030\003 \001(\002\022\025\n\rright_"
  "stick_y\030\004 \001(\002\022\023\n\013left_bumper\030\005 \001(\010\022\024\n\014ri"
  "ght_bumper\030\006 \001(\010\022\024\n\014left_trigger\030\007 \001(\002\022\025"
  "\n\rright_trigger\030\010 \001(\002\022\020\n\010a_button\030\t \001(\010\022"
  "\020\n\010b_button\030\n \001(\010\022\020\n\010x_button\030\013 \001(\010\022\020\n\010y"
  "_button\030\014 \001(\010\022\025\n\rselect_button\030\r \001(\010\022\024\n\014"
  "start_button\030\016 \001(\010\022\031\n\021left_stick_button\030"
  "\017 \001(\010\022\032\n\022right_stick_button\030\020 \001(\010\022\017\n\007dpa"
  "d_up\030\021 \001(\010\022\021\n\tdpad_down\030\022 \001(\010\022\021\n\tdpad_le"
  "ft\030\023 \001(\010\022\022\n\ndpad_right\030\024 \001(\010\"E\n\tEnableKc"
  "p\022\030\n\020client_peer_port\030\001 \001(\r\022\036\n\nkcp_confi"
  "g\030\002 \001(\0132\n.KcpConfig\"F\n\017KcpServerStatus\022\023"
  "\n\013server_port\030\001 \001(\r\022\036\n\nkcp_config\030\002 \001(\0132"
  "\n.KcpConfig\"\210\001\n\tKcpConfig\022\033\n\023window_size"
  "_snd_wnd\030\001 \001(\005\022\033\n\023window_size_rcv_wnd\030\002 "
  "\001(\005\022\023\n\013interval_ms\030\003 \001(\005\022\020\n\010no_delay\030\004 \001"
  "(\010\022\n\n\002nc\030\005 \001(\010\022\016\n\006resend\030\006 \001(\005\"5\n\017ImuAcc"
  "eleration\022\n\n\002ax\030\001 \001(\002\022\n\n\002ay\030\002 \001(\002\022\n\n\002az\030"
  "\003 \001(\002\"8\n\022ImuAngularVelocity\022\n\n\002wx\030\001 \001(\002\022"
  "\n\n\002wy\030\002 \001(\002\022\n\n\002wz\030\003 \001(\002\"\?\n\rImuQuaternion"
  "\022\n\n\002qx\030\001 \001(\002\022\n\n\002qy\030\002 \001(\002\022\n\n\002qz\030\003 \001(\002\022\n\n\002"
  "qw\030\004 \001(\002\"\204\001\n\007ImuData\022&\n\014acceleration\030\001 \001"
  "(\0132\020.ImuAcceleration\022-\n\020angular_velocity"
  "\030\002 \001(\0132\023.ImuAngularVelocity\022\"\n\nquaternio"
  "n\030\003 \001(\0132\016.ImuQuaternion\"j\n\021ParkingStopDe"
  "tail\022\016\n\006reason\030\001 \001(\t\022&\n\010category\030\002 \001(\0162\024"
  ".ParkingStopCategory\022\035\n\025is_remotely_clea"
  "rable\030\003 \001(\010\"\214\001\n\021SingleMotorTarget\022\020\n\006tor"
  "que\030\001 \001(\001H\000\022\017\n\005speed\030\002 \001(\001H\000\022\022\n\010position"
  "\030\003 \001(\003H\000\022\017\n\005brake\030\004 \001(\010H\000\022%\n\nmit_target\030"
  "\005 \001(\0132\017.MitMotorTargetH\000B\010\n\006target\"Y\n\016Mi"
  "tMotorTarget\022\016\n\006torque\030\001 \001(\001\022\r\n\005speed\030\002 "
  "\001(\001\022\020\n\010position\030\003 \001(\001\022\n\n\002kp\030\004 \001(\001\022\n\n\002kd\030"
  "\005 \001(\001\"3\n\014MotorTargets\022#\n\007targets\030\001 \003(\0132\022"
  ".SingleMotorTarget\"\310\002\n\013MotorStatus\022\016\n\006to"
  "rque\030\002 \001(\001\022\r\n\005speed\030\003 \001(\001\022\020\n\010position\030\004 "
  "\001(\003\022\032\n\022pulse_per_rotation\030\005 \001(\r\022\024\n\014wheel"
  "_radius\030\006 \001(\001\022\032\n\005error\030\007 \003(\0162\013.MotorErro"
  "r\022*\n\016current_target\030\010 \001(\0132\022.SingleMotorT"
  "arget\022\037\n\022driver_temperature\030\013 \001(\002H\000\210\001\001\022\036"
  "\n\021motor_temperature\030\014 \001(\002H\001\210\001\001\022\024\n\007voltag"
  "e\030\r \001(\002H\002\210\001\001B\025\n\023_driver_temperatureB\024\n\022_"
  "motor_temperatureB\n\n\010_voltage\"\315\001\n\025Second"
  "aryDeviceStatus\022\021\n\tdevice_id\030\001 \001(\r\022)\n\013de"
  "vice_type\030\002 \001(\0162\024.SecondaryDeviceType\022\034\n"
  "\010imu_data\030\013 \001(\0132\010.ImuDataH\000\022\"\n\013hand_stat"
  "us\030\014 \001(\0132\013.HandStatusH\000\022$\n\014gamepad_read\030"
  "\r \001(\0132\014.GamepadReadH\000B\010\n\006statusJ\004\010\003\020\013\"b\n"
  "\026SecondaryDeviceCommand\022\021\n\tdevice_id\030\001 \001"
  "(\r\022$\n\014hand_command\030\014 \001(\0132\014.HandCommandH\000"
  "B\t\n\007commandJ\004\010\002\020\013*\256\003\n\tRobotType\022\r\n\tRtUnk"
  "nown\020\000\022\017\n\013RtTriggerA3\020\001\022\r\n\tRtMaverX4\020\002\022\026"
  "\n\022RtCustomPcwVehicle\020\004\022\r\n\tRtMaverL4\020\024\022\r\n"
  "\tRtMaverL2\020\025\022\027\n\023RtMark1DiffBBDriver\020\006\022\022\n"
  "\016RtArk2LrDriver\020\005\022\027\n\023RtMark1McnmBBDriver"
  "\020\007\022\024\n\020RtLotaLinearLift\020\010\022\017\n\013RtZeta3Lift\020"
  "\r\022\036\n\032RtArmSaber750d3Lr3DmDriver\020\t\022\036\n\032RtA"
  "rmSaber750d4Lr3DmDriver\020\n\022\036\n\032RtArmSaber7"
  "50h3Lr3DmDriver\020\013\022\036\n\032RtArmSaber750h4Lr3D"
  "mDriver\020\014\022\021\n\rRtArmSaberD6X\020\016\022\021\n\rRtArmSab"
  "erD7X\020\017\022\022\n\016RtArmArcherD6Y\020\020\022\025\n\021RtPureFor"
  "wardOnly\020d*W\n\023SecondaryDeviceType\022\016\n\nSdt"
  "Unknown\020\000\022\020\n\014SdtHandGp100\020\001\022\016\n\nSdtGamepa"
  "d\020\002\022\016\n\nSdtImuY200\020\003*\206\001\n\tBaseState\022\014\n\010BsP"
  "arked\020\000\022\025\n\021BsAlgrithmControl\020\001\022\032\n\026BsOver"
  "takeSpeedControl\020\002\022#\n\037BsOvertakeZeroResi"
  "stanceControl\020\003\022\023\n\017BsEmergencyStop\020\004*n\n\t"
  "LiftState\022\013\n\007LsBrake\020\000\022\021\n\rLsCalibrating\020"
  "\001\022\025\n\021LsAlgrithmControl\020\002\022\025\n\021LsOvertakeCo"
  "ntrol\020\003\022\023\n\017LsEmergencyStop\020\004*]\n\017ReportFr"
  "equency\022\014\n\010Rf1000Hz\020\000\022\013\n\007Rf500Hz\020\003\022\013\n\007Rf"
  "250Hz\020\004\022\013\n\007Rf100Hz\020\001\022\n\n\006Rf50Hz\020\002\022\t\n\005Rf1H"
  "z\020\005*\355\001\n\023ParkingStopCategory\022\032\n\026PscEmerge"
  "ncyStopButton\020\000\022\024\n\020PscMotorHasError\020\001\022\030\n"
  "\024PscBatteryProtection\020\002\022\027\n\023PscGamepadTri"
  "ggered\020\003\022!\n\035PscUnknownParkingStopCategor"
  "y\020\004\022\036\n\032PscAPICommunicationTimeout\020\005\022\033\n\027P"
  "scLimitSwitchTriggered\020\006\022\021\n\rPscBmsTimeou"
  "t\020\007*A\n\017WarningCategory\022\034\n\030WcUnknownWarni"
  "ngCategory\020\000\022\020\n\014WcBatteryLow\020\001*\255\001\n\nMotor"
  "Error\022\030\n\024MeCommunicationError\020\000\022\021\n\rMeOve"
  "rCurrent\020\001\022\021\n\rMeOverVoltage\020\002\022\022\n\016MeUnder"
  "Voltage\020\003\022\032\n\026MeMotorOverTemperature\020\004\022\033\n"
  "\027MeDriverOverTemperature\020\005\022\022\n\016MeGeneralE"
  "rror\020\006b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_public_5fapi_5ftypes_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_public_5fapi_5ftypes_2eproto = {
  false, false, 6214, descriptor_table_protodef_public_5fapi_5ftypes_2eproto, "public_api_types.proto", 
  &descriptor_table_public_5fapi_5ftypes_2eproto_once, nullptr, 0, 34,
  schemas, file_default_instances, TableStruct_public_5fapi_5ftypes_2eproto::offsets,
  file_level_metadata_public_5fapi_5ftypes_2eproto, file_level_enum_descriptors_public_5fapi_5ftypes_2eproto, file_level_service_descriptors_public_5fapi_5ftypes_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_public_5fapi_5ftypes_2eproto_getter() {
  return &descriptor_table_public_5fapi_5ftypes_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_public_5fapi_5ftypes_2eproto(&descriptor_table_public_5fapi_5ftypes_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[0];
}
bool RobotType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 20:
    case 21:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecondaryDeviceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[1];
}
bool SecondaryDeviceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BaseState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[2];
}
bool BaseState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LiftState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[3];
}
bool LiftState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReportFrequency_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[4];
}
bool ReportFrequency_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParkingStopCategory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[5];
}
bool ParkingStopCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WarningCategory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[6];
}
bool WarningCategory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotorError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_public_5fapi_5ftypes_2eproto);
  return file_level_enum_descriptors_public_5fapi_5ftypes_2eproto[7];
}
bool MotorError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class BaseEstimatedOdometry::_Internal {
 public:
};

BaseEstimatedOdometry::BaseEstimatedOdometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:BaseEstimatedOdometry)
}
BaseEstimatedOdometry::BaseEstimatedOdometry(const BaseEstimatedOdometry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&speed_x_, &from.speed_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_z_) -
    reinterpret_cast<char*>(&speed_x_)) + sizeof(speed_z_));
  // @@protoc_insertion_point(copy_constructor:BaseEstimatedOdometry)
}

inline void BaseEstimatedOdometry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&speed_x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_z_) -
    reinterpret_cast<char*>(&speed_x_)) + sizeof(speed_z_));
}

BaseEstimatedOdometry::~BaseEstimatedOdometry() {
  // @@protoc_insertion_point(destructor:BaseEstimatedOdometry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BaseEstimatedOdometry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BaseEstimatedOdometry::ArenaDtor(void* object) {
  BaseEstimatedOdometry* _this = reinterpret_cast< BaseEstimatedOdometry* >(object);
  (void)_this;
}
void BaseEstimatedOdometry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BaseEstimatedOdometry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BaseEstimatedOdometry::Clear() {
// @@protoc_insertion_point(message_clear_start:BaseEstimatedOdometry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&speed_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_z_) -
      reinterpret_cast<char*>(&speed_x_)) + sizeof(speed_z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseEstimatedOdometry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float speed_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          speed_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          speed_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed_z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          speed_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // double pos_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pos_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double pos_z = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          pos_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseEstimatedOdometry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BaseEstimatedOdometry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float speed_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_x = this->_internal_speed_x();
  uint32_t raw_speed_x;
  memcpy(&raw_speed_x, &tmp_speed_x, sizeof(tmp_speed_x));
  if (raw_speed_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_speed_x(), target);
  }

  // float speed_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_y = this->_internal_speed_y();
  uint32_t raw_speed_y;
  memcpy(&raw_speed_y, &tmp_speed_y, sizeof(tmp_speed_y));
  if (raw_speed_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_speed_y(), target);
  }

  // float speed_z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_z = this->_internal_speed_z();
  uint32_t raw_speed_z;
  memcpy(&raw_speed_z, &tmp_speed_z, sizeof(tmp_speed_z));
  if (raw_speed_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_speed_z(), target);
  }

  // double pos_x = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_x = this->_internal_pos_x();
  uint64_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_pos_x(), target);
  }

  // double pos_y = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_y = this->_internal_pos_y();
  uint64_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_pos_y(), target);
  }

  // double pos_z = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_z = this->_internal_pos_z();
  uint64_t raw_pos_z;
  memcpy(&raw_pos_z, &tmp_pos_z, sizeof(tmp_pos_z));
  if (raw_pos_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_pos_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BaseEstimatedOdometry)
  return target;
}

size_t BaseEstimatedOdometry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BaseEstimatedOdometry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float speed_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_x = this->_internal_speed_x();
  uint32_t raw_speed_x;
  memcpy(&raw_speed_x, &tmp_speed_x, sizeof(tmp_speed_x));
  if (raw_speed_x != 0) {
    total_size += 1 + 4;
  }

  // float speed_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_y = this->_internal_speed_y();
  uint32_t raw_speed_y;
  memcpy(&raw_speed_y, &tmp_speed_y, sizeof(tmp_speed_y));
  if (raw_speed_y != 0) {
    total_size += 1 + 4;
  }

  // double pos_x = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_x = this->_internal_pos_x();
  uint64_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    total_size += 1 + 8;
  }

  // double pos_y = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_y = this->_internal_pos_y();
  uint64_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    total_size += 1 + 8;
  }

  // double pos_z = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_z = this->_internal_pos_z();
  uint64_t raw_pos_z;
  memcpy(&raw_pos_z, &tmp_pos_z, sizeof(tmp_pos_z));
  if (raw_pos_z != 0) {
    total_size += 1 + 8;
  }

  // float speed_z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_z = this->_internal_speed_z();
  uint32_t raw_speed_z;
  memcpy(&raw_speed_z, &tmp_speed_z, sizeof(tmp_speed_z));
  if (raw_speed_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseEstimatedOdometry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BaseEstimatedOdometry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseEstimatedOdometry::GetClassData() const { return &_class_data_; }

void BaseEstimatedOdometry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BaseEstimatedOdometry *>(to)->MergeFrom(
      static_cast<const BaseEstimatedOdometry &>(from));
}


void BaseEstimatedOdometry::MergeFrom(const BaseEstimatedOdometry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BaseEstimatedOdometry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_x = from._internal_speed_x();
  uint32_t raw_speed_x;
  memcpy(&raw_speed_x, &tmp_speed_x, sizeof(tmp_speed_x));
  if (raw_speed_x != 0) {
    _internal_set_speed_x(from._internal_speed_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_y = from._internal_speed_y();
  uint32_t raw_speed_y;
  memcpy(&raw_speed_y, &tmp_speed_y, sizeof(tmp_speed_y));
  if (raw_speed_y != 0) {
    _internal_set_speed_y(from._internal_speed_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_x = from._internal_pos_x();
  uint64_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    _internal_set_pos_x(from._internal_pos_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_y = from._internal_pos_y();
  uint64_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    _internal_set_pos_y(from._internal_pos_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_pos_z = from._internal_pos_z();
  uint64_t raw_pos_z;
  memcpy(&raw_pos_z, &tmp_pos_z, sizeof(tmp_pos_z));
  if (raw_pos_z != 0) {
    _internal_set_pos_z(from._internal_pos_z());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_z = from._internal_speed_z();
  uint32_t raw_speed_z;
  memcpy(&raw_speed_z, &tmp_speed_z, sizeof(tmp_speed_z));
  if (raw_speed_z != 0) {
    _internal_set_speed_z(from._internal_speed_z());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseEstimatedOdometry::CopyFrom(const BaseEstimatedOdometry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BaseEstimatedOdometry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseEstimatedOdometry::IsInitialized() const {
  return true;
}

void BaseEstimatedOdometry::InternalSwap(BaseEstimatedOdometry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseEstimatedOdometry, speed_z_)
      + sizeof(BaseEstimatedOdometry::speed_z_)
      - PROTOBUF_FIELD_OFFSET(BaseEstimatedOdometry, speed_x_)>(
          reinterpret_cast<char*>(&speed_x_),
          reinterpret_cast<char*>(&other->speed_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseEstimatedOdometry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[0]);
}

// ===================================================================

class BaseStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseStatus>()._has_bits_);
  static void set_has_battery_charging(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ParkingStopDetail& parking_stop_detail(const BaseStatus* msg);
  static void set_has_parking_stop_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_warning(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::BaseEstimatedOdometry& estimated_odometry(const BaseStatus* msg);
  static void set_has_estimated_odometry(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ParkingStopDetail&
BaseStatus::_Internal::parking_stop_detail(const BaseStatus* msg) {
  return *msg->parking_stop_detail_;
}
const ::BaseEstimatedOdometry&
BaseStatus::_Internal::estimated_odometry(const BaseStatus* msg) {
  return *msg->estimated_odometry_;
}
BaseStatus::BaseStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  motor_status_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:BaseStatus)
}
BaseStatus::BaseStatus(const BaseStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      motor_status_(from.motor_status_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parking_stop_detail()) {
    parking_stop_detail_ = new ::ParkingStopDetail(*from.parking_stop_detail_);
  } else {
    parking_stop_detail_ = nullptr;
  }
  if (from._internal_has_estimated_odometry()) {
    estimated_odometry_ = new ::BaseEstimatedOdometry(*from.estimated_odometry_);
  } else {
    estimated_odometry_ = nullptr;
  }
  ::memcpy(&state_, &from.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&warning_) -
    reinterpret_cast<char*>(&state_)) + sizeof(warning_));
  // @@protoc_insertion_point(copy_constructor:BaseStatus)
}

inline void BaseStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&parking_stop_detail_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&warning_) -
    reinterpret_cast<char*>(&parking_stop_detail_)) + sizeof(warning_));
}

BaseStatus::~BaseStatus() {
  // @@protoc_insertion_point(destructor:BaseStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BaseStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete parking_stop_detail_;
  if (this != internal_default_instance()) delete estimated_odometry_;
}

void BaseStatus::ArenaDtor(void* object) {
  BaseStatus* _this = reinterpret_cast< BaseStatus* >(object);
  (void)_this;
}
void BaseStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BaseStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BaseStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:BaseStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  motor_status_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(parking_stop_detail_ != nullptr);
      parking_stop_detail_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(estimated_odometry_ != nullptr);
      estimated_odometry_->Clear();
    }
  }
  ::memset(&state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&api_control_initialized_) -
      reinterpret_cast<char*>(&state_)) + sizeof(api_control_initialized_));
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&battery_charging_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&warning_) -
        reinterpret_cast<char*>(&battery_charging_)) + sizeof(warning_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .BaseState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_state(static_cast<::BaseState>(val));
        } else
          goto handle_unusual;
        continue;
      // bool api_control_initialized = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          api_control_initialized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float battery_voltage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          battery_voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 battery_thousandth = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          battery_thousandth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .MotorStatus motor_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_motor_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 session_holder = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          session_holder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool battery_charging = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_battery_charging(&has_bits);
          battery_charging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ParkingStopDetail parking_stop_detail = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_parking_stop_detail(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .WarningCategory warning = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_warning(static_cast<::WarningCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // optional .BaseEstimatedOdometry estimated_odometry = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_estimated_odometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BaseStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .BaseState state = 1;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // bool api_control_initialized = 2;
  if (this->_internal_api_control_initialized() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_api_control_initialized(), target);
  }

  // float battery_voltage = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_battery_voltage = this->_internal_battery_voltage();
  uint32_t raw_battery_voltage;
  memcpy(&raw_battery_voltage, &tmp_battery_voltage, sizeof(tmp_battery_voltage));
  if (raw_battery_voltage != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_battery_voltage(), target);
  }

  // uint32 battery_thousandth = 4;
  if (this->_internal_battery_thousandth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_battery_thousandth(), target);
  }

  // repeated .MotorStatus motor_status = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_motor_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_motor_status(i), target, stream);
  }

  // uint32 session_holder = 6;
  if (this->_internal_session_holder() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_session_holder(), target);
  }

  // optional bool battery_charging = 10;
  if (_internal_has_battery_charging()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_battery_charging(), target);
  }

  // optional .ParkingStopDetail parking_stop_detail = 11;
  if (_internal_has_parking_stop_detail()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::parking_stop_detail(this), target, stream);
  }

  // optional .WarningCategory warning = 12;
  if (_internal_has_warning()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_warning(), target);
  }

  // optional .BaseEstimatedOdometry estimated_odometry = 13;
  if (_internal_has_estimated_odometry()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::estimated_odometry(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BaseStatus)
  return target;
}

size_t BaseStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BaseStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MotorStatus motor_status = 5;
  total_size += 1UL * this->_internal_motor_status_size();
  for (const auto& msg : this->motor_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ParkingStopDetail parking_stop_detail = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *parking_stop_detail_);
    }

    // optional .BaseEstimatedOdometry estimated_odometry = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *estimated_odometry_);
    }

  }
  // .BaseState state = 1;
  if (this->_internal_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }

  // float battery_voltage = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_battery_voltage = this->_internal_battery_voltage();
  uint32_t raw_battery_voltage;
  memcpy(&raw_battery_voltage, &tmp_battery_voltage, sizeof(tmp_battery_voltage));
  if (raw_battery_voltage != 0) {
    total_size += 1 + 4;
  }

  // uint32 battery_thousandth = 4;
  if (this->_internal_battery_thousandth() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_battery_thousandth());
  }

  // uint32 session_holder = 6;
  if (this->_internal_session_holder() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_holder());
  }

  // bool api_control_initialized = 2;
  if (this->_internal_api_control_initialized() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional bool battery_charging = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .WarningCategory warning = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_warning());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BaseStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseStatus::GetClassData() const { return &_class_data_; }

void BaseStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BaseStatus *>(to)->MergeFrom(
      static_cast<const BaseStatus &>(from));
}


void BaseStatus::MergeFrom(const BaseStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BaseStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  motor_status_.MergeFrom(from.motor_status_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_parking_stop_detail()->::ParkingStopDetail::MergeFrom(from._internal_parking_stop_detail());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_estimated_odometry()->::BaseEstimatedOdometry::MergeFrom(from._internal_estimated_odometry());
    }
  }
  if (from._internal_state() != 0) {
    _internal_set_state(from._internal_state());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_battery_voltage = from._internal_battery_voltage();
  uint32_t raw_battery_voltage;
  memcpy(&raw_battery_voltage, &tmp_battery_voltage, sizeof(tmp_battery_voltage));
  if (raw_battery_voltage != 0) {
    _internal_set_battery_voltage(from._internal_battery_voltage());
  }
  if (from._internal_battery_thousandth() != 0) {
    _internal_set_battery_thousandth(from._internal_battery_thousandth());
  }
  if (from._internal_session_holder() != 0) {
    _internal_set_session_holder(from._internal_session_holder());
  }
  if (from._internal_api_control_initialized() != 0) {
    _internal_set_api_control_initialized(from._internal_api_control_initialized());
  }
  if (cached_has_bits & 0x0000000cu) {
    if (cached_has_bits & 0x00000004u) {
      battery_charging_ = from.battery_charging_;
    }
    if (cached_has_bits & 0x00000008u) {
      warning_ = from.warning_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseStatus::CopyFrom(const BaseStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BaseStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseStatus::IsInitialized() const {
  return true;
}

void BaseStatus::InternalSwap(BaseStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  motor_status_.InternalSwap(&other->motor_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseStatus, warning_)
      + sizeof(BaseStatus::warning_)
      - PROTOBUF_FIELD_OFFSET(BaseStatus, parking_stop_detail_)>(
          reinterpret_cast<char*>(&parking_stop_detail_),
          reinterpret_cast<char*>(&other->parking_stop_detail_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[1]);
}

// ===================================================================

class XyzSpeed::_Internal {
 public:
};

XyzSpeed::XyzSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:XyzSpeed)
}
XyzSpeed::XyzSpeed(const XyzSpeed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&speed_x_, &from.speed_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_z_) -
    reinterpret_cast<char*>(&speed_x_)) + sizeof(speed_z_));
  // @@protoc_insertion_point(copy_constructor:XyzSpeed)
}

inline void XyzSpeed::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&speed_x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_z_) -
    reinterpret_cast<char*>(&speed_x_)) + sizeof(speed_z_));
}

XyzSpeed::~XyzSpeed() {
  // @@protoc_insertion_point(destructor:XyzSpeed)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void XyzSpeed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void XyzSpeed::ArenaDtor(void* object) {
  XyzSpeed* _this = reinterpret_cast< XyzSpeed* >(object);
  (void)_this;
}
void XyzSpeed::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void XyzSpeed::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void XyzSpeed::Clear() {
// @@protoc_insertion_point(message_clear_start:XyzSpeed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&speed_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_z_) -
      reinterpret_cast<char*>(&speed_x_)) + sizeof(speed_z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* XyzSpeed::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float speed_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          speed_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          speed_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speed_z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          speed_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* XyzSpeed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:XyzSpeed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float speed_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_x = this->_internal_speed_x();
  uint32_t raw_speed_x;
  memcpy(&raw_speed_x, &tmp_speed_x, sizeof(tmp_speed_x));
  if (raw_speed_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_speed_x(), target);
  }

  // float speed_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_y = this->_internal_speed_y();
  uint32_t raw_speed_y;
  memcpy(&raw_speed_y, &tmp_speed_y, sizeof(tmp_speed_y));
  if (raw_speed_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_speed_y(), target);
  }

  // float speed_z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_z = this->_internal_speed_z();
  uint32_t raw_speed_z;
  memcpy(&raw_speed_z, &tmp_speed_z, sizeof(tmp_speed_z));
  if (raw_speed_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_speed_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:XyzSpeed)
  return target;
}

size_t XyzSpeed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:XyzSpeed)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float speed_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_x = this->_internal_speed_x();
  uint32_t raw_speed_x;
  memcpy(&raw_speed_x, &tmp_speed_x, sizeof(tmp_speed_x));
  if (raw_speed_x != 0) {
    total_size += 1 + 4;
  }

  // float speed_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_y = this->_internal_speed_y();
  uint32_t raw_speed_y;
  memcpy(&raw_speed_y, &tmp_speed_y, sizeof(tmp_speed_y));
  if (raw_speed_y != 0) {
    total_size += 1 + 4;
  }

  // float speed_z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_z = this->_internal_speed_z();
  uint32_t raw_speed_z;
  memcpy(&raw_speed_z, &tmp_speed_z, sizeof(tmp_speed_z));
  if (raw_speed_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData XyzSpeed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    XyzSpeed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*XyzSpeed::GetClassData() const { return &_class_data_; }

void XyzSpeed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<XyzSpeed *>(to)->MergeFrom(
      static_cast<const XyzSpeed &>(from));
}


void XyzSpeed::MergeFrom(const XyzSpeed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:XyzSpeed)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_x = from._internal_speed_x();
  uint32_t raw_speed_x;
  memcpy(&raw_speed_x, &tmp_speed_x, sizeof(tmp_speed_x));
  if (raw_speed_x != 0) {
    _internal_set_speed_x(from._internal_speed_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_y = from._internal_speed_y();
  uint32_t raw_speed_y;
  memcpy(&raw_speed_y, &tmp_speed_y, sizeof(tmp_speed_y));
  if (raw_speed_y != 0) {
    _internal_set_speed_y(from._internal_speed_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed_z = from._internal_speed_z();
  uint32_t raw_speed_z;
  memcpy(&raw_speed_z, &tmp_speed_z, sizeof(tmp_speed_z));
  if (raw_speed_z != 0) {
    _internal_set_speed_z(from._internal_speed_z());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void XyzSpeed::CopyFrom(const XyzSpeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:XyzSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XyzSpeed::IsInitialized() const {
  return true;
}

void XyzSpeed::InternalSwap(XyzSpeed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(XyzSpeed, speed_z_)
      + sizeof(XyzSpeed::speed_z_)
      - PROTOBUF_FIELD_OFFSET(XyzSpeed, speed_x_)>(
          reinterpret_cast<char*>(&speed_x_),
          reinterpret_cast<char*>(&other->speed_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata XyzSpeed::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[2]);
}

// ===================================================================

class SimpleBaseMoveCommand::_Internal {
 public:
  static const ::XyzSpeed& xyz_speed(const SimpleBaseMoveCommand* msg);
};

const ::XyzSpeed&
SimpleBaseMoveCommand::_Internal::xyz_speed(const SimpleBaseMoveCommand* msg) {
  return *msg->command_.xyz_speed_;
}
void SimpleBaseMoveCommand::set_allocated_xyz_speed(::XyzSpeed* xyz_speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (xyz_speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XyzSpeed>::GetOwningArena(xyz_speed);
    if (message_arena != submessage_arena) {
      xyz_speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xyz_speed, submessage_arena);
    }
    set_has_xyz_speed();
    command_.xyz_speed_ = xyz_speed;
  }
  // @@protoc_insertion_point(field_set_allocated:SimpleBaseMoveCommand.xyz_speed)
}
SimpleBaseMoveCommand::SimpleBaseMoveCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SimpleBaseMoveCommand)
}
SimpleBaseMoveCommand::SimpleBaseMoveCommand(const SimpleBaseMoveCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kXyzSpeed: {
      _internal_mutable_xyz_speed()->::XyzSpeed::MergeFrom(from._internal_xyz_speed());
      break;
    }
    case kZeroResistance: {
      _internal_set_zero_resistance(from._internal_zero_resistance());
      break;
    }
    case kBrake: {
      _internal_set_brake(from._internal_brake());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SimpleBaseMoveCommand)
}

inline void SimpleBaseMoveCommand::SharedCtor() {
clear_has_command();
}

SimpleBaseMoveCommand::~SimpleBaseMoveCommand() {
  // @@protoc_insertion_point(destructor:SimpleBaseMoveCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimpleBaseMoveCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void SimpleBaseMoveCommand::ArenaDtor(void* object) {
  SimpleBaseMoveCommand* _this = reinterpret_cast< SimpleBaseMoveCommand* >(object);
  (void)_this;
}
void SimpleBaseMoveCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimpleBaseMoveCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimpleBaseMoveCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:SimpleBaseMoveCommand)
  switch (command_case()) {
    case kXyzSpeed: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.xyz_speed_;
      }
      break;
    }
    case kZeroResistance: {
      // No need to clear
      break;
    }
    case kBrake: {
      // No need to clear
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void SimpleBaseMoveCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:SimpleBaseMoveCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimpleBaseMoveCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .XyzSpeed xyz_speed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_xyz_speed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool zero_resistance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_zero_resistance(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool brake = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_brake(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimpleBaseMoveCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SimpleBaseMoveCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .XyzSpeed xyz_speed = 1;
  if (_internal_has_xyz_speed()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::xyz_speed(this), target, stream);
  }

  // bool zero_resistance = 2;
  if (_internal_has_zero_resistance()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_zero_resistance(), target);
  }

  // bool brake = 3;
  if (_internal_has_brake()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_brake(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SimpleBaseMoveCommand)
  return target;
}

size_t SimpleBaseMoveCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SimpleBaseMoveCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // .XyzSpeed xyz_speed = 1;
    case kXyzSpeed: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.xyz_speed_);
      break;
    }
    // bool zero_resistance = 2;
    case kZeroResistance: {
      total_size += 1 + 1;
      break;
    }
    // bool brake = 3;
    case kBrake: {
      total_size += 1 + 1;
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimpleBaseMoveCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimpleBaseMoveCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimpleBaseMoveCommand::GetClassData() const { return &_class_data_; }

void SimpleBaseMoveCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SimpleBaseMoveCommand *>(to)->MergeFrom(
      static_cast<const SimpleBaseMoveCommand &>(from));
}


void SimpleBaseMoveCommand::MergeFrom(const SimpleBaseMoveCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SimpleBaseMoveCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kXyzSpeed: {
      _internal_mutable_xyz_speed()->::XyzSpeed::MergeFrom(from._internal_xyz_speed());
      break;
    }
    case kZeroResistance: {
      _internal_set_zero_resistance(from._internal_zero_resistance());
      break;
    }
    case kBrake: {
      _internal_set_brake(from._internal_brake());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimpleBaseMoveCommand::CopyFrom(const SimpleBaseMoveCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SimpleBaseMoveCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleBaseMoveCommand::IsInitialized() const {
  return true;
}

void SimpleBaseMoveCommand::InternalSwap(SimpleBaseMoveCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimpleBaseMoveCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[3]);
}

// ===================================================================

class BaseCommand::_Internal {
 public:
  static const ::MotorTargets& motor_targets(const BaseCommand* msg);
  static const ::SimpleBaseMoveCommand& simple_move_command(const BaseCommand* msg);
};

const ::MotorTargets&
BaseCommand::_Internal::motor_targets(const BaseCommand* msg) {
  return *msg->command_.motor_targets_;
}
const ::SimpleBaseMoveCommand&
BaseCommand::_Internal::simple_move_command(const BaseCommand* msg) {
  return *msg->command_.simple_move_command_;
}
void BaseCommand::set_allocated_motor_targets(::MotorTargets* motor_targets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (motor_targets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MotorTargets>::GetOwningArena(motor_targets);
    if (message_arena != submessage_arena) {
      motor_targets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motor_targets, submessage_arena);
    }
    set_has_motor_targets();
    command_.motor_targets_ = motor_targets;
  }
  // @@protoc_insertion_point(field_set_allocated:BaseCommand.motor_targets)
}
void BaseCommand::set_allocated_simple_move_command(::SimpleBaseMoveCommand* simple_move_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (simple_move_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SimpleBaseMoveCommand>::GetOwningArena(simple_move_command);
    if (message_arena != submessage_arena) {
      simple_move_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simple_move_command, submessage_arena);
    }
    set_has_simple_move_command();
    command_.simple_move_command_ = simple_move_command;
  }
  // @@protoc_insertion_point(field_set_allocated:BaseCommand.simple_move_command)
}
BaseCommand::BaseCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:BaseCommand)
}
BaseCommand::BaseCommand(const BaseCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kApiControlInitialize: {
      _internal_set_api_control_initialize(from._internal_api_control_initialize());
      break;
    }
    case kClearParkingStop: {
      _internal_set_clear_parking_stop(from._internal_clear_parking_stop());
      break;
    }
    case kMotorTargets: {
      _internal_mutable_motor_targets()->::MotorTargets::MergeFrom(from._internal_motor_targets());
      break;
    }
    case kSimpleMoveCommand: {
      _internal_mutable_simple_move_command()->::SimpleBaseMoveCommand::MergeFrom(from._internal_simple_move_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:BaseCommand)
}

inline void BaseCommand::SharedCtor() {
clear_has_command();
}

BaseCommand::~BaseCommand() {
  // @@protoc_insertion_point(destructor:BaseCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BaseCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void BaseCommand::ArenaDtor(void* object) {
  BaseCommand* _this = reinterpret_cast< BaseCommand* >(object);
  (void)_this;
}
void BaseCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BaseCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BaseCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:BaseCommand)
  switch (command_case()) {
    case kApiControlInitialize: {
      // No need to clear
      break;
    }
    case kClearParkingStop: {
      // No need to clear
      break;
    }
    case kMotorTargets: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.motor_targets_;
      }
      break;
    }
    case kSimpleMoveCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.simple_move_command_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void BaseCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:BaseCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BaseCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool api_control_initialize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_api_control_initialize(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool clear_parking_stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_clear_parking_stop(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .MotorTargets motor_targets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_motor_targets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SimpleBaseMoveCommand simple_move_command = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_simple_move_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BaseCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BaseCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool api_control_initialize = 1;
  if (_internal_has_api_control_initialize()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_api_control_initialize(), target);
  }

  // bool clear_parking_stop = 2;
  if (_internal_has_clear_parking_stop()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_clear_parking_stop(), target);
  }

  // .MotorTargets motor_targets = 3;
  if (_internal_has_motor_targets()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::motor_targets(this), target, stream);
  }

  // .SimpleBaseMoveCommand simple_move_command = 5;
  if (_internal_has_simple_move_command()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::simple_move_command(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BaseCommand)
  return target;
}

size_t BaseCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BaseCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // bool api_control_initialize = 1;
    case kApiControlInitialize: {
      total_size += 1 + 1;
      break;
    }
    // bool clear_parking_stop = 2;
    case kClearParkingStop: {
      total_size += 1 + 1;
      break;
    }
    // .MotorTargets motor_targets = 3;
    case kMotorTargets: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.motor_targets_);
      break;
    }
    // .SimpleBaseMoveCommand simple_move_command = 5;
    case kSimpleMoveCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.simple_move_command_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BaseCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BaseCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BaseCommand::GetClassData() const { return &_class_data_; }

void BaseCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BaseCommand *>(to)->MergeFrom(
      static_cast<const BaseCommand &>(from));
}


void BaseCommand::MergeFrom(const BaseCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BaseCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kApiControlInitialize: {
      _internal_set_api_control_initialize(from._internal_api_control_initialize());
      break;
    }
    case kClearParkingStop: {
      _internal_set_clear_parking_stop(from._internal_clear_parking_stop());
      break;
    }
    case kMotorTargets: {
      _internal_mutable_motor_targets()->::MotorTargets::MergeFrom(from._internal_motor_targets());
      break;
    }
    case kSimpleMoveCommand: {
      _internal_mutable_simple_move_command()->::SimpleBaseMoveCommand::MergeFrom(from._internal_simple_move_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BaseCommand::CopyFrom(const BaseCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BaseCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseCommand::IsInitialized() const {
  return true;
}

void BaseCommand::InternalSwap(BaseCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata BaseCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[4]);
}

// ===================================================================

class RotateLiftStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<RotateLiftStatus>()._has_bits_);
  static const ::ParkingStopDetail& parking_stop_detail(const RotateLiftStatus* msg);
  static void set_has_parking_stop_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ParkingStopDetail&
RotateLiftStatus::_Internal::parking_stop_detail(const RotateLiftStatus* msg) {
  return *msg->parking_stop_detail_;
}
RotateLiftStatus::RotateLiftStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  motor_status_(arena),
  max_pos_(arena),
  min_pos_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RotateLiftStatus)
}
RotateLiftStatus::RotateLiftStatus(const RotateLiftStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      motor_status_(from.motor_status_),
      max_pos_(from.max_pos_),
      min_pos_(from.min_pos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parking_stop_detail()) {
    parking_stop_detail_ = new ::ParkingStopDetail(*from.parking_stop_detail_);
  } else {
    parking_stop_detail_ = nullptr;
  }
  ::memcpy(&calibrated_, &from.calibrated_,
    static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&calibrated_)) + sizeof(state_));
  // @@protoc_insertion_point(copy_constructor:RotateLiftStatus)
}

inline void RotateLiftStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&parking_stop_detail_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&parking_stop_detail_)) + sizeof(state_));
}

RotateLiftStatus::~RotateLiftStatus() {
  // @@protoc_insertion_point(destructor:RotateLiftStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RotateLiftStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete parking_stop_detail_;
}

void RotateLiftStatus::ArenaDtor(void* object) {
  RotateLiftStatus* _this = reinterpret_cast< RotateLiftStatus* >(object);
  (void)_this;
}
void RotateLiftStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RotateLiftStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RotateLiftStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:RotateLiftStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  motor_status_.Clear();
  max_pos_.Clear();
  min_pos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(parking_stop_detail_ != nullptr);
    parking_stop_detail_->Clear();
  }
  ::memset(&calibrated_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&state_) -
      reinterpret_cast<char*>(&calibrated_)) + sizeof(state_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RotateLiftStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool calibrated = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          calibrated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LiftState state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_state(static_cast<::LiftState>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .MotorStatus motor_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_motor_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 max_pos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_max_pos(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_max_pos(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 min_pos = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_min_pos(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_min_pos(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ParkingStopDetail parking_stop_detail = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_parking_stop_detail(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RotateLiftStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RotateLiftStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool calibrated = 1;
  if (this->_internal_calibrated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_calibrated(), target);
  }

  // .LiftState state = 2;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_state(), target);
  }

  // repeated .MotorStatus motor_status = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_motor_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_motor_status(i), target, stream);
  }

  // repeated int32 max_pos = 4;
  {
    int byte_size = _max_pos_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_max_pos(), byte_size, target);
    }
  }

  // repeated int32 min_pos = 5;
  {
    int byte_size = _min_pos_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          5, _internal_min_pos(), byte_size, target);
    }
  }

  // optional .ParkingStopDetail parking_stop_detail = 10;
  if (_internal_has_parking_stop_detail()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::parking_stop_detail(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RotateLiftStatus)
  return target;
}

size_t RotateLiftStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RotateLiftStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MotorStatus motor_status = 3;
  total_size += 1UL * this->_internal_motor_status_size();
  for (const auto& msg : this->motor_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 max_pos = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->max_pos_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _max_pos_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 min_pos = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->min_pos_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _min_pos_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional .ParkingStopDetail parking_stop_detail = 10;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *parking_stop_detail_);
  }

  // bool calibrated = 1;
  if (this->_internal_calibrated() != 0) {
    total_size += 1 + 1;
  }

  // .LiftState state = 2;
  if (this->_internal_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RotateLiftStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RotateLiftStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RotateLiftStatus::GetClassData() const { return &_class_data_; }

void RotateLiftStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RotateLiftStatus *>(to)->MergeFrom(
      static_cast<const RotateLiftStatus &>(from));
}


void RotateLiftStatus::MergeFrom(const RotateLiftStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RotateLiftStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  motor_status_.MergeFrom(from.motor_status_);
  max_pos_.MergeFrom(from.max_pos_);
  min_pos_.MergeFrom(from.min_pos_);
  if (from._internal_has_parking_stop_detail()) {
    _internal_mutable_parking_stop_detail()->::ParkingStopDetail::MergeFrom(from._internal_parking_stop_detail());
  }
  if (from._internal_calibrated() != 0) {
    _internal_set_calibrated(from._internal_calibrated());
  }
  if (from._internal_state() != 0) {
    _internal_set_state(from._internal_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RotateLiftStatus::CopyFrom(const RotateLiftStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RotateLiftStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RotateLiftStatus::IsInitialized() const {
  return true;
}

void RotateLiftStatus::InternalSwap(RotateLiftStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  motor_status_.InternalSwap(&other->motor_status_);
  max_pos_.InternalSwap(&other->max_pos_);
  min_pos_.InternalSwap(&other->min_pos_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotateLiftStatus, state_)
      + sizeof(RotateLiftStatus::state_)
      - PROTOBUF_FIELD_OFFSET(RotateLiftStatus, parking_stop_detail_)>(
          reinterpret_cast<char*>(&parking_stop_detail_),
          reinterpret_cast<char*>(&other->parking_stop_detail_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RotateLiftStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[5]);
}

// ===================================================================

class RotateLiftRuntimeConfig::_Internal {
 public:
};

RotateLiftRuntimeConfig::RotateLiftRuntimeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  pos_mode_max_speed_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RotateLiftRuntimeConfig)
}
RotateLiftRuntimeConfig::RotateLiftRuntimeConfig(const RotateLiftRuntimeConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      pos_mode_max_speed_(from.pos_mode_max_speed_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:RotateLiftRuntimeConfig)
}

inline void RotateLiftRuntimeConfig::SharedCtor() {
}

RotateLiftRuntimeConfig::~RotateLiftRuntimeConfig() {
  // @@protoc_insertion_point(destructor:RotateLiftRuntimeConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RotateLiftRuntimeConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RotateLiftRuntimeConfig::ArenaDtor(void* object) {
  RotateLiftRuntimeConfig* _this = reinterpret_cast< RotateLiftRuntimeConfig* >(object);
  (void)_this;
}
void RotateLiftRuntimeConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RotateLiftRuntimeConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RotateLiftRuntimeConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:RotateLiftRuntimeConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pos_mode_max_speed_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RotateLiftRuntimeConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double pos_mode_max_speed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_pos_mode_max_speed(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_pos_mode_max_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RotateLiftRuntimeConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RotateLiftRuntimeConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double pos_mode_max_speed = 1;
  if (this->_internal_pos_mode_max_speed_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_pos_mode_max_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RotateLiftRuntimeConfig)
  return target;
}

size_t RotateLiftRuntimeConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RotateLiftRuntimeConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double pos_mode_max_speed = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_pos_mode_max_speed_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RotateLiftRuntimeConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RotateLiftRuntimeConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RotateLiftRuntimeConfig::GetClassData() const { return &_class_data_; }

void RotateLiftRuntimeConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RotateLiftRuntimeConfig *>(to)->MergeFrom(
      static_cast<const RotateLiftRuntimeConfig &>(from));
}


void RotateLiftRuntimeConfig::MergeFrom(const RotateLiftRuntimeConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RotateLiftRuntimeConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  pos_mode_max_speed_.MergeFrom(from.pos_mode_max_speed_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RotateLiftRuntimeConfig::CopyFrom(const RotateLiftRuntimeConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RotateLiftRuntimeConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RotateLiftRuntimeConfig::IsInitialized() const {
  return true;
}

void RotateLiftRuntimeConfig::InternalSwap(RotateLiftRuntimeConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  pos_mode_max_speed_.InternalSwap(&other->pos_mode_max_speed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RotateLiftRuntimeConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[6]);
}

// ===================================================================

class RotateLiftCommand::_Internal {
 public:
  static const ::MotorTargets& motor_targets(const RotateLiftCommand* msg);
  static const ::RotateLiftRuntimeConfig& runtime_config(const RotateLiftCommand* msg);
};

const ::MotorTargets&
RotateLiftCommand::_Internal::motor_targets(const RotateLiftCommand* msg) {
  return *msg->command_.motor_targets_;
}
const ::RotateLiftRuntimeConfig&
RotateLiftCommand::_Internal::runtime_config(const RotateLiftCommand* msg) {
  return *msg->command_.runtime_config_;
}
void RotateLiftCommand::set_allocated_motor_targets(::MotorTargets* motor_targets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (motor_targets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MotorTargets>::GetOwningArena(motor_targets);
    if (message_arena != submessage_arena) {
      motor_targets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motor_targets, submessage_arena);
    }
    set_has_motor_targets();
    command_.motor_targets_ = motor_targets;
  }
  // @@protoc_insertion_point(field_set_allocated:RotateLiftCommand.motor_targets)
}
void RotateLiftCommand::set_allocated_runtime_config(::RotateLiftRuntimeConfig* runtime_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (runtime_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RotateLiftRuntimeConfig>::GetOwningArena(runtime_config);
    if (message_arena != submessage_arena) {
      runtime_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime_config, submessage_arena);
    }
    set_has_runtime_config();
    command_.runtime_config_ = runtime_config;
  }
  // @@protoc_insertion_point(field_set_allocated:RotateLiftCommand.runtime_config)
}
RotateLiftCommand::RotateLiftCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:RotateLiftCommand)
}
RotateLiftCommand::RotateLiftCommand(const RotateLiftCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kCalibrate: {
      _internal_set_calibrate(from._internal_calibrate());
      break;
    }
    case kMotorTargets: {
      _internal_mutable_motor_targets()->::MotorTargets::MergeFrom(from._internal_motor_targets());
      break;
    }
    case kRuntimeConfig: {
      _internal_mutable_runtime_config()->::RotateLiftRuntimeConfig::MergeFrom(from._internal_runtime_config());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:RotateLiftCommand)
}

inline void RotateLiftCommand::SharedCtor() {
clear_has_command();
}

RotateLiftCommand::~RotateLiftCommand() {
  // @@protoc_insertion_point(destructor:RotateLiftCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RotateLiftCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void RotateLiftCommand::ArenaDtor(void* object) {
  RotateLiftCommand* _this = reinterpret_cast< RotateLiftCommand* >(object);
  (void)_this;
}
void RotateLiftCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RotateLiftCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RotateLiftCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:RotateLiftCommand)
  switch (command_case()) {
    case kCalibrate: {
      // No need to clear
      break;
    }
    case kMotorTargets: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.motor_targets_;
      }
      break;
    }
    case kRuntimeConfig: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.runtime_config_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void RotateLiftCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:RotateLiftCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RotateLiftCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool calibrate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_calibrate(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .MotorTargets motor_targets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_motor_targets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .RotateLiftRuntimeConfig runtime_config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_runtime_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RotateLiftCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RotateLiftCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool calibrate = 1;
  if (_internal_has_calibrate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_calibrate(), target);
  }

  // .MotorTargets motor_targets = 2;
  if (_internal_has_motor_targets()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::motor_targets(this), target, stream);
  }

  // .RotateLiftRuntimeConfig runtime_config = 3;
  if (_internal_has_runtime_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::runtime_config(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RotateLiftCommand)
  return target;
}

size_t RotateLiftCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RotateLiftCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // bool calibrate = 1;
    case kCalibrate: {
      total_size += 1 + 1;
      break;
    }
    // .MotorTargets motor_targets = 2;
    case kMotorTargets: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.motor_targets_);
      break;
    }
    // .RotateLiftRuntimeConfig runtime_config = 3;
    case kRuntimeConfig: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.runtime_config_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RotateLiftCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RotateLiftCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RotateLiftCommand::GetClassData() const { return &_class_data_; }

void RotateLiftCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RotateLiftCommand *>(to)->MergeFrom(
      static_cast<const RotateLiftCommand &>(from));
}


void RotateLiftCommand::MergeFrom(const RotateLiftCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RotateLiftCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kCalibrate: {
      _internal_set_calibrate(from._internal_calibrate());
      break;
    }
    case kMotorTargets: {
      _internal_mutable_motor_targets()->::MotorTargets::MergeFrom(from._internal_motor_targets());
      break;
    }
    case kRuntimeConfig: {
      _internal_mutable_runtime_config()->::RotateLiftRuntimeConfig::MergeFrom(from._internal_runtime_config());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RotateLiftCommand::CopyFrom(const RotateLiftCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RotateLiftCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RotateLiftCommand::IsInitialized() const {
  return true;
}

void RotateLiftCommand::InternalSwap(RotateLiftCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata RotateLiftCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[7]);
}

// ===================================================================

class LinearLiftStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<LinearLiftStatus>()._has_bits_);
  static const ::ParkingStopDetail& parking_stop_detail(const LinearLiftStatus* msg);
  static void set_has_parking_stop_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_custom_button_pressed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ParkingStopDetail&
LinearLiftStatus::_Internal::parking_stop_detail(const LinearLiftStatus* msg) {
  return *msg->parking_stop_detail_;
}
LinearLiftStatus::LinearLiftStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:LinearLiftStatus)
}
LinearLiftStatus::LinearLiftStatus(const LinearLiftStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parking_stop_detail()) {
    parking_stop_detail_ = new ::ParkingStopDetail(*from.parking_stop_detail_);
  } else {
    parking_stop_detail_ = nullptr;
  }
  ::memcpy(&max_pos_, &from.max_pos_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&max_pos_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:LinearLiftStatus)
}

inline void LinearLiftStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&parking_stop_detail_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&parking_stop_detail_)) + sizeof(speed_));
}

LinearLiftStatus::~LinearLiftStatus() {
  // @@protoc_insertion_point(destructor:LinearLiftStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LinearLiftStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete parking_stop_detail_;
}

void LinearLiftStatus::ArenaDtor(void* object) {
  LinearLiftStatus* _this = reinterpret_cast< LinearLiftStatus* >(object);
  (void)_this;
}
void LinearLiftStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LinearLiftStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LinearLiftStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:LinearLiftStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(parking_stop_detail_ != nullptr);
    parking_stop_detail_->Clear();
  }
  ::memset(&max_pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&calibrated_) -
      reinterpret_cast<char*>(&max_pos_)) + sizeof(calibrated_));
  custom_button_pressed_ = false;
  speed_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinearLiftStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool calibrated = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          calibrated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LiftState state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_state(static_cast<::LiftState>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 max_pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          max_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 current_pos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          current_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 pulse_per_rotation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          pulse_per_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          max_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 speed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ParkingStopDetail parking_stop_detail = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_parking_stop_detail(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool custom_button_pressed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_custom_button_pressed(&has_bits);
          custom_button_pressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearLiftStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LinearLiftStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool calibrated = 1;
  if (this->_internal_calibrated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_calibrated(), target);
  }

  // .LiftState state = 2;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_state(), target);
  }

  // int64 max_pos = 3;
  if (this->_internal_max_pos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_max_pos(), target);
  }

  // int64 current_pos = 4;
  if (this->_internal_current_pos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_current_pos(), target);
  }

  // uint32 pulse_per_rotation = 5;
  if (this->_internal_pulse_per_rotation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_pulse_per_rotation(), target);
  }

  // uint32 max_speed = 6;
  if (this->_internal_max_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_max_speed(), target);
  }

  // uint32 speed = 7;
  if (this->_internal_speed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_speed(), target);
  }

  // optional .ParkingStopDetail parking_stop_detail = 10;
  if (_internal_has_parking_stop_detail()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::parking_stop_detail(this), target, stream);
  }

  // optional bool custom_button_pressed = 11;
  if (_internal_has_custom_button_pressed()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_custom_button_pressed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LinearLiftStatus)
  return target;
}

size_t LinearLiftStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LinearLiftStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .ParkingStopDetail parking_stop_detail = 10;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *parking_stop_detail_);
  }

  // int64 max_pos = 3;
  if (this->_internal_max_pos() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_max_pos());
  }

  // .LiftState state = 2;
  if (this->_internal_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }

  // uint32 pulse_per_rotation = 5;
  if (this->_internal_pulse_per_rotation() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_pulse_per_rotation());
  }

  // int64 current_pos = 4;
  if (this->_internal_current_pos() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_current_pos());
  }

  // uint32 max_speed = 6;
  if (this->_internal_max_speed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_max_speed());
  }

  // bool calibrated = 1;
  if (this->_internal_calibrated() != 0) {
    total_size += 1 + 1;
  }

  // optional bool custom_button_pressed = 11;
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  // uint32 speed = 7;
  if (this->_internal_speed() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_speed());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinearLiftStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LinearLiftStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinearLiftStatus::GetClassData() const { return &_class_data_; }

void LinearLiftStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LinearLiftStatus *>(to)->MergeFrom(
      static_cast<const LinearLiftStatus &>(from));
}


void LinearLiftStatus::MergeFrom(const LinearLiftStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LinearLiftStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_parking_stop_detail()) {
    _internal_mutable_parking_stop_detail()->::ParkingStopDetail::MergeFrom(from._internal_parking_stop_detail());
  }
  if (from._internal_max_pos() != 0) {
    _internal_set_max_pos(from._internal_max_pos());
  }
  if (from._internal_state() != 0) {
    _internal_set_state(from._internal_state());
  }
  if (from._internal_pulse_per_rotation() != 0) {
    _internal_set_pulse_per_rotation(from._internal_pulse_per_rotation());
  }
  if (from._internal_current_pos() != 0) {
    _internal_set_current_pos(from._internal_current_pos());
  }
  if (from._internal_max_speed() != 0) {
    _internal_set_max_speed(from._internal_max_speed());
  }
  if (from._internal_calibrated() != 0) {
    _internal_set_calibrated(from._internal_calibrated());
  }
  if (from._internal_has_custom_button_pressed()) {
    _internal_set_custom_button_pressed(from._internal_custom_button_pressed());
  }
  if (from._internal_speed() != 0) {
    _internal_set_speed(from._internal_speed());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinearLiftStatus::CopyFrom(const LinearLiftStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LinearLiftStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearLiftStatus::IsInitialized() const {
  return true;
}

void LinearLiftStatus::InternalSwap(LinearLiftStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LinearLiftStatus, speed_)
      + sizeof(LinearLiftStatus::speed_)
      - PROTOBUF_FIELD_OFFSET(LinearLiftStatus, parking_stop_detail_)>(
          reinterpret_cast<char*>(&parking_stop_detail_),
          reinterpret_cast<char*>(&other->parking_stop_detail_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LinearLiftStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[8]);
}

// ===================================================================

class LinearLiftCommand::_Internal {
 public:
};

LinearLiftCommand::LinearLiftCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:LinearLiftCommand)
}
LinearLiftCommand::LinearLiftCommand(const LinearLiftCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kCalibrate: {
      _internal_set_calibrate(from._internal_calibrate());
      break;
    }
    case kTargetPos: {
      _internal_set_target_pos(from._internal_target_pos());
      break;
    }
    case kBrake: {
      _internal_set_brake(from._internal_brake());
      break;
    }
    case kSetSpeed: {
      _internal_set_set_speed(from._internal_set_speed());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:LinearLiftCommand)
}

inline void LinearLiftCommand::SharedCtor() {
clear_has_command();
}

LinearLiftCommand::~LinearLiftCommand() {
  // @@protoc_insertion_point(destructor:LinearLiftCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LinearLiftCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void LinearLiftCommand::ArenaDtor(void* object) {
  LinearLiftCommand* _this = reinterpret_cast< LinearLiftCommand* >(object);
  (void)_this;
}
void LinearLiftCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LinearLiftCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LinearLiftCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:LinearLiftCommand)
  switch (command_case()) {
    case kCalibrate: {
      // No need to clear
      break;
    }
    case kTargetPos: {
      // No need to clear
      break;
    }
    case kBrake: {
      // No need to clear
      break;
    }
    case kSetSpeed: {
      // No need to clear
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void LinearLiftCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:LinearLiftCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinearLiftCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool calibrate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_calibrate(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 target_pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_target_pos(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool brake = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_brake(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 set_speed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_set_speed(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearLiftCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LinearLiftCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool calibrate = 1;
  if (_internal_has_calibrate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_calibrate(), target);
  }

  // int64 target_pos = 2;
  if (_internal_has_target_pos()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_target_pos(), target);
  }

  // bool brake = 3;
  if (_internal_has_brake()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_brake(), target);
  }

  // uint32 set_speed = 4;
  if (_internal_has_set_speed()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_set_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LinearLiftCommand)
  return target;
}

size_t LinearLiftCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LinearLiftCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // bool calibrate = 1;
    case kCalibrate: {
      total_size += 1 + 1;
      break;
    }
    // int64 target_pos = 2;
    case kTargetPos: {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_target_pos());
      break;
    }
    // bool brake = 3;
    case kBrake: {
      total_size += 1 + 1;
      break;
    }
    // uint32 set_speed = 4;
    case kSetSpeed: {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_set_speed());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinearLiftCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LinearLiftCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinearLiftCommand::GetClassData() const { return &_class_data_; }

void LinearLiftCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LinearLiftCommand *>(to)->MergeFrom(
      static_cast<const LinearLiftCommand &>(from));
}


void LinearLiftCommand::MergeFrom(const LinearLiftCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LinearLiftCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kCalibrate: {
      _internal_set_calibrate(from._internal_calibrate());
      break;
    }
    case kTargetPos: {
      _internal_set_target_pos(from._internal_target_pos());
      break;
    }
    case kBrake: {
      _internal_set_brake(from._internal_brake());
      break;
    }
    case kSetSpeed: {
      _internal_set_set_speed(from._internal_set_speed());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinearLiftCommand::CopyFrom(const LinearLiftCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LinearLiftCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearLiftCommand::IsInitialized() const {
  return true;
}

void LinearLiftCommand::InternalSwap(LinearLiftCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LinearLiftCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[9]);
}

// ===================================================================

class ArmStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ArmStatus>()._has_bits_);
  static const ::ParkingStopDetail& parking_stop_detail(const ArmStatus* msg);
  static void set_has_parking_stop_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ParkingStopDetail&
ArmStatus::_Internal::parking_stop_detail(const ArmStatus* msg) {
  return *msg->parking_stop_detail_;
}
ArmStatus::ArmStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  motor_status_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ArmStatus)
}
ArmStatus::ArmStatus(const ArmStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      motor_status_(from.motor_status_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parking_stop_detail()) {
    parking_stop_detail_ = new ::ParkingStopDetail(*from.parking_stop_detail_);
  } else {
    parking_stop_detail_ = nullptr;
  }
  ::memcpy(&api_control_initialized_, &from.api_control_initialized_,
    static_cast<size_t>(reinterpret_cast<char*>(&session_holder_) -
    reinterpret_cast<char*>(&api_control_initialized_)) + sizeof(session_holder_));
  // @@protoc_insertion_point(copy_constructor:ArmStatus)
}

inline void ArmStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&parking_stop_detail_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&session_holder_) -
    reinterpret_cast<char*>(&parking_stop_detail_)) + sizeof(session_holder_));
}

ArmStatus::~ArmStatus() {
  // @@protoc_insertion_point(destructor:ArmStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ArmStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete parking_stop_detail_;
}

void ArmStatus::ArenaDtor(void* object) {
  ArmStatus* _this = reinterpret_cast< ArmStatus* >(object);
  (void)_this;
}
void ArmStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArmStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArmStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:ArmStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  motor_status_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(parking_stop_detail_ != nullptr);
    parking_stop_detail_->Clear();
  }
  ::memset(&api_control_initialized_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&session_holder_) -
      reinterpret_cast<char*>(&api_control_initialized_)) + sizeof(session_holder_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArmStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool api_control_initialized = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          api_control_initialized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool calibrated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          calibrated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .MotorStatus motor_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_motor_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .ParkingStopDetail parking_stop_detail = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_parking_stop_detail(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 session_holder = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          session_holder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArmStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ArmStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool api_control_initialized = 1;
  if (this->_internal_api_control_initialized() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_api_control_initialized(), target);
  }

  // bool calibrated = 3;
  if (this->_internal_calibrated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_calibrated(), target);
  }

  // repeated .MotorStatus motor_status = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_motor_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_motor_status(i), target, stream);
  }

  // optional .ParkingStopDetail parking_stop_detail = 5;
  if (_internal_has_parking_stop_detail()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::parking_stop_detail(this), target, stream);
  }

  // uint32 session_holder = 6;
  if (this->_internal_session_holder() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_session_holder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ArmStatus)
  return target;
}

size_t ArmStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ArmStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MotorStatus motor_status = 4;
  total_size += 1UL * this->_internal_motor_status_size();
  for (const auto& msg : this->motor_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .ParkingStopDetail parking_stop_detail = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *parking_stop_detail_);
  }

  // bool api_control_initialized = 1;
  if (this->_internal_api_control_initialized() != 0) {
    total_size += 1 + 1;
  }

  // bool calibrated = 3;
  if (this->_internal_calibrated() != 0) {
    total_size += 1 + 1;
  }

  // uint32 session_holder = 6;
  if (this->_internal_session_holder() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_session_holder());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArmStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArmStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArmStatus::GetClassData() const { return &_class_data_; }

void ArmStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArmStatus *>(to)->MergeFrom(
      static_cast<const ArmStatus &>(from));
}


void ArmStatus::MergeFrom(const ArmStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ArmStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  motor_status_.MergeFrom(from.motor_status_);
  if (from._internal_has_parking_stop_detail()) {
    _internal_mutable_parking_stop_detail()->::ParkingStopDetail::MergeFrom(from._internal_parking_stop_detail());
  }
  if (from._internal_api_control_initialized() != 0) {
    _internal_set_api_control_initialized(from._internal_api_control_initialized());
  }
  if (from._internal_calibrated() != 0) {
    _internal_set_calibrated(from._internal_calibrated());
  }
  if (from._internal_session_holder() != 0) {
    _internal_set_session_holder(from._internal_session_holder());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArmStatus::CopyFrom(const ArmStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ArmStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArmStatus::IsInitialized() const {
  return true;
}

void ArmStatus::InternalSwap(ArmStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  motor_status_.InternalSwap(&other->motor_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArmStatus, session_holder_)
      + sizeof(ArmStatus::session_holder_)
      - PROTOBUF_FIELD_OFFSET(ArmStatus, parking_stop_detail_)>(
          reinterpret_cast<char*>(&parking_stop_detail_),
          reinterpret_cast<char*>(&other->parking_stop_detail_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArmStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[10]);
}

// ===================================================================

class HandStatus::_Internal {
 public:
};

HandStatus::HandStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  motor_status_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HandStatus)
}
HandStatus::HandStatus(const HandStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      motor_status_(from.motor_status_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:HandStatus)
}

inline void HandStatus::SharedCtor() {
}

HandStatus::~HandStatus() {
  // @@protoc_insertion_point(destructor:HandStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HandStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HandStatus::ArenaDtor(void* object) {
  HandStatus* _this = reinterpret_cast< HandStatus* >(object);
  (void)_this;
}
void HandStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HandStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HandStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:HandStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  motor_status_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HandStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .MotorStatus motor_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_motor_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HandStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HandStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .MotorStatus motor_status = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_motor_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_motor_status(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HandStatus)
  return target;
}

size_t HandStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HandStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MotorStatus motor_status = 2;
  total_size += 1UL * this->_internal_motor_status_size();
  for (const auto& msg : this->motor_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HandStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HandStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HandStatus::GetClassData() const { return &_class_data_; }

void HandStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HandStatus *>(to)->MergeFrom(
      static_cast<const HandStatus &>(from));
}


void HandStatus::MergeFrom(const HandStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HandStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  motor_status_.MergeFrom(from.motor_status_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HandStatus::CopyFrom(const HandStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HandStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandStatus::IsInitialized() const {
  return true;
}

void HandStatus::InternalSwap(HandStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  motor_status_.InternalSwap(&other->motor_status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HandStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[11]);
}

// ===================================================================

class HandCommand::_Internal {
 public:
  static const ::MotorTargets& motor_targets(const HandCommand* msg);
};

const ::MotorTargets&
HandCommand::_Internal::motor_targets(const HandCommand* msg) {
  return *msg->motor_targets_;
}
HandCommand::HandCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HandCommand)
}
HandCommand::HandCommand(const HandCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_motor_targets()) {
    motor_targets_ = new ::MotorTargets(*from.motor_targets_);
  } else {
    motor_targets_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:HandCommand)
}

inline void HandCommand::SharedCtor() {
motor_targets_ = nullptr;
}

HandCommand::~HandCommand() {
  // @@protoc_insertion_point(destructor:HandCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HandCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete motor_targets_;
}

void HandCommand::ArenaDtor(void* object) {
  HandCommand* _this = reinterpret_cast< HandCommand* >(object);
  (void)_this;
}
void HandCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HandCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HandCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:HandCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && motor_targets_ != nullptr) {
    delete motor_targets_;
  }
  motor_targets_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HandCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .MotorTargets motor_targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_motor_targets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HandCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HandCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .MotorTargets motor_targets = 1;
  if (this->_internal_has_motor_targets()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::motor_targets(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HandCommand)
  return target;
}

size_t HandCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HandCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .MotorTargets motor_targets = 1;
  if (this->_internal_has_motor_targets()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *motor_targets_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HandCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HandCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HandCommand::GetClassData() const { return &_class_data_; }

void HandCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HandCommand *>(to)->MergeFrom(
      static_cast<const HandCommand &>(from));
}


void HandCommand::MergeFrom(const HandCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HandCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_motor_targets()) {
    _internal_mutable_motor_targets()->::MotorTargets::MergeFrom(from._internal_motor_targets());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HandCommand::CopyFrom(const HandCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HandCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandCommand::IsInitialized() const {
  return true;
}

void HandCommand::InternalSwap(HandCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(motor_targets_, other->motor_targets_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HandCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[12]);
}

// ===================================================================

class ArmApiFreeDragCommand::_Internal {
 public:
};

ArmApiFreeDragCommand::ArmApiFreeDragCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:ArmApiFreeDragCommand)
}
ArmApiFreeDragCommand::ArmApiFreeDragCommand(const ArmApiFreeDragCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ArmApiFreeDragCommand)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArmApiFreeDragCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArmApiFreeDragCommand::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ArmApiFreeDragCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[13]);
}

// ===================================================================

class ArmApiZeroCurrentCommand::_Internal {
 public:
};

ArmApiZeroCurrentCommand::ArmApiZeroCurrentCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:ArmApiZeroCurrentCommand)
}
ArmApiZeroCurrentCommand::ArmApiZeroCurrentCommand(const ArmApiZeroCurrentCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ArmApiZeroCurrentCommand)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArmApiZeroCurrentCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArmApiZeroCurrentCommand::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ArmApiZeroCurrentCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[14]);
}

// ===================================================================

class ArmApiControlCommand::_Internal {
 public:
  static const ::MotorTargets& motor_targets(const ArmApiControlCommand* msg);
  static const ::ArmApiFreeDragCommand& arm_api_free_drag_command(const ArmApiControlCommand* msg);
  static const ::ArmApiZeroCurrentCommand& arm_api_zero_current_command(const ArmApiControlCommand* msg);
};

const ::MotorTargets&
ArmApiControlCommand::_Internal::motor_targets(const ArmApiControlCommand* msg) {
  return *msg->command_.motor_targets_;
}
const ::ArmApiFreeDragCommand&
ArmApiControlCommand::_Internal::arm_api_free_drag_command(const ArmApiControlCommand* msg) {
  return *msg->command_.arm_api_free_drag_command_;
}
const ::ArmApiZeroCurrentCommand&
ArmApiControlCommand::_Internal::arm_api_zero_current_command(const ArmApiControlCommand* msg) {
  return *msg->command_.arm_api_zero_current_command_;
}
void ArmApiControlCommand::set_allocated_motor_targets(::MotorTargets* motor_targets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (motor_targets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MotorTargets>::GetOwningArena(motor_targets);
    if (message_arena != submessage_arena) {
      motor_targets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motor_targets, submessage_arena);
    }
    set_has_motor_targets();
    command_.motor_targets_ = motor_targets;
  }
  // @@protoc_insertion_point(field_set_allocated:ArmApiControlCommand.motor_targets)
}
void ArmApiControlCommand::set_allocated_arm_api_free_drag_command(::ArmApiFreeDragCommand* arm_api_free_drag_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (arm_api_free_drag_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ArmApiFreeDragCommand>::GetOwningArena(arm_api_free_drag_command);
    if (message_arena != submessage_arena) {
      arm_api_free_drag_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm_api_free_drag_command, submessage_arena);
    }
    set_has_arm_api_free_drag_command();
    command_.arm_api_free_drag_command_ = arm_api_free_drag_command;
  }
  // @@protoc_insertion_point(field_set_allocated:ArmApiControlCommand.arm_api_free_drag_command)
}
void ArmApiControlCommand::set_allocated_arm_api_zero_current_command(::ArmApiZeroCurrentCommand* arm_api_zero_current_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (arm_api_zero_current_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ArmApiZeroCurrentCommand>::GetOwningArena(arm_api_zero_current_command);
    if (message_arena != submessage_arena) {
      arm_api_zero_current_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm_api_zero_current_command, submessage_arena);
    }
    set_has_arm_api_zero_current_command();
    command_.arm_api_zero_current_command_ = arm_api_zero_current_command;
  }
  // @@protoc_insertion_point(field_set_allocated:ArmApiControlCommand.arm_api_zero_current_command)
}
ArmApiControlCommand::ArmApiControlCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ArmApiControlCommand)
}
ArmApiControlCommand::ArmApiControlCommand(const ArmApiControlCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kMotorTargets: {
      _internal_mutable_motor_targets()->::MotorTargets::MergeFrom(from._internal_motor_targets());
      break;
    }
    case kArmApiFreeDragCommand: {
      _internal_mutable_arm_api_free_drag_command()->::ArmApiFreeDragCommand::MergeFrom(from._internal_arm_api_free_drag_command());
      break;
    }
    case kArmApiZeroCurrentCommand: {
      _internal_mutable_arm_api_zero_current_command()->::ArmApiZeroCurrentCommand::MergeFrom(from._internal_arm_api_zero_current_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ArmApiControlCommand)
}

inline void ArmApiControlCommand::SharedCtor() {
clear_has_command();
}

ArmApiControlCommand::~ArmApiControlCommand() {
  // @@protoc_insertion_point(destructor:ArmApiControlCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ArmApiControlCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void ArmApiControlCommand::ArenaDtor(void* object) {
  ArmApiControlCommand* _this = reinterpret_cast< ArmApiControlCommand* >(object);
  (void)_this;
}
void ArmApiControlCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArmApiControlCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArmApiControlCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:ArmApiControlCommand)
  switch (command_case()) {
    case kMotorTargets: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.motor_targets_;
      }
      break;
    }
    case kArmApiFreeDragCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.arm_api_free_drag_command_;
      }
      break;
    }
    case kArmApiZeroCurrentCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.arm_api_zero_current_command_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void ArmApiControlCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:ArmApiControlCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArmApiControlCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .MotorTargets motor_targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_motor_targets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ArmApiFreeDragCommand arm_api_free_drag_command = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_arm_api_free_drag_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ArmApiZeroCurrentCommand arm_api_zero_current_command = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_arm_api_zero_current_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArmApiControlCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ArmApiControlCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .MotorTargets motor_targets = 1;
  if (_internal_has_motor_targets()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::motor_targets(this), target, stream);
  }

  // .ArmApiFreeDragCommand arm_api_free_drag_command = 2;
  if (_internal_has_arm_api_free_drag_command()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::arm_api_free_drag_command(this), target, stream);
  }

  // .ArmApiZeroCurrentCommand arm_api_zero_current_command = 3;
  if (_internal_has_arm_api_zero_current_command()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::arm_api_zero_current_command(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ArmApiControlCommand)
  return target;
}

size_t ArmApiControlCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ArmApiControlCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // .MotorTargets motor_targets = 1;
    case kMotorTargets: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.motor_targets_);
      break;
    }
    // .ArmApiFreeDragCommand arm_api_free_drag_command = 2;
    case kArmApiFreeDragCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.arm_api_free_drag_command_);
      break;
    }
    // .ArmApiZeroCurrentCommand arm_api_zero_current_command = 3;
    case kArmApiZeroCurrentCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.arm_api_zero_current_command_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArmApiControlCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArmApiControlCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArmApiControlCommand::GetClassData() const { return &_class_data_; }

void ArmApiControlCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArmApiControlCommand *>(to)->MergeFrom(
      static_cast<const ArmApiControlCommand &>(from));
}


void ArmApiControlCommand::MergeFrom(const ArmApiControlCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ArmApiControlCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kMotorTargets: {
      _internal_mutable_motor_targets()->::MotorTargets::MergeFrom(from._internal_motor_targets());
      break;
    }
    case kArmApiFreeDragCommand: {
      _internal_mutable_arm_api_free_drag_command()->::ArmApiFreeDragCommand::MergeFrom(from._internal_arm_api_free_drag_command());
      break;
    }
    case kArmApiZeroCurrentCommand: {
      _internal_mutable_arm_api_zero_current_command()->::ArmApiZeroCurrentCommand::MergeFrom(from._internal_arm_api_zero_current_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArmApiControlCommand::CopyFrom(const ArmApiControlCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ArmApiControlCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArmApiControlCommand::IsInitialized() const {
  return true;
}

void ArmApiControlCommand::InternalSwap(ArmApiControlCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArmApiControlCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[15]);
}

// ===================================================================

class ArmSharedCommand::_Internal {
 public:
  static const ::ParkingStopDetail& enter_parking_stop(const ArmSharedCommand* msg);
};

const ::ParkingStopDetail&
ArmSharedCommand::_Internal::enter_parking_stop(const ArmSharedCommand* msg) {
  return *msg->command_.enter_parking_stop_;
}
void ArmSharedCommand::set_allocated_enter_parking_stop(::ParkingStopDetail* enter_parking_stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (enter_parking_stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ParkingStopDetail>::GetOwningArena(enter_parking_stop);
    if (message_arena != submessage_arena) {
      enter_parking_stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enter_parking_stop, submessage_arena);
    }
    set_has_enter_parking_stop();
    command_.enter_parking_stop_ = enter_parking_stop;
  }
  // @@protoc_insertion_point(field_set_allocated:ArmSharedCommand.enter_parking_stop)
}
ArmSharedCommand::ArmSharedCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ArmSharedCommand)
}
ArmSharedCommand::ArmSharedCommand(const ArmSharedCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kClearParkingStop: {
      _internal_set_clear_parking_stop(from._internal_clear_parking_stop());
      break;
    }
    case kEnterParkingStop: {
      _internal_mutable_enter_parking_stop()->::ParkingStopDetail::MergeFrom(from._internal_enter_parking_stop());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ArmSharedCommand)
}

inline void ArmSharedCommand::SharedCtor() {
clear_has_command();
}

ArmSharedCommand::~ArmSharedCommand() {
  // @@protoc_insertion_point(destructor:ArmSharedCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ArmSharedCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void ArmSharedCommand::ArenaDtor(void* object) {
  ArmSharedCommand* _this = reinterpret_cast< ArmSharedCommand* >(object);
  (void)_this;
}
void ArmSharedCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArmSharedCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArmSharedCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:ArmSharedCommand)
  switch (command_case()) {
    case kClearParkingStop: {
      // No need to clear
      break;
    }
    case kEnterParkingStop: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.enter_parking_stop_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void ArmSharedCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:ArmSharedCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArmSharedCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool clear_parking_stop = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_clear_parking_stop(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ParkingStopDetail enter_parking_stop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_enter_parking_stop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArmSharedCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ArmSharedCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool clear_parking_stop = 1;
  if (_internal_has_clear_parking_stop()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_clear_parking_stop(), target);
  }

  // .ParkingStopDetail enter_parking_stop = 2;
  if (_internal_has_enter_parking_stop()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::enter_parking_stop(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ArmSharedCommand)
  return target;
}

size_t ArmSharedCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ArmSharedCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // bool clear_parking_stop = 1;
    case kClearParkingStop: {
      total_size += 1 + 1;
      break;
    }
    // .ParkingStopDetail enter_parking_stop = 2;
    case kEnterParkingStop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.enter_parking_stop_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArmSharedCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArmSharedCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArmSharedCommand::GetClassData() const { return &_class_data_; }

void ArmSharedCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArmSharedCommand *>(to)->MergeFrom(
      static_cast<const ArmSharedCommand &>(from));
}


void ArmSharedCommand::MergeFrom(const ArmSharedCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ArmSharedCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kClearParkingStop: {
      _internal_set_clear_parking_stop(from._internal_clear_parking_stop());
      break;
    }
    case kEnterParkingStop: {
      _internal_mutable_enter_parking_stop()->::ParkingStopDetail::MergeFrom(from._internal_enter_parking_stop());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArmSharedCommand::CopyFrom(const ArmSharedCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ArmSharedCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArmSharedCommand::IsInitialized() const {
  return true;
}

void ArmSharedCommand::InternalSwap(ArmSharedCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArmSharedCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[16]);
}

// ===================================================================

class ArmExclusiveCommand::_Internal {
 public:
  static const ::ArmApiControlCommand& arm_api_control_command(const ArmExclusiveCommand* msg);
};

const ::ArmApiControlCommand&
ArmExclusiveCommand::_Internal::arm_api_control_command(const ArmExclusiveCommand* msg) {
  return *msg->exclusive_command_.arm_api_control_command_;
}
void ArmExclusiveCommand::set_allocated_arm_api_control_command(::ArmApiControlCommand* arm_api_control_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_exclusive_command();
  if (arm_api_control_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ArmApiControlCommand>::GetOwningArena(arm_api_control_command);
    if (message_arena != submessage_arena) {
      arm_api_control_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm_api_control_command, submessage_arena);
    }
    set_has_arm_api_control_command();
    exclusive_command_.arm_api_control_command_ = arm_api_control_command;
  }
  // @@protoc_insertion_point(field_set_allocated:ArmExclusiveCommand.arm_api_control_command)
}
ArmExclusiveCommand::ArmExclusiveCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ArmExclusiveCommand)
}
ArmExclusiveCommand::ArmExclusiveCommand(const ArmExclusiveCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_exclusive_command();
  switch (from.exclusive_command_case()) {
    case kApiControlInitialize: {
      _internal_set_api_control_initialize(from._internal_api_control_initialize());
      break;
    }
    case kArmApiControlCommand: {
      _internal_mutable_arm_api_control_command()->::ArmApiControlCommand::MergeFrom(from._internal_arm_api_control_command());
      break;
    }
    case kCalibrate: {
      _internal_set_calibrate(from._internal_calibrate());
      break;
    }
    case EXCLUSIVE_COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ArmExclusiveCommand)
}

inline void ArmExclusiveCommand::SharedCtor() {
clear_has_exclusive_command();
}

ArmExclusiveCommand::~ArmExclusiveCommand() {
  // @@protoc_insertion_point(destructor:ArmExclusiveCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ArmExclusiveCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_exclusive_command()) {
    clear_exclusive_command();
  }
}

void ArmExclusiveCommand::ArenaDtor(void* object) {
  ArmExclusiveCommand* _this = reinterpret_cast< ArmExclusiveCommand* >(object);
  (void)_this;
}
void ArmExclusiveCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArmExclusiveCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArmExclusiveCommand::clear_exclusive_command() {
// @@protoc_insertion_point(one_of_clear_start:ArmExclusiveCommand)
  switch (exclusive_command_case()) {
    case kApiControlInitialize: {
      // No need to clear
      break;
    }
    case kArmApiControlCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete exclusive_command_.arm_api_control_command_;
      }
      break;
    }
    case kCalibrate: {
      // No need to clear
      break;
    }
    case EXCLUSIVE_COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = EXCLUSIVE_COMMAND_NOT_SET;
}


void ArmExclusiveCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:ArmExclusiveCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_exclusive_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArmExclusiveCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool api_control_initialize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_api_control_initialize(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool calibrate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_calibrate(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ArmApiControlCommand arm_api_control_command = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_arm_api_control_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArmExclusiveCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ArmExclusiveCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool api_control_initialize = 1;
  if (_internal_has_api_control_initialize()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_api_control_initialize(), target);
  }

  // bool calibrate = 4;
  if (_internal_has_calibrate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_calibrate(), target);
  }

  // .ArmApiControlCommand arm_api_control_command = 6;
  if (_internal_has_arm_api_control_command()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::arm_api_control_command(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ArmExclusiveCommand)
  return target;
}

size_t ArmExclusiveCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ArmExclusiveCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (exclusive_command_case()) {
    // bool api_control_initialize = 1;
    case kApiControlInitialize: {
      total_size += 1 + 1;
      break;
    }
    // .ArmApiControlCommand arm_api_control_command = 6;
    case kArmApiControlCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *exclusive_command_.arm_api_control_command_);
      break;
    }
    // bool calibrate = 4;
    case kCalibrate: {
      total_size += 1 + 1;
      break;
    }
    case EXCLUSIVE_COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArmExclusiveCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArmExclusiveCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArmExclusiveCommand::GetClassData() const { return &_class_data_; }

void ArmExclusiveCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArmExclusiveCommand *>(to)->MergeFrom(
      static_cast<const ArmExclusiveCommand &>(from));
}


void ArmExclusiveCommand::MergeFrom(const ArmExclusiveCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ArmExclusiveCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.exclusive_command_case()) {
    case kApiControlInitialize: {
      _internal_set_api_control_initialize(from._internal_api_control_initialize());
      break;
    }
    case kArmApiControlCommand: {
      _internal_mutable_arm_api_control_command()->::ArmApiControlCommand::MergeFrom(from._internal_arm_api_control_command());
      break;
    }
    case kCalibrate: {
      _internal_set_calibrate(from._internal_calibrate());
      break;
    }
    case EXCLUSIVE_COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArmExclusiveCommand::CopyFrom(const ArmExclusiveCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ArmExclusiveCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArmExclusiveCommand::IsInitialized() const {
  return true;
}

void ArmExclusiveCommand::InternalSwap(ArmExclusiveCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(exclusive_command_, other->exclusive_command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArmExclusiveCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[17]);
}

// ===================================================================

class ArmCommand::_Internal {
 public:
  static const ::ArmExclusiveCommand& arm_exclusive_command(const ArmCommand* msg);
  static const ::ArmSharedCommand& arm_shared_command(const ArmCommand* msg);
};

const ::ArmExclusiveCommand&
ArmCommand::_Internal::arm_exclusive_command(const ArmCommand* msg) {
  return *msg->command_.arm_exclusive_command_;
}
const ::ArmSharedCommand&
ArmCommand::_Internal::arm_shared_command(const ArmCommand* msg) {
  return *msg->command_.arm_shared_command_;
}
void ArmCommand::set_allocated_arm_exclusive_command(::ArmExclusiveCommand* arm_exclusive_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (arm_exclusive_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ArmExclusiveCommand>::GetOwningArena(arm_exclusive_command);
    if (message_arena != submessage_arena) {
      arm_exclusive_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm_exclusive_command, submessage_arena);
    }
    set_has_arm_exclusive_command();
    command_.arm_exclusive_command_ = arm_exclusive_command;
  }
  // @@protoc_insertion_point(field_set_allocated:ArmCommand.arm_exclusive_command)
}
void ArmCommand::set_allocated_arm_shared_command(::ArmSharedCommand* arm_shared_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (arm_shared_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ArmSharedCommand>::GetOwningArena(arm_shared_command);
    if (message_arena != submessage_arena) {
      arm_shared_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arm_shared_command, submessage_arena);
    }
    set_has_arm_shared_command();
    command_.arm_shared_command_ = arm_shared_command;
  }
  // @@protoc_insertion_point(field_set_allocated:ArmCommand.arm_shared_command)
}
ArmCommand::ArmCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ArmCommand)
}
ArmCommand::ArmCommand(const ArmCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kArmExclusiveCommand: {
      _internal_mutable_arm_exclusive_command()->::ArmExclusiveCommand::MergeFrom(from._internal_arm_exclusive_command());
      break;
    }
    case kArmSharedCommand: {
      _internal_mutable_arm_shared_command()->::ArmSharedCommand::MergeFrom(from._internal_arm_shared_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ArmCommand)
}

inline void ArmCommand::SharedCtor() {
clear_has_command();
}

ArmCommand::~ArmCommand() {
  // @@protoc_insertion_point(destructor:ArmCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ArmCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void ArmCommand::ArenaDtor(void* object) {
  ArmCommand* _this = reinterpret_cast< ArmCommand* >(object);
  (void)_this;
}
void ArmCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ArmCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ArmCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:ArmCommand)
  switch (command_case()) {
    case kArmExclusiveCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.arm_exclusive_command_;
      }
      break;
    }
    case kArmSharedCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.arm_shared_command_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void ArmCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:ArmCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArmCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .ArmExclusiveCommand arm_exclusive_command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_arm_exclusive_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ArmSharedCommand arm_shared_command = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_arm_shared_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArmCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ArmCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .ArmExclusiveCommand arm_exclusive_command = 1;
  if (_internal_has_arm_exclusive_command()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::arm_exclusive_command(this), target, stream);
  }

  // .ArmSharedCommand arm_shared_command = 2;
  if (_internal_has_arm_shared_command()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::arm_shared_command(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ArmCommand)
  return target;
}

size_t ArmCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ArmCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // .ArmExclusiveCommand arm_exclusive_command = 1;
    case kArmExclusiveCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.arm_exclusive_command_);
      break;
    }
    // .ArmSharedCommand arm_shared_command = 2;
    case kArmSharedCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.arm_shared_command_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArmCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ArmCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArmCommand::GetClassData() const { return &_class_data_; }

void ArmCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ArmCommand *>(to)->MergeFrom(
      static_cast<const ArmCommand &>(from));
}


void ArmCommand::MergeFrom(const ArmCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ArmCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kArmExclusiveCommand: {
      _internal_mutable_arm_exclusive_command()->::ArmExclusiveCommand::MergeFrom(from._internal_arm_exclusive_command());
      break;
    }
    case kArmSharedCommand: {
      _internal_mutable_arm_shared_command()->::ArmSharedCommand::MergeFrom(from._internal_arm_shared_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArmCommand::CopyFrom(const ArmCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ArmCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArmCommand::IsInitialized() const {
  return true;
}

void ArmCommand::InternalSwap(ArmCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ArmCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[18]);
}

// ===================================================================

class GamepadRead::_Internal {
 public:
};

GamepadRead::GamepadRead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GamepadRead)
}
GamepadRead::GamepadRead(const GamepadRead& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&left_stick_x_, &from.left_stick_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&dpad_right_) -
    reinterpret_cast<char*>(&left_stick_x_)) + sizeof(dpad_right_));
  // @@protoc_insertion_point(copy_constructor:GamepadRead)
}

inline void GamepadRead::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&left_stick_x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dpad_right_) -
    reinterpret_cast<char*>(&left_stick_x_)) + sizeof(dpad_right_));
}

GamepadRead::~GamepadRead() {
  // @@protoc_insertion_point(destructor:GamepadRead)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GamepadRead::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GamepadRead::ArenaDtor(void* object) {
  GamepadRead* _this = reinterpret_cast< GamepadRead* >(object);
  (void)_this;
}
void GamepadRead::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GamepadRead::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GamepadRead::Clear() {
// @@protoc_insertion_point(message_clear_start:GamepadRead)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&left_stick_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dpad_right_) -
      reinterpret_cast<char*>(&left_stick_x_)) + sizeof(dpad_right_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GamepadRead::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float left_stick_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          left_stick_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float left_stick_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          left_stick_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float right_stick_x = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          right_stick_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float right_stick_y = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          right_stick_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool left_bumper = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          left_bumper_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool right_bumper = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          right_bumper_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float left_trigger = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          left_trigger_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float right_trigger = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          right_trigger_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool a_button = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          a_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool b_button = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          b_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool x_button = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          x_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool y_button = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          y_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool select_button = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          select_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool start_button = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          start_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool left_stick_button = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          left_stick_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool right_stick_button = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          right_stick_button_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool dpad_up = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          dpad_up_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool dpad_down = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          dpad_down_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool dpad_left = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          dpad_left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool dpad_right = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          dpad_right_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GamepadRead::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GamepadRead)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float left_stick_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_stick_x = this->_internal_left_stick_x();
  uint32_t raw_left_stick_x;
  memcpy(&raw_left_stick_x, &tmp_left_stick_x, sizeof(tmp_left_stick_x));
  if (raw_left_stick_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_left_stick_x(), target);
  }

  // float left_stick_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_stick_y = this->_internal_left_stick_y();
  uint32_t raw_left_stick_y;
  memcpy(&raw_left_stick_y, &tmp_left_stick_y, sizeof(tmp_left_stick_y));
  if (raw_left_stick_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_left_stick_y(), target);
  }

  // float right_stick_x = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_stick_x = this->_internal_right_stick_x();
  uint32_t raw_right_stick_x;
  memcpy(&raw_right_stick_x, &tmp_right_stick_x, sizeof(tmp_right_stick_x));
  if (raw_right_stick_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_right_stick_x(), target);
  }

  // float right_stick_y = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_stick_y = this->_internal_right_stick_y();
  uint32_t raw_right_stick_y;
  memcpy(&raw_right_stick_y, &tmp_right_stick_y, sizeof(tmp_right_stick_y));
  if (raw_right_stick_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_right_stick_y(), target);
  }

  // bool left_bumper = 5;
  if (this->_internal_left_bumper() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_left_bumper(), target);
  }

  // bool right_bumper = 6;
  if (this->_internal_right_bumper() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_right_bumper(), target);
  }

  // float left_trigger = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_trigger = this->_internal_left_trigger();
  uint32_t raw_left_trigger;
  memcpy(&raw_left_trigger, &tmp_left_trigger, sizeof(tmp_left_trigger));
  if (raw_left_trigger != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_left_trigger(), target);
  }

  // float right_trigger = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_trigger = this->_internal_right_trigger();
  uint32_t raw_right_trigger;
  memcpy(&raw_right_trigger, &tmp_right_trigger, sizeof(tmp_right_trigger));
  if (raw_right_trigger != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_right_trigger(), target);
  }

  // bool a_button = 9;
  if (this->_internal_a_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_a_button(), target);
  }

  // bool b_button = 10;
  if (this->_internal_b_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_b_button(), target);
  }

  // bool x_button = 11;
  if (this->_internal_x_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_x_button(), target);
  }

  // bool y_button = 12;
  if (this->_internal_y_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_y_button(), target);
  }

  // bool select_button = 13;
  if (this->_internal_select_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_select_button(), target);
  }

  // bool start_button = 14;
  if (this->_internal_start_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_start_button(), target);
  }

  // bool left_stick_button = 15;
  if (this->_internal_left_stick_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_left_stick_button(), target);
  }

  // bool right_stick_button = 16;
  if (this->_internal_right_stick_button() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_right_stick_button(), target);
  }

  // bool dpad_up = 17;
  if (this->_internal_dpad_up() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_dpad_up(), target);
  }

  // bool dpad_down = 18;
  if (this->_internal_dpad_down() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_dpad_down(), target);
  }

  // bool dpad_left = 19;
  if (this->_internal_dpad_left() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_dpad_left(), target);
  }

  // bool dpad_right = 20;
  if (this->_internal_dpad_right() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_dpad_right(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GamepadRead)
  return target;
}

size_t GamepadRead::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GamepadRead)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float left_stick_x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_stick_x = this->_internal_left_stick_x();
  uint32_t raw_left_stick_x;
  memcpy(&raw_left_stick_x, &tmp_left_stick_x, sizeof(tmp_left_stick_x));
  if (raw_left_stick_x != 0) {
    total_size += 1 + 4;
  }

  // float left_stick_y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_stick_y = this->_internal_left_stick_y();
  uint32_t raw_left_stick_y;
  memcpy(&raw_left_stick_y, &tmp_left_stick_y, sizeof(tmp_left_stick_y));
  if (raw_left_stick_y != 0) {
    total_size += 1 + 4;
  }

  // float right_stick_x = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_stick_x = this->_internal_right_stick_x();
  uint32_t raw_right_stick_x;
  memcpy(&raw_right_stick_x, &tmp_right_stick_x, sizeof(tmp_right_stick_x));
  if (raw_right_stick_x != 0) {
    total_size += 1 + 4;
  }

  // float right_stick_y = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_stick_y = this->_internal_right_stick_y();
  uint32_t raw_right_stick_y;
  memcpy(&raw_right_stick_y, &tmp_right_stick_y, sizeof(tmp_right_stick_y));
  if (raw_right_stick_y != 0) {
    total_size += 1 + 4;
  }

  // float left_trigger = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_trigger = this->_internal_left_trigger();
  uint32_t raw_left_trigger;
  memcpy(&raw_left_trigger, &tmp_left_trigger, sizeof(tmp_left_trigger));
  if (raw_left_trigger != 0) {
    total_size += 1 + 4;
  }

  // bool left_bumper = 5;
  if (this->_internal_left_bumper() != 0) {
    total_size += 1 + 1;
  }

  // bool right_bumper = 6;
  if (this->_internal_right_bumper() != 0) {
    total_size += 1 + 1;
  }

  // bool a_button = 9;
  if (this->_internal_a_button() != 0) {
    total_size += 1 + 1;
  }

  // bool b_button = 10;
  if (this->_internal_b_button() != 0) {
    total_size += 1 + 1;
  }

  // float right_trigger = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_trigger = this->_internal_right_trigger();
  uint32_t raw_right_trigger;
  memcpy(&raw_right_trigger, &tmp_right_trigger, sizeof(tmp_right_trigger));
  if (raw_right_trigger != 0) {
    total_size += 1 + 4;
  }

  // bool x_button = 11;
  if (this->_internal_x_button() != 0) {
    total_size += 1 + 1;
  }

  // bool y_button = 12;
  if (this->_internal_y_button() != 0) {
    total_size += 1 + 1;
  }

  // bool select_button = 13;
  if (this->_internal_select_button() != 0) {
    total_size += 1 + 1;
  }

  // bool start_button = 14;
  if (this->_internal_start_button() != 0) {
    total_size += 1 + 1;
  }

  // bool left_stick_button = 15;
  if (this->_internal_left_stick_button() != 0) {
    total_size += 1 + 1;
  }

  // bool right_stick_button = 16;
  if (this->_internal_right_stick_button() != 0) {
    total_size += 2 + 1;
  }

  // bool dpad_up = 17;
  if (this->_internal_dpad_up() != 0) {
    total_size += 2 + 1;
  }

  // bool dpad_down = 18;
  if (this->_internal_dpad_down() != 0) {
    total_size += 2 + 1;
  }

  // bool dpad_left = 19;
  if (this->_internal_dpad_left() != 0) {
    total_size += 2 + 1;
  }

  // bool dpad_right = 20;
  if (this->_internal_dpad_right() != 0) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GamepadRead::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GamepadRead::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GamepadRead::GetClassData() const { return &_class_data_; }

void GamepadRead::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GamepadRead *>(to)->MergeFrom(
      static_cast<const GamepadRead &>(from));
}


void GamepadRead::MergeFrom(const GamepadRead& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GamepadRead)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_stick_x = from._internal_left_stick_x();
  uint32_t raw_left_stick_x;
  memcpy(&raw_left_stick_x, &tmp_left_stick_x, sizeof(tmp_left_stick_x));
  if (raw_left_stick_x != 0) {
    _internal_set_left_stick_x(from._internal_left_stick_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_stick_y = from._internal_left_stick_y();
  uint32_t raw_left_stick_y;
  memcpy(&raw_left_stick_y, &tmp_left_stick_y, sizeof(tmp_left_stick_y));
  if (raw_left_stick_y != 0) {
    _internal_set_left_stick_y(from._internal_left_stick_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_stick_x = from._internal_right_stick_x();
  uint32_t raw_right_stick_x;
  memcpy(&raw_right_stick_x, &tmp_right_stick_x, sizeof(tmp_right_stick_x));
  if (raw_right_stick_x != 0) {
    _internal_set_right_stick_x(from._internal_right_stick_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_stick_y = from._internal_right_stick_y();
  uint32_t raw_right_stick_y;
  memcpy(&raw_right_stick_y, &tmp_right_stick_y, sizeof(tmp_right_stick_y));
  if (raw_right_stick_y != 0) {
    _internal_set_right_stick_y(from._internal_right_stick_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left_trigger = from._internal_left_trigger();
  uint32_t raw_left_trigger;
  memcpy(&raw_left_trigger, &tmp_left_trigger, sizeof(tmp_left_trigger));
  if (raw_left_trigger != 0) {
    _internal_set_left_trigger(from._internal_left_trigger());
  }
  if (from._internal_left_bumper() != 0) {
    _internal_set_left_bumper(from._internal_left_bumper());
  }
  if (from._internal_right_bumper() != 0) {
    _internal_set_right_bumper(from._internal_right_bumper());
  }
  if (from._internal_a_button() != 0) {
    _internal_set_a_button(from._internal_a_button());
  }
  if (from._internal_b_button() != 0) {
    _internal_set_b_button(from._internal_b_button());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right_trigger = from._internal_right_trigger();
  uint32_t raw_right_trigger;
  memcpy(&raw_right_trigger, &tmp_right_trigger, sizeof(tmp_right_trigger));
  if (raw_right_trigger != 0) {
    _internal_set_right_trigger(from._internal_right_trigger());
  }
  if (from._internal_x_button() != 0) {
    _internal_set_x_button(from._internal_x_button());
  }
  if (from._internal_y_button() != 0) {
    _internal_set_y_button(from._internal_y_button());
  }
  if (from._internal_select_button() != 0) {
    _internal_set_select_button(from._internal_select_button());
  }
  if (from._internal_start_button() != 0) {
    _internal_set_start_button(from._internal_start_button());
  }
  if (from._internal_left_stick_button() != 0) {
    _internal_set_left_stick_button(from._internal_left_stick_button());
  }
  if (from._internal_right_stick_button() != 0) {
    _internal_set_right_stick_button(from._internal_right_stick_button());
  }
  if (from._internal_dpad_up() != 0) {
    _internal_set_dpad_up(from._internal_dpad_up());
  }
  if (from._internal_dpad_down() != 0) {
    _internal_set_dpad_down(from._internal_dpad_down());
  }
  if (from._internal_dpad_left() != 0) {
    _internal_set_dpad_left(from._internal_dpad_left());
  }
  if (from._internal_dpad_right() != 0) {
    _internal_set_dpad_right(from._internal_dpad_right());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GamepadRead::CopyFrom(const GamepadRead& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GamepadRead)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GamepadRead::IsInitialized() const {
  return true;
}

void GamepadRead::InternalSwap(GamepadRead* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GamepadRead, dpad_right_)
      + sizeof(GamepadRead::dpad_right_)
      - PROTOBUF_FIELD_OFFSET(GamepadRead, left_stick_x_)>(
          reinterpret_cast<char*>(&left_stick_x_),
          reinterpret_cast<char*>(&other->left_stick_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GamepadRead::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[19]);
}

// ===================================================================

class EnableKcp::_Internal {
 public:
  static const ::KcpConfig& kcp_config(const EnableKcp* msg);
};

const ::KcpConfig&
EnableKcp::_Internal::kcp_config(const EnableKcp* msg) {
  return *msg->kcp_config_;
}
EnableKcp::EnableKcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:EnableKcp)
}
EnableKcp::EnableKcp(const EnableKcp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_kcp_config()) {
    kcp_config_ = new ::KcpConfig(*from.kcp_config_);
  } else {
    kcp_config_ = nullptr;
  }
  client_peer_port_ = from.client_peer_port_;
  // @@protoc_insertion_point(copy_constructor:EnableKcp)
}

inline void EnableKcp::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&kcp_config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_peer_port_) -
    reinterpret_cast<char*>(&kcp_config_)) + sizeof(client_peer_port_));
}

EnableKcp::~EnableKcp() {
  // @@protoc_insertion_point(destructor:EnableKcp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EnableKcp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete kcp_config_;
}

void EnableKcp::ArenaDtor(void* object) {
  EnableKcp* _this = reinterpret_cast< EnableKcp* >(object);
  (void)_this;
}
void EnableKcp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EnableKcp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EnableKcp::Clear() {
// @@protoc_insertion_point(message_clear_start:EnableKcp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && kcp_config_ != nullptr) {
    delete kcp_config_;
  }
  kcp_config_ = nullptr;
  client_peer_port_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnableKcp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 client_peer_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          client_peer_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .KcpConfig kcp_config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_kcp_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnableKcp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EnableKcp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 client_peer_port = 1;
  if (this->_internal_client_peer_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_client_peer_port(), target);
  }

  // .KcpConfig kcp_config = 2;
  if (this->_internal_has_kcp_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::kcp_config(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EnableKcp)
  return target;
}

size_t EnableKcp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EnableKcp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .KcpConfig kcp_config = 2;
  if (this->_internal_has_kcp_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *kcp_config_);
  }

  // uint32 client_peer_port = 1;
  if (this->_internal_client_peer_port() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_client_peer_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnableKcp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EnableKcp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnableKcp::GetClassData() const { return &_class_data_; }

void EnableKcp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EnableKcp *>(to)->MergeFrom(
      static_cast<const EnableKcp &>(from));
}


void EnableKcp::MergeFrom(const EnableKcp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:EnableKcp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_kcp_config()) {
    _internal_mutable_kcp_config()->::KcpConfig::MergeFrom(from._internal_kcp_config());
  }
  if (from._internal_client_peer_port() != 0) {
    _internal_set_client_peer_port(from._internal_client_peer_port());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnableKcp::CopyFrom(const EnableKcp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EnableKcp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnableKcp::IsInitialized() const {
  return true;
}

void EnableKcp::InternalSwap(EnableKcp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnableKcp, client_peer_port_)
      + sizeof(EnableKcp::client_peer_port_)
      - PROTOBUF_FIELD_OFFSET(EnableKcp, kcp_config_)>(
          reinterpret_cast<char*>(&kcp_config_),
          reinterpret_cast<char*>(&other->kcp_config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EnableKcp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[20]);
}

// ===================================================================

class KcpServerStatus::_Internal {
 public:
  static const ::KcpConfig& kcp_config(const KcpServerStatus* msg);
};

const ::KcpConfig&
KcpServerStatus::_Internal::kcp_config(const KcpServerStatus* msg) {
  return *msg->kcp_config_;
}
KcpServerStatus::KcpServerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:KcpServerStatus)
}
KcpServerStatus::KcpServerStatus(const KcpServerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_kcp_config()) {
    kcp_config_ = new ::KcpConfig(*from.kcp_config_);
  } else {
    kcp_config_ = nullptr;
  }
  server_port_ = from.server_port_;
  // @@protoc_insertion_point(copy_constructor:KcpServerStatus)
}

inline void KcpServerStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&kcp_config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&server_port_) -
    reinterpret_cast<char*>(&kcp_config_)) + sizeof(server_port_));
}

KcpServerStatus::~KcpServerStatus() {
  // @@protoc_insertion_point(destructor:KcpServerStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KcpServerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete kcp_config_;
}

void KcpServerStatus::ArenaDtor(void* object) {
  KcpServerStatus* _this = reinterpret_cast< KcpServerStatus* >(object);
  (void)_this;
}
void KcpServerStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KcpServerStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KcpServerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:KcpServerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && kcp_config_ != nullptr) {
    delete kcp_config_;
  }
  kcp_config_ = nullptr;
  server_port_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KcpServerStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 server_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          server_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .KcpConfig kcp_config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_kcp_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KcpServerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:KcpServerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 server_port = 1;
  if (this->_internal_server_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_server_port(), target);
  }

  // .KcpConfig kcp_config = 2;
  if (this->_internal_has_kcp_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::kcp_config(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:KcpServerStatus)
  return target;
}

size_t KcpServerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:KcpServerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .KcpConfig kcp_config = 2;
  if (this->_internal_has_kcp_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *kcp_config_);
  }

  // uint32 server_port = 1;
  if (this->_internal_server_port() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_server_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KcpServerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KcpServerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KcpServerStatus::GetClassData() const { return &_class_data_; }

void KcpServerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KcpServerStatus *>(to)->MergeFrom(
      static_cast<const KcpServerStatus &>(from));
}


void KcpServerStatus::MergeFrom(const KcpServerStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:KcpServerStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_kcp_config()) {
    _internal_mutable_kcp_config()->::KcpConfig::MergeFrom(from._internal_kcp_config());
  }
  if (from._internal_server_port() != 0) {
    _internal_set_server_port(from._internal_server_port());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KcpServerStatus::CopyFrom(const KcpServerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KcpServerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KcpServerStatus::IsInitialized() const {
  return true;
}

void KcpServerStatus::InternalSwap(KcpServerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KcpServerStatus, server_port_)
      + sizeof(KcpServerStatus::server_port_)
      - PROTOBUF_FIELD_OFFSET(KcpServerStatus, kcp_config_)>(
          reinterpret_cast<char*>(&kcp_config_),
          reinterpret_cast<char*>(&other->kcp_config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KcpServerStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[21]);
}

// ===================================================================

class KcpConfig::_Internal {
 public:
};

KcpConfig::KcpConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:KcpConfig)
}
KcpConfig::KcpConfig(const KcpConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&window_size_snd_wnd_, &from.window_size_snd_wnd_,
    static_cast<size_t>(reinterpret_cast<char*>(&resend_) -
    reinterpret_cast<char*>(&window_size_snd_wnd_)) + sizeof(resend_));
  // @@protoc_insertion_point(copy_constructor:KcpConfig)
}

inline void KcpConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&window_size_snd_wnd_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&resend_) -
    reinterpret_cast<char*>(&window_size_snd_wnd_)) + sizeof(resend_));
}

KcpConfig::~KcpConfig() {
  // @@protoc_insertion_point(destructor:KcpConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KcpConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KcpConfig::ArenaDtor(void* object) {
  KcpConfig* _this = reinterpret_cast< KcpConfig* >(object);
  (void)_this;
}
void KcpConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KcpConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KcpConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:KcpConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&window_size_snd_wnd_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&resend_) -
      reinterpret_cast<char*>(&window_size_snd_wnd_)) + sizeof(resend_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KcpConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 window_size_snd_wnd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          window_size_snd_wnd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 window_size_rcv_wnd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          window_size_rcv_wnd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 interval_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool no_delay = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          no_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool nc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          nc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 resend = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          resend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KcpConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:KcpConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 window_size_snd_wnd = 1;
  if (this->_internal_window_size_snd_wnd() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_window_size_snd_wnd(), target);
  }

  // int32 window_size_rcv_wnd = 2;
  if (this->_internal_window_size_rcv_wnd() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_window_size_rcv_wnd(), target);
  }

  // int32 interval_ms = 3;
  if (this->_internal_interval_ms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_interval_ms(), target);
  }

  // bool no_delay = 4;
  if (this->_internal_no_delay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_no_delay(), target);
  }

  // bool nc = 5;
  if (this->_internal_nc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_nc(), target);
  }

  // int32 resend = 6;
  if (this->_internal_resend() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_resend(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:KcpConfig)
  return target;
}

size_t KcpConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:KcpConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 window_size_snd_wnd = 1;
  if (this->_internal_window_size_snd_wnd() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_window_size_snd_wnd());
  }

  // int32 window_size_rcv_wnd = 2;
  if (this->_internal_window_size_rcv_wnd() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_window_size_rcv_wnd());
  }

  // int32 interval_ms = 3;
  if (this->_internal_interval_ms() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_interval_ms());
  }

  // bool no_delay = 4;
  if (this->_internal_no_delay() != 0) {
    total_size += 1 + 1;
  }

  // bool nc = 5;
  if (this->_internal_nc() != 0) {
    total_size += 1 + 1;
  }

  // int32 resend = 6;
  if (this->_internal_resend() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_resend());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KcpConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KcpConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KcpConfig::GetClassData() const { return &_class_data_; }

void KcpConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KcpConfig *>(to)->MergeFrom(
      static_cast<const KcpConfig &>(from));
}


void KcpConfig::MergeFrom(const KcpConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:KcpConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_window_size_snd_wnd() != 0) {
    _internal_set_window_size_snd_wnd(from._internal_window_size_snd_wnd());
  }
  if (from._internal_window_size_rcv_wnd() != 0) {
    _internal_set_window_size_rcv_wnd(from._internal_window_size_rcv_wnd());
  }
  if (from._internal_interval_ms() != 0) {
    _internal_set_interval_ms(from._internal_interval_ms());
  }
  if (from._internal_no_delay() != 0) {
    _internal_set_no_delay(from._internal_no_delay());
  }
  if (from._internal_nc() != 0) {
    _internal_set_nc(from._internal_nc());
  }
  if (from._internal_resend() != 0) {
    _internal_set_resend(from._internal_resend());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KcpConfig::CopyFrom(const KcpConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KcpConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KcpConfig::IsInitialized() const {
  return true;
}

void KcpConfig::InternalSwap(KcpConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KcpConfig, resend_)
      + sizeof(KcpConfig::resend_)
      - PROTOBUF_FIELD_OFFSET(KcpConfig, window_size_snd_wnd_)>(
          reinterpret_cast<char*>(&window_size_snd_wnd_),
          reinterpret_cast<char*>(&other->window_size_snd_wnd_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KcpConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[22]);
}

// ===================================================================

class ImuAcceleration::_Internal {
 public:
};

ImuAcceleration::ImuAcceleration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ImuAcceleration)
}
ImuAcceleration::ImuAcceleration(const ImuAcceleration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ax_, &from.ax_,
    static_cast<size_t>(reinterpret_cast<char*>(&az_) -
    reinterpret_cast<char*>(&ax_)) + sizeof(az_));
  // @@protoc_insertion_point(copy_constructor:ImuAcceleration)
}

inline void ImuAcceleration::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ax_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&az_) -
    reinterpret_cast<char*>(&ax_)) + sizeof(az_));
}

ImuAcceleration::~ImuAcceleration() {
  // @@protoc_insertion_point(destructor:ImuAcceleration)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ImuAcceleration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImuAcceleration::ArenaDtor(void* object) {
  ImuAcceleration* _this = reinterpret_cast< ImuAcceleration* >(object);
  (void)_this;
}
void ImuAcceleration::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImuAcceleration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImuAcceleration::Clear() {
// @@protoc_insertion_point(message_clear_start:ImuAcceleration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ax_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&az_) -
      reinterpret_cast<char*>(&ax_)) + sizeof(az_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImuAcceleration::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float ax = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float ay = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          ay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float az = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          az_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImuAcceleration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ImuAcceleration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float ax = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ax = this->_internal_ax();
  uint32_t raw_ax;
  memcpy(&raw_ax, &tmp_ax, sizeof(tmp_ax));
  if (raw_ax != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_ax(), target);
  }

  // float ay = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ay = this->_internal_ay();
  uint32_t raw_ay;
  memcpy(&raw_ay, &tmp_ay, sizeof(tmp_ay));
  if (raw_ay != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_ay(), target);
  }

  // float az = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_az = this->_internal_az();
  uint32_t raw_az;
  memcpy(&raw_az, &tmp_az, sizeof(tmp_az));
  if (raw_az != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_az(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ImuAcceleration)
  return target;
}

size_t ImuAcceleration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ImuAcceleration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float ax = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ax = this->_internal_ax();
  uint32_t raw_ax;
  memcpy(&raw_ax, &tmp_ax, sizeof(tmp_ax));
  if (raw_ax != 0) {
    total_size += 1 + 4;
  }

  // float ay = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ay = this->_internal_ay();
  uint32_t raw_ay;
  memcpy(&raw_ay, &tmp_ay, sizeof(tmp_ay));
  if (raw_ay != 0) {
    total_size += 1 + 4;
  }

  // float az = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_az = this->_internal_az();
  uint32_t raw_az;
  memcpy(&raw_az, &tmp_az, sizeof(tmp_az));
  if (raw_az != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImuAcceleration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ImuAcceleration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImuAcceleration::GetClassData() const { return &_class_data_; }

void ImuAcceleration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ImuAcceleration *>(to)->MergeFrom(
      static_cast<const ImuAcceleration &>(from));
}


void ImuAcceleration::MergeFrom(const ImuAcceleration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ImuAcceleration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ax = from._internal_ax();
  uint32_t raw_ax;
  memcpy(&raw_ax, &tmp_ax, sizeof(tmp_ax));
  if (raw_ax != 0) {
    _internal_set_ax(from._internal_ax());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_ay = from._internal_ay();
  uint32_t raw_ay;
  memcpy(&raw_ay, &tmp_ay, sizeof(tmp_ay));
  if (raw_ay != 0) {
    _internal_set_ay(from._internal_ay());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_az = from._internal_az();
  uint32_t raw_az;
  memcpy(&raw_az, &tmp_az, sizeof(tmp_az));
  if (raw_az != 0) {
    _internal_set_az(from._internal_az());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImuAcceleration::CopyFrom(const ImuAcceleration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ImuAcceleration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuAcceleration::IsInitialized() const {
  return true;
}

void ImuAcceleration::InternalSwap(ImuAcceleration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImuAcceleration, az_)
      + sizeof(ImuAcceleration::az_)
      - PROTOBUF_FIELD_OFFSET(ImuAcceleration, ax_)>(
          reinterpret_cast<char*>(&ax_),
          reinterpret_cast<char*>(&other->ax_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImuAcceleration::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[23]);
}

// ===================================================================

class ImuAngularVelocity::_Internal {
 public:
};

ImuAngularVelocity::ImuAngularVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ImuAngularVelocity)
}
ImuAngularVelocity::ImuAngularVelocity(const ImuAngularVelocity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&wx_, &from.wx_,
    static_cast<size_t>(reinterpret_cast<char*>(&wz_) -
    reinterpret_cast<char*>(&wx_)) + sizeof(wz_));
  // @@protoc_insertion_point(copy_constructor:ImuAngularVelocity)
}

inline void ImuAngularVelocity::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&wx_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&wz_) -
    reinterpret_cast<char*>(&wx_)) + sizeof(wz_));
}

ImuAngularVelocity::~ImuAngularVelocity() {
  // @@protoc_insertion_point(destructor:ImuAngularVelocity)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ImuAngularVelocity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImuAngularVelocity::ArenaDtor(void* object) {
  ImuAngularVelocity* _this = reinterpret_cast< ImuAngularVelocity* >(object);
  (void)_this;
}
void ImuAngularVelocity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImuAngularVelocity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImuAngularVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:ImuAngularVelocity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&wx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&wz_) -
      reinterpret_cast<char*>(&wx_)) + sizeof(wz_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImuAngularVelocity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float wx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          wx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float wy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          wy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float wz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          wz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImuAngularVelocity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ImuAngularVelocity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float wx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wx = this->_internal_wx();
  uint32_t raw_wx;
  memcpy(&raw_wx, &tmp_wx, sizeof(tmp_wx));
  if (raw_wx != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_wx(), target);
  }

  // float wy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wy = this->_internal_wy();
  uint32_t raw_wy;
  memcpy(&raw_wy, &tmp_wy, sizeof(tmp_wy));
  if (raw_wy != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_wy(), target);
  }

  // float wz = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wz = this->_internal_wz();
  uint32_t raw_wz;
  memcpy(&raw_wz, &tmp_wz, sizeof(tmp_wz));
  if (raw_wz != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_wz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ImuAngularVelocity)
  return target;
}

size_t ImuAngularVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ImuAngularVelocity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float wx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wx = this->_internal_wx();
  uint32_t raw_wx;
  memcpy(&raw_wx, &tmp_wx, sizeof(tmp_wx));
  if (raw_wx != 0) {
    total_size += 1 + 4;
  }

  // float wy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wy = this->_internal_wy();
  uint32_t raw_wy;
  memcpy(&raw_wy, &tmp_wy, sizeof(tmp_wy));
  if (raw_wy != 0) {
    total_size += 1 + 4;
  }

  // float wz = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wz = this->_internal_wz();
  uint32_t raw_wz;
  memcpy(&raw_wz, &tmp_wz, sizeof(tmp_wz));
  if (raw_wz != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImuAngularVelocity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ImuAngularVelocity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImuAngularVelocity::GetClassData() const { return &_class_data_; }

void ImuAngularVelocity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ImuAngularVelocity *>(to)->MergeFrom(
      static_cast<const ImuAngularVelocity &>(from));
}


void ImuAngularVelocity::MergeFrom(const ImuAngularVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ImuAngularVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wx = from._internal_wx();
  uint32_t raw_wx;
  memcpy(&raw_wx, &tmp_wx, sizeof(tmp_wx));
  if (raw_wx != 0) {
    _internal_set_wx(from._internal_wx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wy = from._internal_wy();
  uint32_t raw_wy;
  memcpy(&raw_wy, &tmp_wy, sizeof(tmp_wy));
  if (raw_wy != 0) {
    _internal_set_wy(from._internal_wy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_wz = from._internal_wz();
  uint32_t raw_wz;
  memcpy(&raw_wz, &tmp_wz, sizeof(tmp_wz));
  if (raw_wz != 0) {
    _internal_set_wz(from._internal_wz());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImuAngularVelocity::CopyFrom(const ImuAngularVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ImuAngularVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuAngularVelocity::IsInitialized() const {
  return true;
}

void ImuAngularVelocity::InternalSwap(ImuAngularVelocity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImuAngularVelocity, wz_)
      + sizeof(ImuAngularVelocity::wz_)
      - PROTOBUF_FIELD_OFFSET(ImuAngularVelocity, wx_)>(
          reinterpret_cast<char*>(&wx_),
          reinterpret_cast<char*>(&other->wx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImuAngularVelocity::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[24]);
}

// ===================================================================

class ImuQuaternion::_Internal {
 public:
};

ImuQuaternion::ImuQuaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ImuQuaternion)
}
ImuQuaternion::ImuQuaternion(const ImuQuaternion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&qx_, &from.qx_,
    static_cast<size_t>(reinterpret_cast<char*>(&qw_) -
    reinterpret_cast<char*>(&qx_)) + sizeof(qw_));
  // @@protoc_insertion_point(copy_constructor:ImuQuaternion)
}

inline void ImuQuaternion::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&qx_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&qw_) -
    reinterpret_cast<char*>(&qx_)) + sizeof(qw_));
}

ImuQuaternion::~ImuQuaternion() {
  // @@protoc_insertion_point(destructor:ImuQuaternion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ImuQuaternion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImuQuaternion::ArenaDtor(void* object) {
  ImuQuaternion* _this = reinterpret_cast< ImuQuaternion* >(object);
  (void)_this;
}
void ImuQuaternion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImuQuaternion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImuQuaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:ImuQuaternion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&qx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&qw_) -
      reinterpret_cast<char*>(&qx_)) + sizeof(qw_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImuQuaternion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float qx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          qx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float qy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          qy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float qz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          qz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float qw = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          qw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImuQuaternion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ImuQuaternion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float qx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qx = this->_internal_qx();
  uint32_t raw_qx;
  memcpy(&raw_qx, &tmp_qx, sizeof(tmp_qx));
  if (raw_qx != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_qx(), target);
  }

  // float qy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qy = this->_internal_qy();
  uint32_t raw_qy;
  memcpy(&raw_qy, &tmp_qy, sizeof(tmp_qy));
  if (raw_qy != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_qy(), target);
  }

  // float qz = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qz = this->_internal_qz();
  uint32_t raw_qz;
  memcpy(&raw_qz, &tmp_qz, sizeof(tmp_qz));
  if (raw_qz != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_qz(), target);
  }

  // float qw = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qw = this->_internal_qw();
  uint32_t raw_qw;
  memcpy(&raw_qw, &tmp_qw, sizeof(tmp_qw));
  if (raw_qw != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_qw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ImuQuaternion)
  return target;
}

size_t ImuQuaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ImuQuaternion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float qx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qx = this->_internal_qx();
  uint32_t raw_qx;
  memcpy(&raw_qx, &tmp_qx, sizeof(tmp_qx));
  if (raw_qx != 0) {
    total_size += 1 + 4;
  }

  // float qy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qy = this->_internal_qy();
  uint32_t raw_qy;
  memcpy(&raw_qy, &tmp_qy, sizeof(tmp_qy));
  if (raw_qy != 0) {
    total_size += 1 + 4;
  }

  // float qz = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qz = this->_internal_qz();
  uint32_t raw_qz;
  memcpy(&raw_qz, &tmp_qz, sizeof(tmp_qz));
  if (raw_qz != 0) {
    total_size += 1 + 4;
  }

  // float qw = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qw = this->_internal_qw();
  uint32_t raw_qw;
  memcpy(&raw_qw, &tmp_qw, sizeof(tmp_qw));
  if (raw_qw != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImuQuaternion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ImuQuaternion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImuQuaternion::GetClassData() const { return &_class_data_; }

void ImuQuaternion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ImuQuaternion *>(to)->MergeFrom(
      static_cast<const ImuQuaternion &>(from));
}


void ImuQuaternion::MergeFrom(const ImuQuaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ImuQuaternion)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qx = from._internal_qx();
  uint32_t raw_qx;
  memcpy(&raw_qx, &tmp_qx, sizeof(tmp_qx));
  if (raw_qx != 0) {
    _internal_set_qx(from._internal_qx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qy = from._internal_qy();
  uint32_t raw_qy;
  memcpy(&raw_qy, &tmp_qy, sizeof(tmp_qy));
  if (raw_qy != 0) {
    _internal_set_qy(from._internal_qy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qz = from._internal_qz();
  uint32_t raw_qz;
  memcpy(&raw_qz, &tmp_qz, sizeof(tmp_qz));
  if (raw_qz != 0) {
    _internal_set_qz(from._internal_qz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_qw = from._internal_qw();
  uint32_t raw_qw;
  memcpy(&raw_qw, &tmp_qw, sizeof(tmp_qw));
  if (raw_qw != 0) {
    _internal_set_qw(from._internal_qw());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImuQuaternion::CopyFrom(const ImuQuaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ImuQuaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuQuaternion::IsInitialized() const {
  return true;
}

void ImuQuaternion::InternalSwap(ImuQuaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImuQuaternion, qw_)
      + sizeof(ImuQuaternion::qw_)
      - PROTOBUF_FIELD_OFFSET(ImuQuaternion, qx_)>(
          reinterpret_cast<char*>(&qx_),
          reinterpret_cast<char*>(&other->qx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImuQuaternion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[25]);
}

// ===================================================================

class ImuData::_Internal {
 public:
  static const ::ImuAcceleration& acceleration(const ImuData* msg);
  static const ::ImuAngularVelocity& angular_velocity(const ImuData* msg);
  static const ::ImuQuaternion& quaternion(const ImuData* msg);
};

const ::ImuAcceleration&
ImuData::_Internal::acceleration(const ImuData* msg) {
  return *msg->acceleration_;
}
const ::ImuAngularVelocity&
ImuData::_Internal::angular_velocity(const ImuData* msg) {
  return *msg->angular_velocity_;
}
const ::ImuQuaternion&
ImuData::_Internal::quaternion(const ImuData* msg) {
  return *msg->quaternion_;
}
ImuData::ImuData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ImuData)
}
ImuData::ImuData(const ImuData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_acceleration()) {
    acceleration_ = new ::ImuAcceleration(*from.acceleration_);
  } else {
    acceleration_ = nullptr;
  }
  if (from._internal_has_angular_velocity()) {
    angular_velocity_ = new ::ImuAngularVelocity(*from.angular_velocity_);
  } else {
    angular_velocity_ = nullptr;
  }
  if (from._internal_has_quaternion()) {
    quaternion_ = new ::ImuQuaternion(*from.quaternion_);
  } else {
    quaternion_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ImuData)
}

inline void ImuData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&acceleration_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&quaternion_) -
    reinterpret_cast<char*>(&acceleration_)) + sizeof(quaternion_));
}

ImuData::~ImuData() {
  // @@protoc_insertion_point(destructor:ImuData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ImuData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete acceleration_;
  if (this != internal_default_instance()) delete angular_velocity_;
  if (this != internal_default_instance()) delete quaternion_;
}

void ImuData::ArenaDtor(void* object) {
  ImuData* _this = reinterpret_cast< ImuData* >(object);
  (void)_this;
}
void ImuData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ImuData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImuData::Clear() {
// @@protoc_insertion_point(message_clear_start:ImuData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && acceleration_ != nullptr) {
    delete acceleration_;
  }
  acceleration_ = nullptr;
  if (GetArenaForAllocation() == nullptr && angular_velocity_ != nullptr) {
    delete angular_velocity_;
  }
  angular_velocity_ = nullptr;
  if (GetArenaForAllocation() == nullptr && quaternion_ != nullptr) {
    delete quaternion_;
  }
  quaternion_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImuData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .ImuAcceleration acceleration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ImuAngularVelocity angular_velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angular_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ImuQuaternion quaternion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_quaternion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImuData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ImuData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .ImuAcceleration acceleration = 1;
  if (this->_internal_has_acceleration()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::acceleration(this), target, stream);
  }

  // .ImuAngularVelocity angular_velocity = 2;
  if (this->_internal_has_angular_velocity()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::angular_velocity(this), target, stream);
  }

  // .ImuQuaternion quaternion = 3;
  if (this->_internal_has_quaternion()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::quaternion(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ImuData)
  return target;
}

size_t ImuData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ImuData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ImuAcceleration acceleration = 1;
  if (this->_internal_has_acceleration()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *acceleration_);
  }

  // .ImuAngularVelocity angular_velocity = 2;
  if (this->_internal_has_angular_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *angular_velocity_);
  }

  // .ImuQuaternion quaternion = 3;
  if (this->_internal_has_quaternion()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *quaternion_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImuData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ImuData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImuData::GetClassData() const { return &_class_data_; }

void ImuData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ImuData *>(to)->MergeFrom(
      static_cast<const ImuData &>(from));
}


void ImuData::MergeFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ImuData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_acceleration()) {
    _internal_mutable_acceleration()->::ImuAcceleration::MergeFrom(from._internal_acceleration());
  }
  if (from._internal_has_angular_velocity()) {
    _internal_mutable_angular_velocity()->::ImuAngularVelocity::MergeFrom(from._internal_angular_velocity());
  }
  if (from._internal_has_quaternion()) {
    _internal_mutable_quaternion()->::ImuQuaternion::MergeFrom(from._internal_quaternion());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImuData::CopyFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuData::IsInitialized() const {
  return true;
}

void ImuData::InternalSwap(ImuData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImuData, quaternion_)
      + sizeof(ImuData::quaternion_)
      - PROTOBUF_FIELD_OFFSET(ImuData, acceleration_)>(
          reinterpret_cast<char*>(&acceleration_),
          reinterpret_cast<char*>(&other->acceleration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImuData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[26]);
}

// ===================================================================

class ParkingStopDetail::_Internal {
 public:
};

ParkingStopDetail::ParkingStopDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ParkingStopDetail)
}
ParkingStopDetail::ParkingStopDetail(const ParkingStopDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_reason().empty()) {
    reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_reason(), 
      GetArenaForAllocation());
  }
  ::memcpy(&category_, &from.category_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_remotely_clearable_) -
    reinterpret_cast<char*>(&category_)) + sizeof(is_remotely_clearable_));
  // @@protoc_insertion_point(copy_constructor:ParkingStopDetail)
}

inline void ParkingStopDetail::SharedCtor() {
reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&category_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_remotely_clearable_) -
    reinterpret_cast<char*>(&category_)) + sizeof(is_remotely_clearable_));
}

ParkingStopDetail::~ParkingStopDetail() {
  // @@protoc_insertion_point(destructor:ParkingStopDetail)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ParkingStopDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  reason_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ParkingStopDetail::ArenaDtor(void* object) {
  ParkingStopDetail* _this = reinterpret_cast< ParkingStopDetail* >(object);
  (void)_this;
}
void ParkingStopDetail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ParkingStopDetail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ParkingStopDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:ParkingStopDetail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reason_.ClearToEmpty();
  ::memset(&category_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_remotely_clearable_) -
      reinterpret_cast<char*>(&category_)) + sizeof(is_remotely_clearable_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParkingStopDetail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_reason();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ParkingStopDetail.reason"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ParkingStopCategory category = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_category(static_cast<::ParkingStopCategory>(val));
        } else
          goto handle_unusual;
        continue;
      // bool is_remotely_clearable = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          is_remotely_clearable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ParkingStopDetail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ParkingStopDetail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string reason = 1;
  if (!this->_internal_reason().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_reason().data(), static_cast<int>(this->_internal_reason().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ParkingStopDetail.reason");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_reason(), target);
  }

  // .ParkingStopCategory category = 2;
  if (this->_internal_category() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_category(), target);
  }

  // bool is_remotely_clearable = 3;
  if (this->_internal_is_remotely_clearable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_remotely_clearable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ParkingStopDetail)
  return target;
}

size_t ParkingStopDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ParkingStopDetail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string reason = 1;
  if (!this->_internal_reason().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_reason());
  }

  // .ParkingStopCategory category = 2;
  if (this->_internal_category() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_category());
  }

  // bool is_remotely_clearable = 3;
  if (this->_internal_is_remotely_clearable() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParkingStopDetail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ParkingStopDetail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParkingStopDetail::GetClassData() const { return &_class_data_; }

void ParkingStopDetail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ParkingStopDetail *>(to)->MergeFrom(
      static_cast<const ParkingStopDetail &>(from));
}


void ParkingStopDetail::MergeFrom(const ParkingStopDetail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ParkingStopDetail)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_reason().empty()) {
    _internal_set_reason(from._internal_reason());
  }
  if (from._internal_category() != 0) {
    _internal_set_category(from._internal_category());
  }
  if (from._internal_is_remotely_clearable() != 0) {
    _internal_set_is_remotely_clearable(from._internal_is_remotely_clearable());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ParkingStopDetail::CopyFrom(const ParkingStopDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ParkingStopDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkingStopDetail::IsInitialized() const {
  return true;
}

void ParkingStopDetail::InternalSwap(ParkingStopDetail* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &reason_, lhs_arena,
      &other->reason_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ParkingStopDetail, is_remotely_clearable_)
      + sizeof(ParkingStopDetail::is_remotely_clearable_)
      - PROTOBUF_FIELD_OFFSET(ParkingStopDetail, category_)>(
          reinterpret_cast<char*>(&category_),
          reinterpret_cast<char*>(&other->category_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ParkingStopDetail::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[27]);
}

// ===================================================================

class SingleMotorTarget::_Internal {
 public:
  static const ::MitMotorTarget& mit_target(const SingleMotorTarget* msg);
};

const ::MitMotorTarget&
SingleMotorTarget::_Internal::mit_target(const SingleMotorTarget* msg) {
  return *msg->target_.mit_target_;
}
void SingleMotorTarget::set_allocated_mit_target(::MitMotorTarget* mit_target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_target();
  if (mit_target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MitMotorTarget>::GetOwningArena(mit_target);
    if (message_arena != submessage_arena) {
      mit_target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mit_target, submessage_arena);
    }
    set_has_mit_target();
    target_.mit_target_ = mit_target;
  }
  // @@protoc_insertion_point(field_set_allocated:SingleMotorTarget.mit_target)
}
SingleMotorTarget::SingleMotorTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SingleMotorTarget)
}
SingleMotorTarget::SingleMotorTarget(const SingleMotorTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_target();
  switch (from.target_case()) {
    case kTorque: {
      _internal_set_torque(from._internal_torque());
      break;
    }
    case kSpeed: {
      _internal_set_speed(from._internal_speed());
      break;
    }
    case kPosition: {
      _internal_set_position(from._internal_position());
      break;
    }
    case kBrake: {
      _internal_set_brake(from._internal_brake());
      break;
    }
    case kMitTarget: {
      _internal_mutable_mit_target()->::MitMotorTarget::MergeFrom(from._internal_mit_target());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SingleMotorTarget)
}

inline void SingleMotorTarget::SharedCtor() {
clear_has_target();
}

SingleMotorTarget::~SingleMotorTarget() {
  // @@protoc_insertion_point(destructor:SingleMotorTarget)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SingleMotorTarget::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_target()) {
    clear_target();
  }
}

void SingleMotorTarget::ArenaDtor(void* object) {
  SingleMotorTarget* _this = reinterpret_cast< SingleMotorTarget* >(object);
  (void)_this;
}
void SingleMotorTarget::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SingleMotorTarget::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SingleMotorTarget::clear_target() {
// @@protoc_insertion_point(one_of_clear_start:SingleMotorTarget)
  switch (target_case()) {
    case kTorque: {
      // No need to clear
      break;
    }
    case kSpeed: {
      // No need to clear
      break;
    }
    case kPosition: {
      // No need to clear
      break;
    }
    case kBrake: {
      // No need to clear
      break;
    }
    case kMitTarget: {
      if (GetArenaForAllocation() == nullptr) {
        delete target_.mit_target_;
      }
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TARGET_NOT_SET;
}


void SingleMotorTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:SingleMotorTarget)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_target();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SingleMotorTarget::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double torque = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _internal_set_torque(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _internal_set_speed(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_position(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool brake = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_brake(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .MitMotorTarget mit_target = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mit_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SingleMotorTarget::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SingleMotorTarget)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double torque = 1;
  if (_internal_has_torque()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_torque(), target);
  }

  // double speed = 2;
  if (_internal_has_speed()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_speed(), target);
  }

  // int64 position = 3;
  if (_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_position(), target);
  }

  // bool brake = 4;
  if (_internal_has_brake()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_brake(), target);
  }

  // .MitMotorTarget mit_target = 5;
  if (_internal_has_mit_target()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::mit_target(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SingleMotorTarget)
  return target;
}

size_t SingleMotorTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SingleMotorTarget)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (target_case()) {
    // double torque = 1;
    case kTorque: {
      total_size += 1 + 8;
      break;
    }
    // double speed = 2;
    case kSpeed: {
      total_size += 1 + 8;
      break;
    }
    // int64 position = 3;
    case kPosition: {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_position());
      break;
    }
    // bool brake = 4;
    case kBrake: {
      total_size += 1 + 1;
      break;
    }
    // .MitMotorTarget mit_target = 5;
    case kMitTarget: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *target_.mit_target_);
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SingleMotorTarget::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SingleMotorTarget::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SingleMotorTarget::GetClassData() const { return &_class_data_; }

void SingleMotorTarget::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SingleMotorTarget *>(to)->MergeFrom(
      static_cast<const SingleMotorTarget &>(from));
}


void SingleMotorTarget::MergeFrom(const SingleMotorTarget& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SingleMotorTarget)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.target_case()) {
    case kTorque: {
      _internal_set_torque(from._internal_torque());
      break;
    }
    case kSpeed: {
      _internal_set_speed(from._internal_speed());
      break;
    }
    case kPosition: {
      _internal_set_position(from._internal_position());
      break;
    }
    case kBrake: {
      _internal_set_brake(from._internal_brake());
      break;
    }
    case kMitTarget: {
      _internal_mutable_mit_target()->::MitMotorTarget::MergeFrom(from._internal_mit_target());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SingleMotorTarget::CopyFrom(const SingleMotorTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SingleMotorTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleMotorTarget::IsInitialized() const {
  return true;
}

void SingleMotorTarget::InternalSwap(SingleMotorTarget* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(target_, other->target_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SingleMotorTarget::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[28]);
}

// ===================================================================

class MitMotorTarget::_Internal {
 public:
};

MitMotorTarget::MitMotorTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:MitMotorTarget)
}
MitMotorTarget::MitMotorTarget(const MitMotorTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&torque_, &from.torque_,
    static_cast<size_t>(reinterpret_cast<char*>(&kd_) -
    reinterpret_cast<char*>(&torque_)) + sizeof(kd_));
  // @@protoc_insertion_point(copy_constructor:MitMotorTarget)
}

inline void MitMotorTarget::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&torque_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&kd_) -
    reinterpret_cast<char*>(&torque_)) + sizeof(kd_));
}

MitMotorTarget::~MitMotorTarget() {
  // @@protoc_insertion_point(destructor:MitMotorTarget)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MitMotorTarget::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MitMotorTarget::ArenaDtor(void* object) {
  MitMotorTarget* _this = reinterpret_cast< MitMotorTarget* >(object);
  (void)_this;
}
void MitMotorTarget::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MitMotorTarget::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MitMotorTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:MitMotorTarget)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&torque_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&kd_) -
      reinterpret_cast<char*>(&torque_)) + sizeof(kd_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MitMotorTarget::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double torque = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          torque_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          position_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double kp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          kp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double kd = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          kd_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MitMotorTarget::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MitMotorTarget)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double torque = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_torque = this->_internal_torque();
  uint64_t raw_torque;
  memcpy(&raw_torque, &tmp_torque, sizeof(tmp_torque));
  if (raw_torque != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_torque(), target);
  }

  // double speed = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_speed(), target);
  }

  // double position = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position = this->_internal_position();
  uint64_t raw_position;
  memcpy(&raw_position, &tmp_position, sizeof(tmp_position));
  if (raw_position != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_position(), target);
  }

  // double kp = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kp = this->_internal_kp();
  uint64_t raw_kp;
  memcpy(&raw_kp, &tmp_kp, sizeof(tmp_kp));
  if (raw_kp != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_kp(), target);
  }

  // double kd = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kd = this->_internal_kd();
  uint64_t raw_kd;
  memcpy(&raw_kd, &tmp_kd, sizeof(tmp_kd));
  if (raw_kd != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(5, this->_internal_kd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MitMotorTarget)
  return target;
}

size_t MitMotorTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MitMotorTarget)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double torque = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_torque = this->_internal_torque();
  uint64_t raw_torque;
  memcpy(&raw_torque, &tmp_torque, sizeof(tmp_torque));
  if (raw_torque != 0) {
    total_size += 1 + 8;
  }

  // double speed = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 8;
  }

  // double position = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position = this->_internal_position();
  uint64_t raw_position;
  memcpy(&raw_position, &tmp_position, sizeof(tmp_position));
  if (raw_position != 0) {
    total_size += 1 + 8;
  }

  // double kp = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kp = this->_internal_kp();
  uint64_t raw_kp;
  memcpy(&raw_kp, &tmp_kp, sizeof(tmp_kp));
  if (raw_kp != 0) {
    total_size += 1 + 8;
  }

  // double kd = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kd = this->_internal_kd();
  uint64_t raw_kd;
  memcpy(&raw_kd, &tmp_kd, sizeof(tmp_kd));
  if (raw_kd != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MitMotorTarget::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MitMotorTarget::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MitMotorTarget::GetClassData() const { return &_class_data_; }

void MitMotorTarget::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MitMotorTarget *>(to)->MergeFrom(
      static_cast<const MitMotorTarget &>(from));
}


void MitMotorTarget::MergeFrom(const MitMotorTarget& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MitMotorTarget)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_torque = from._internal_torque();
  uint64_t raw_torque;
  memcpy(&raw_torque, &tmp_torque, sizeof(tmp_torque));
  if (raw_torque != 0) {
    _internal_set_torque(from._internal_torque());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _internal_set_speed(from._internal_speed());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position = from._internal_position();
  uint64_t raw_position;
  memcpy(&raw_position, &tmp_position, sizeof(tmp_position));
  if (raw_position != 0) {
    _internal_set_position(from._internal_position());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kp = from._internal_kp();
  uint64_t raw_kp;
  memcpy(&raw_kp, &tmp_kp, sizeof(tmp_kp));
  if (raw_kp != 0) {
    _internal_set_kp(from._internal_kp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_kd = from._internal_kd();
  uint64_t raw_kd;
  memcpy(&raw_kd, &tmp_kd, sizeof(tmp_kd));
  if (raw_kd != 0) {
    _internal_set_kd(from._internal_kd());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MitMotorTarget::CopyFrom(const MitMotorTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MitMotorTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MitMotorTarget::IsInitialized() const {
  return true;
}

void MitMotorTarget::InternalSwap(MitMotorTarget* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MitMotorTarget, kd_)
      + sizeof(MitMotorTarget::kd_)
      - PROTOBUF_FIELD_OFFSET(MitMotorTarget, torque_)>(
          reinterpret_cast<char*>(&torque_),
          reinterpret_cast<char*>(&other->torque_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MitMotorTarget::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[29]);
}

// ===================================================================

class MotorTargets::_Internal {
 public:
};

MotorTargets::MotorTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  targets_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:MotorTargets)
}
MotorTargets::MotorTargets(const MotorTargets& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      targets_(from.targets_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:MotorTargets)
}

inline void MotorTargets::SharedCtor() {
}

MotorTargets::~MotorTargets() {
  // @@protoc_insertion_point(destructor:MotorTargets)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MotorTargets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MotorTargets::ArenaDtor(void* object) {
  MotorTargets* _this = reinterpret_cast< MotorTargets* >(object);
  (void)_this;
}
void MotorTargets::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotorTargets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotorTargets::Clear() {
// @@protoc_insertion_point(message_clear_start:MotorTargets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targets_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotorTargets::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .SingleMotorTarget targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotorTargets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MotorTargets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SingleMotorTarget targets = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_targets_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_targets(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MotorTargets)
  return target;
}

size_t MotorTargets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MotorTargets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SingleMotorTarget targets = 1;
  total_size += 1UL * this->_internal_targets_size();
  for (const auto& msg : this->targets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotorTargets::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MotorTargets::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotorTargets::GetClassData() const { return &_class_data_; }

void MotorTargets::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MotorTargets *>(to)->MergeFrom(
      static_cast<const MotorTargets &>(from));
}


void MotorTargets::MergeFrom(const MotorTargets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MotorTargets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targets_.MergeFrom(from.targets_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotorTargets::CopyFrom(const MotorTargets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MotorTargets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorTargets::IsInitialized() const {
  return true;
}

void MotorTargets::InternalSwap(MotorTargets* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targets_.InternalSwap(&other->targets_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotorTargets::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[30]);
}

// ===================================================================

class MotorStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<MotorStatus>()._has_bits_);
  static const ::SingleMotorTarget& current_target(const MotorStatus* msg);
  static void set_has_driver_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_motor_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_voltage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::SingleMotorTarget&
MotorStatus::_Internal::current_target(const MotorStatus* msg) {
  return *msg->current_target_;
}
MotorStatus::MotorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  error_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:MotorStatus)
}
MotorStatus::MotorStatus(const MotorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      error_(from.error_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_current_target()) {
    current_target_ = new ::SingleMotorTarget(*from.current_target_);
  } else {
    current_target_ = nullptr;
  }
  ::memcpy(&torque_, &from.torque_,
    static_cast<size_t>(reinterpret_cast<char*>(&voltage_) -
    reinterpret_cast<char*>(&torque_)) + sizeof(voltage_));
  // @@protoc_insertion_point(copy_constructor:MotorStatus)
}

inline void MotorStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&current_target_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&voltage_) -
    reinterpret_cast<char*>(&current_target_)) + sizeof(voltage_));
}

MotorStatus::~MotorStatus() {
  // @@protoc_insertion_point(destructor:MotorStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MotorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete current_target_;
}

void MotorStatus::ArenaDtor(void* object) {
  MotorStatus* _this = reinterpret_cast< MotorStatus* >(object);
  (void)_this;
}
void MotorStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotorStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:MotorStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_.Clear();
  if (GetArenaForAllocation() == nullptr && current_target_ != nullptr) {
    delete current_target_;
  }
  current_target_ = nullptr;
  ::memset(&torque_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pulse_per_rotation_) -
      reinterpret_cast<char*>(&torque_)) + sizeof(pulse_per_rotation_));
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&driver_temperature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&voltage_) -
        reinterpret_cast<char*>(&driver_temperature_)) + sizeof(voltage_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotorStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double torque = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          torque_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 pulse_per_rotation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          pulse_per_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double wheel_radius = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          wheel_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .MotorError error = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_error(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_error(static_cast<::MotorError>(val));
        } else
          goto handle_unusual;
        continue;
      // .SingleMotorTarget current_target = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_current_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float driver_temperature = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_driver_temperature(&has_bits);
          driver_temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float motor_temperature = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_motor_temperature(&has_bits);
          motor_temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float voltage = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_voltage(&has_bits);
          voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotorStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MotorStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double torque = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_torque = this->_internal_torque();
  uint64_t raw_torque;
  memcpy(&raw_torque, &tmp_torque, sizeof(tmp_torque));
  if (raw_torque != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_torque(), target);
  }

  // double speed = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_speed(), target);
  }

  // int64 position = 4;
  if (this->_internal_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_position(), target);
  }

  // uint32 pulse_per_rotation = 5;
  if (this->_internal_pulse_per_rotation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_pulse_per_rotation(), target);
  }

  // double wheel_radius = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_radius = this->_internal_wheel_radius();
  uint64_t raw_wheel_radius;
  memcpy(&raw_wheel_radius, &tmp_wheel_radius, sizeof(tmp_wheel_radius));
  if (raw_wheel_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(6, this->_internal_wheel_radius(), target);
  }

  // repeated .MotorError error = 7;
  {
    int byte_size = _error_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          7, error_, byte_size, target);
    }
  }

  // .SingleMotorTarget current_target = 8;
  if (this->_internal_has_current_target()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::current_target(this), target, stream);
  }

  // optional float driver_temperature = 11;
  if (_internal_has_driver_temperature()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_driver_temperature(), target);
  }

  // optional float motor_temperature = 12;
  if (_internal_has_motor_temperature()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_motor_temperature(), target);
  }

  // optional float voltage = 13;
  if (_internal_has_voltage()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_voltage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MotorStatus)
  return target;
}

size_t MotorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MotorStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MotorError error = 7;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_error_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_error(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _error_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .SingleMotorTarget current_target = 8;
  if (this->_internal_has_current_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *current_target_);
  }

  // double torque = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_torque = this->_internal_torque();
  uint64_t raw_torque;
  memcpy(&raw_torque, &tmp_torque, sizeof(tmp_torque));
  if (raw_torque != 0) {
    total_size += 1 + 8;
  }

  // double speed = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 8;
  }

  // int64 position = 4;
  if (this->_internal_position() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_position());
  }

  // double wheel_radius = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_radius = this->_internal_wheel_radius();
  uint64_t raw_wheel_radius;
  memcpy(&raw_wheel_radius, &tmp_wheel_radius, sizeof(tmp_wheel_radius));
  if (raw_wheel_radius != 0) {
    total_size += 1 + 8;
  }

  // uint32 pulse_per_rotation = 5;
  if (this->_internal_pulse_per_rotation() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_pulse_per_rotation());
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float driver_temperature = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float motor_temperature = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float voltage = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotorStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MotorStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotorStatus::GetClassData() const { return &_class_data_; }

void MotorStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MotorStatus *>(to)->MergeFrom(
      static_cast<const MotorStatus &>(from));
}


void MotorStatus::MergeFrom(const MotorStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MotorStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  error_.MergeFrom(from.error_);
  if (from._internal_has_current_target()) {
    _internal_mutable_current_target()->::SingleMotorTarget::MergeFrom(from._internal_current_target());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_torque = from._internal_torque();
  uint64_t raw_torque;
  memcpy(&raw_torque, &tmp_torque, sizeof(tmp_torque));
  if (raw_torque != 0) {
    _internal_set_torque(from._internal_torque());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _internal_set_speed(from._internal_speed());
  }
  if (from._internal_position() != 0) {
    _internal_set_position(from._internal_position());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wheel_radius = from._internal_wheel_radius();
  uint64_t raw_wheel_radius;
  memcpy(&raw_wheel_radius, &tmp_wheel_radius, sizeof(tmp_wheel_radius));
  if (raw_wheel_radius != 0) {
    _internal_set_wheel_radius(from._internal_wheel_radius());
  }
  if (from._internal_pulse_per_rotation() != 0) {
    _internal_set_pulse_per_rotation(from._internal_pulse_per_rotation());
  }
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      driver_temperature_ = from.driver_temperature_;
    }
    if (cached_has_bits & 0x00000002u) {
      motor_temperature_ = from.motor_temperature_;
    }
    if (cached_has_bits & 0x00000004u) {
      voltage_ = from.voltage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotorStatus::CopyFrom(const MotorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MotorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorStatus::IsInitialized() const {
  return true;
}

void MotorStatus::InternalSwap(MotorStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  error_.InternalSwap(&other->error_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotorStatus, voltage_)
      + sizeof(MotorStatus::voltage_)
      - PROTOBUF_FIELD_OFFSET(MotorStatus, current_target_)>(
          reinterpret_cast<char*>(&current_target_),
          reinterpret_cast<char*>(&other->current_target_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotorStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[31]);
}

// ===================================================================

class SecondaryDeviceStatus::_Internal {
 public:
  static const ::ImuData& imu_data(const SecondaryDeviceStatus* msg);
  static const ::HandStatus& hand_status(const SecondaryDeviceStatus* msg);
  static const ::GamepadRead& gamepad_read(const SecondaryDeviceStatus* msg);
};

const ::ImuData&
SecondaryDeviceStatus::_Internal::imu_data(const SecondaryDeviceStatus* msg) {
  return *msg->status_.imu_data_;
}
const ::HandStatus&
SecondaryDeviceStatus::_Internal::hand_status(const SecondaryDeviceStatus* msg) {
  return *msg->status_.hand_status_;
}
const ::GamepadRead&
SecondaryDeviceStatus::_Internal::gamepad_read(const SecondaryDeviceStatus* msg) {
  return *msg->status_.gamepad_read_;
}
void SecondaryDeviceStatus::set_allocated_imu_data(::ImuData* imu_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_status();
  if (imu_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ImuData>::GetOwningArena(imu_data);
    if (message_arena != submessage_arena) {
      imu_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imu_data, submessage_arena);
    }
    set_has_imu_data();
    status_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_set_allocated:SecondaryDeviceStatus.imu_data)
}
void SecondaryDeviceStatus::set_allocated_hand_status(::HandStatus* hand_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_status();
  if (hand_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HandStatus>::GetOwningArena(hand_status);
    if (message_arena != submessage_arena) {
      hand_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hand_status, submessage_arena);
    }
    set_has_hand_status();
    status_.hand_status_ = hand_status;
  }
  // @@protoc_insertion_point(field_set_allocated:SecondaryDeviceStatus.hand_status)
}
void SecondaryDeviceStatus::set_allocated_gamepad_read(::GamepadRead* gamepad_read) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_status();
  if (gamepad_read) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GamepadRead>::GetOwningArena(gamepad_read);
    if (message_arena != submessage_arena) {
      gamepad_read = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamepad_read, submessage_arena);
    }
    set_has_gamepad_read();
    status_.gamepad_read_ = gamepad_read;
  }
  // @@protoc_insertion_point(field_set_allocated:SecondaryDeviceStatus.gamepad_read)
}
SecondaryDeviceStatus::SecondaryDeviceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SecondaryDeviceStatus)
}
SecondaryDeviceStatus::SecondaryDeviceStatus(const SecondaryDeviceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&device_id_, &from.device_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_type_) -
    reinterpret_cast<char*>(&device_id_)) + sizeof(device_type_));
  clear_has_status();
  switch (from.status_case()) {
    case kImuData: {
      _internal_mutable_imu_data()->::ImuData::MergeFrom(from._internal_imu_data());
      break;
    }
    case kHandStatus: {
      _internal_mutable_hand_status()->::HandStatus::MergeFrom(from._internal_hand_status());
      break;
    }
    case kGamepadRead: {
      _internal_mutable_gamepad_read()->::GamepadRead::MergeFrom(from._internal_gamepad_read());
      break;
    }
    case STATUS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SecondaryDeviceStatus)
}

inline void SecondaryDeviceStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&device_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_type_) -
    reinterpret_cast<char*>(&device_id_)) + sizeof(device_type_));
clear_has_status();
}

SecondaryDeviceStatus::~SecondaryDeviceStatus() {
  // @@protoc_insertion_point(destructor:SecondaryDeviceStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SecondaryDeviceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_status()) {
    clear_status();
  }
}

void SecondaryDeviceStatus::ArenaDtor(void* object) {
  SecondaryDeviceStatus* _this = reinterpret_cast< SecondaryDeviceStatus* >(object);
  (void)_this;
}
void SecondaryDeviceStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SecondaryDeviceStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SecondaryDeviceStatus::clear_status() {
// @@protoc_insertion_point(one_of_clear_start:SecondaryDeviceStatus)
  switch (status_case()) {
    case kImuData: {
      if (GetArenaForAllocation() == nullptr) {
        delete status_.imu_data_;
      }
      break;
    }
    case kHandStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete status_.hand_status_;
      }
      break;
    }
    case kGamepadRead: {
      if (GetArenaForAllocation() == nullptr) {
        delete status_.gamepad_read_;
      }
      break;
    }
    case STATUS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = STATUS_NOT_SET;
}


void SecondaryDeviceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:SecondaryDeviceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&device_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&device_type_) -
      reinterpret_cast<char*>(&device_id_)) + sizeof(device_type_));
  clear_status();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecondaryDeviceStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 device_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .SecondaryDeviceType device_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_device_type(static_cast<::SecondaryDeviceType>(val));
        } else
          goto handle_unusual;
        continue;
      // .ImuData imu_data = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_imu_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HandStatus hand_status = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_hand_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .GamepadRead gamepad_read = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_gamepad_read(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecondaryDeviceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SecondaryDeviceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 device_id = 1;
  if (this->_internal_device_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_device_id(), target);
  }

  // .SecondaryDeviceType device_type = 2;
  if (this->_internal_device_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_device_type(), target);
  }

  // .ImuData imu_data = 11;
  if (_internal_has_imu_data()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::imu_data(this), target, stream);
  }

  // .HandStatus hand_status = 12;
  if (_internal_has_hand_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::hand_status(this), target, stream);
  }

  // .GamepadRead gamepad_read = 13;
  if (_internal_has_gamepad_read()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::gamepad_read(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SecondaryDeviceStatus)
  return target;
}

size_t SecondaryDeviceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SecondaryDeviceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 device_id = 1;
  if (this->_internal_device_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_device_id());
  }

  // .SecondaryDeviceType device_type = 2;
  if (this->_internal_device_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_device_type());
  }

  switch (status_case()) {
    // .ImuData imu_data = 11;
    case kImuData: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_.imu_data_);
      break;
    }
    // .HandStatus hand_status = 12;
    case kHandStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_.hand_status_);
      break;
    }
    // .GamepadRead gamepad_read = 13;
    case kGamepadRead: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_.gamepad_read_);
      break;
    }
    case STATUS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecondaryDeviceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SecondaryDeviceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecondaryDeviceStatus::GetClassData() const { return &_class_data_; }

void SecondaryDeviceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SecondaryDeviceStatus *>(to)->MergeFrom(
      static_cast<const SecondaryDeviceStatus &>(from));
}


void SecondaryDeviceStatus::MergeFrom(const SecondaryDeviceStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SecondaryDeviceStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_device_id() != 0) {
    _internal_set_device_id(from._internal_device_id());
  }
  if (from._internal_device_type() != 0) {
    _internal_set_device_type(from._internal_device_type());
  }
  switch (from.status_case()) {
    case kImuData: {
      _internal_mutable_imu_data()->::ImuData::MergeFrom(from._internal_imu_data());
      break;
    }
    case kHandStatus: {
      _internal_mutable_hand_status()->::HandStatus::MergeFrom(from._internal_hand_status());
      break;
    }
    case kGamepadRead: {
      _internal_mutable_gamepad_read()->::GamepadRead::MergeFrom(from._internal_gamepad_read());
      break;
    }
    case STATUS_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecondaryDeviceStatus::CopyFrom(const SecondaryDeviceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SecondaryDeviceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecondaryDeviceStatus::IsInitialized() const {
  return true;
}

void SecondaryDeviceStatus::InternalSwap(SecondaryDeviceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SecondaryDeviceStatus, device_type_)
      + sizeof(SecondaryDeviceStatus::device_type_)
      - PROTOBUF_FIELD_OFFSET(SecondaryDeviceStatus, device_id_)>(
          reinterpret_cast<char*>(&device_id_),
          reinterpret_cast<char*>(&other->device_id_));
  swap(status_, other->status_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecondaryDeviceStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[32]);
}

// ===================================================================

class SecondaryDeviceCommand::_Internal {
 public:
  static const ::HandCommand& hand_command(const SecondaryDeviceCommand* msg);
};

const ::HandCommand&
SecondaryDeviceCommand::_Internal::hand_command(const SecondaryDeviceCommand* msg) {
  return *msg->command_.hand_command_;
}
void SecondaryDeviceCommand::set_allocated_hand_command(::HandCommand* hand_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_command();
  if (hand_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HandCommand>::GetOwningArena(hand_command);
    if (message_arena != submessage_arena) {
      hand_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hand_command, submessage_arena);
    }
    set_has_hand_command();
    command_.hand_command_ = hand_command;
  }
  // @@protoc_insertion_point(field_set_allocated:SecondaryDeviceCommand.hand_command)
}
SecondaryDeviceCommand::SecondaryDeviceCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SecondaryDeviceCommand)
}
SecondaryDeviceCommand::SecondaryDeviceCommand(const SecondaryDeviceCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_id_ = from.device_id_;
  clear_has_command();
  switch (from.command_case()) {
    case kHandCommand: {
      _internal_mutable_hand_command()->::HandCommand::MergeFrom(from._internal_hand_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SecondaryDeviceCommand)
}

inline void SecondaryDeviceCommand::SharedCtor() {
device_id_ = 0u;
clear_has_command();
}

SecondaryDeviceCommand::~SecondaryDeviceCommand() {
  // @@protoc_insertion_point(destructor:SecondaryDeviceCommand)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SecondaryDeviceCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void SecondaryDeviceCommand::ArenaDtor(void* object) {
  SecondaryDeviceCommand* _this = reinterpret_cast< SecondaryDeviceCommand* >(object);
  (void)_this;
}
void SecondaryDeviceCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SecondaryDeviceCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SecondaryDeviceCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:SecondaryDeviceCommand)
  switch (command_case()) {
    case kHandCommand: {
      if (GetArenaForAllocation() == nullptr) {
        delete command_.hand_command_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void SecondaryDeviceCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:SecondaryDeviceCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_id_ = 0u;
  clear_command();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SecondaryDeviceCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 device_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HandCommand hand_command = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_hand_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SecondaryDeviceCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SecondaryDeviceCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 device_id = 1;
  if (this->_internal_device_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_device_id(), target);
  }

  // .HandCommand hand_command = 12;
  if (_internal_has_hand_command()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::hand_command(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SecondaryDeviceCommand)
  return target;
}

size_t SecondaryDeviceCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SecondaryDeviceCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 device_id = 1;
  if (this->_internal_device_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_device_id());
  }

  switch (command_case()) {
    // .HandCommand hand_command = 12;
    case kHandCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.hand_command_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SecondaryDeviceCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SecondaryDeviceCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SecondaryDeviceCommand::GetClassData() const { return &_class_data_; }

void SecondaryDeviceCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SecondaryDeviceCommand *>(to)->MergeFrom(
      static_cast<const SecondaryDeviceCommand &>(from));
}


void SecondaryDeviceCommand::MergeFrom(const SecondaryDeviceCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SecondaryDeviceCommand)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_device_id() != 0) {
    _internal_set_device_id(from._internal_device_id());
  }
  switch (from.command_case()) {
    case kHandCommand: {
      _internal_mutable_hand_command()->::HandCommand::MergeFrom(from._internal_hand_command());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SecondaryDeviceCommand::CopyFrom(const SecondaryDeviceCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SecondaryDeviceCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecondaryDeviceCommand::IsInitialized() const {
  return true;
}

void SecondaryDeviceCommand::InternalSwap(SecondaryDeviceCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(device_id_, other->device_id_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SecondaryDeviceCommand::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_public_5fapi_5ftypes_2eproto_getter, &descriptor_table_public_5fapi_5ftypes_2eproto_once,
      file_level_metadata_public_5fapi_5ftypes_2eproto[33]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::BaseEstimatedOdometry* Arena::CreateMaybeMessage< ::BaseEstimatedOdometry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BaseEstimatedOdometry >(arena);
}
template<> PROTOBUF_NOINLINE ::BaseStatus* Arena::CreateMaybeMessage< ::BaseStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BaseStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::XyzSpeed* Arena::CreateMaybeMessage< ::XyzSpeed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::XyzSpeed >(arena);
}
template<> PROTOBUF_NOINLINE ::SimpleBaseMoveCommand* Arena::CreateMaybeMessage< ::SimpleBaseMoveCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SimpleBaseMoveCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::BaseCommand* Arena::CreateMaybeMessage< ::BaseCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BaseCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::RotateLiftStatus* Arena::CreateMaybeMessage< ::RotateLiftStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RotateLiftStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::RotateLiftRuntimeConfig* Arena::CreateMaybeMessage< ::RotateLiftRuntimeConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RotateLiftRuntimeConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::RotateLiftCommand* Arena::CreateMaybeMessage< ::RotateLiftCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RotateLiftCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::LinearLiftStatus* Arena::CreateMaybeMessage< ::LinearLiftStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LinearLiftStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::LinearLiftCommand* Arena::CreateMaybeMessage< ::LinearLiftCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LinearLiftCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ArmStatus* Arena::CreateMaybeMessage< ::ArmStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ArmStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::HandStatus* Arena::CreateMaybeMessage< ::HandStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HandStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::HandCommand* Arena::CreateMaybeMessage< ::HandCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HandCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ArmApiFreeDragCommand* Arena::CreateMaybeMessage< ::ArmApiFreeDragCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ArmApiFreeDragCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ArmApiZeroCurrentCommand* Arena::CreateMaybeMessage< ::ArmApiZeroCurrentCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ArmApiZeroCurrentCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ArmApiControlCommand* Arena::CreateMaybeMessage< ::ArmApiControlCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ArmApiControlCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ArmSharedCommand* Arena::CreateMaybeMessage< ::ArmSharedCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ArmSharedCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ArmExclusiveCommand* Arena::CreateMaybeMessage< ::ArmExclusiveCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ArmExclusiveCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ArmCommand* Arena::CreateMaybeMessage< ::ArmCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ArmCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::GamepadRead* Arena::CreateMaybeMessage< ::GamepadRead >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GamepadRead >(arena);
}
template<> PROTOBUF_NOINLINE ::EnableKcp* Arena::CreateMaybeMessage< ::EnableKcp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::EnableKcp >(arena);
}
template<> PROTOBUF_NOINLINE ::KcpServerStatus* Arena::CreateMaybeMessage< ::KcpServerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::KcpServerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::KcpConfig* Arena::CreateMaybeMessage< ::KcpConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::KcpConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::ImuAcceleration* Arena::CreateMaybeMessage< ::ImuAcceleration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ImuAcceleration >(arena);
}
template<> PROTOBUF_NOINLINE ::ImuAngularVelocity* Arena::CreateMaybeMessage< ::ImuAngularVelocity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ImuAngularVelocity >(arena);
}
template<> PROTOBUF_NOINLINE ::ImuQuaternion* Arena::CreateMaybeMessage< ::ImuQuaternion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ImuQuaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::ImuData* Arena::CreateMaybeMessage< ::ImuData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ImuData >(arena);
}
template<> PROTOBUF_NOINLINE ::ParkingStopDetail* Arena::CreateMaybeMessage< ::ParkingStopDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ParkingStopDetail >(arena);
}
template<> PROTOBUF_NOINLINE ::SingleMotorTarget* Arena::CreateMaybeMessage< ::SingleMotorTarget >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SingleMotorTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::MitMotorTarget* Arena::CreateMaybeMessage< ::MitMotorTarget >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MitMotorTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::MotorTargets* Arena::CreateMaybeMessage< ::MotorTargets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MotorTargets >(arena);
}
template<> PROTOBUF_NOINLINE ::MotorStatus* Arena::CreateMaybeMessage< ::MotorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MotorStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::SecondaryDeviceStatus* Arena::CreateMaybeMessage< ::SecondaryDeviceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SecondaryDeviceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::SecondaryDeviceCommand* Arena::CreateMaybeMessage< ::SecondaryDeviceCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SecondaryDeviceCommand >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

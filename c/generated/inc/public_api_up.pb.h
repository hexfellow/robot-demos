/* Automatically generated nanopb header */
/* Generated by nanopb-1.0.0-dev */

#ifndef PB_PUBLIC_API_UP_PB_H_INCLUDED
#define PB_PUBLIC_API_UP_PB_H_INCLUDED
#include <pb.h>
#include "public_api_types.pb.h"

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Struct definitions */
/* All messages from the robot are in this format.
 Different robot types have different status fields.
 所有机器人发给上位机的消息都是这个格式。
 不同机器人类型有不同的状态字段。 */
typedef struct _APIUp {
    /* This field indicates the robot type.
 这个字段表示机器人类型。 */
    RobotType robot_type;
    pb_size_t which_status;
    union _APIUp_status {
        /* Base robots will use this field.
     底盘机器人会使用这个字段。 */
        BaseStatus base_status;
        /* Linear lifts will use this field.
     线性升降机会使用这个字段。 */
        LinearLiftStatus linear_lift_status;
        /* Arms will use this field.
     机械臂会使用这个字段。 */
        ArmStatus arm_status;
        /* Rotational lifts will use this field.
     旋转升降机会使用这个字段。 */
        RotateLiftStatus rotate_lift_status;
    } status;
    /* Current report frequency. This field is connection independent. A single robot might have multiple websocket connections. Each connection might have a different report frequency.
 当前的报告频率。这个字段与连接无关。一个机器人可能有多个 websocket 连接。每个连接可能有不同的报告频率。 */
    ReportFrequency report_frequency;
    /* Optional log message. Unless you are interested in the log, you can ignore this field.
 可选的日志消息。除非您对日志感兴趣，否则可以忽略这个字段不解析。 */
    pb_callback_t log;
    /* Identifies different websocket connections. Value will not be zero.
 识别不同的 websocket 连接。值不会为零。 */
    uint32_t session_id;
    /* Secondary device status. Optional. Including Imu, Hand, Gamepad, etc.
 次级设备状态。可选。包括 Imu, Hand, Gamepad 等。 */
    pb_callback_t secondary_device_status;
    /* Rolls with potential breaking changes. e.g. Refactoring the message structure, removing deprecated robot types, etc.
 变更意味着 breaking change。 */
    uint32_t protocol_major_version; /* Current value is 1. */
    /* Rolls with potential non-breaking changes. e.g. adding new robot types. */
    uint32_t protocol_minor_version;
    /* If KCP connection is enabled, this field will be present.
 This field will not change after connection is established. */
    bool has_kcp_server_status;
    KcpServerStatus kcp_server_status;
} APIUp;


#ifdef __cplusplus
extern "C" {
#endif

/* Initializer values for message structs */
#define APIUp_init_default                       {_RobotType_MIN, 0, {BaseStatus_init_default}, _ReportFrequency_MIN, {{NULL}, NULL}, 0, {{NULL}, NULL}, 0, 0, false, KcpServerStatus_init_default}
#define APIUp_init_zero                          {_RobotType_MIN, 0, {BaseStatus_init_zero}, _ReportFrequency_MIN, {{NULL}, NULL}, 0, {{NULL}, NULL}, 0, 0, false, KcpServerStatus_init_zero}

/* Field tags (for use in manual encoding/decoding) */
#define APIUp_robot_type_tag                     1
#define APIUp_base_status_tag                    2
#define APIUp_linear_lift_status_tag             3
#define APIUp_arm_status_tag                     4
#define APIUp_rotate_lift_status_tag             5
#define APIUp_report_frequency_tag               12
#define APIUp_log_tag                            14
#define APIUp_session_id_tag                     15
#define APIUp_secondary_device_status_tag        16
#define APIUp_protocol_major_version_tag         17
#define APIUp_protocol_minor_version_tag         18
#define APIUp_kcp_server_status_tag              19

/* Struct field encoding specification for nanopb */
#define APIUp_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UENUM,    robot_type,        1) \
X(a, STATIC,   ONEOF,    MESSAGE,  (status,base_status,status.base_status),   2) \
X(a, STATIC,   ONEOF,    MESSAGE,  (status,linear_lift_status,status.linear_lift_status),   3) \
X(a, STATIC,   ONEOF,    MESSAGE,  (status,arm_status,status.arm_status),   4) \
X(a, STATIC,   ONEOF,    MESSAGE,  (status,rotate_lift_status,status.rotate_lift_status),   5) \
X(a, STATIC,   SINGULAR, UENUM,    report_frequency,  12) \
X(a, CALLBACK, OPTIONAL, STRING,   log,              14) \
X(a, STATIC,   SINGULAR, UINT32,   session_id,       15) \
X(a, CALLBACK, REPEATED, MESSAGE,  secondary_device_status,  16) \
X(a, STATIC,   SINGULAR, UINT32,   protocol_major_version,  17) \
X(a, STATIC,   SINGULAR, UINT32,   protocol_minor_version,  18) \
X(a, STATIC,   OPTIONAL, MESSAGE,  kcp_server_status,  19)
#define APIUp_CALLBACK pb_default_field_callback
#define APIUp_DEFAULT NULL
#define APIUp_status_base_status_MSGTYPE BaseStatus
#define APIUp_status_linear_lift_status_MSGTYPE LinearLiftStatus
#define APIUp_status_arm_status_MSGTYPE ArmStatus
#define APIUp_status_rotate_lift_status_MSGTYPE RotateLiftStatus
#define APIUp_secondary_device_status_MSGTYPE SecondaryDeviceStatus
#define APIUp_kcp_server_status_MSGTYPE KcpServerStatus

extern const pb_msgdesc_t APIUp_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define APIUp_fields &APIUp_msg

/* Maximum encoded size of messages (where known) */
#if defined(BaseStatus_size) && defined(LinearLiftStatus_size) && defined(ArmStatus_size) && defined(RotateLiftStatus_size)
union APIUp_status_size_union {char f2[(6 + BaseStatus_size)]; char f3[(6 + LinearLiftStatus_size)]; char f4[(6 + ArmStatus_size)]; char f5[(6 + RotateLiftStatus_size)];};
#endif
/* APIUp_size depends on runtime parameters */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif

/* Automatically generated nanopb header */
/* Generated by nanopb-1.0.0-dev */

#ifndef PB_PUBLIC_API_DOWN_PB_H_INCLUDED
#define PB_PUBLIC_API_DOWN_PB_H_INCLUDED
#include <pb.h>
#include "public_api_types.pb.h"

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Struct definitions */
/* All messages sent to the robot are in this format.
 Different robot types have different command fields.
 所有发送给机器人的消息都是这个格式。
 不同机器人类型有不同的命令字段。 */
typedef struct _APIDown {
    pb_size_t which_down;
    union _APIDown_down {
        /* Base robots will use this field.
     底盘机器人会使用这个字段。 */
        BaseCommand base_command;
        /* Linear lifts will use this field.
     线性升降机会使用这个字段。 */
        LinearLiftCommand linear_lift_command;
        /* Arms will use this field.
     机械臂会使用这个字段。 */
        ArmCommand arm_command;
        /* Rotational lifts will use this field.
     旋转升降机会使用这个字段。 */
        RotateLiftCommand rotate_lift_command;
        /* Sets report frequency for THIS connection. Will not affect other connections.
     设置本连接的报告频率。不会影响其他连接。 */
        ReportFrequency set_report_frequency;
        /* There might be multiple secondary devices. Send commands to different devices separately.
     可能有多台次级设备。请分别发送命令到不同的设备。 */
        SecondaryDeviceCommand secondary_device_command;
        /* Turn On the KCP connection.
     Please remember to change websocket Report Frequency to Rf1Hz, if you want to use KCP.
     And do not kill websocket connection, if you want to use KCP.
     Why? This is learned from https://github.com/skywind3000/kcp/wiki/Cooperate-With-Tcp-Server
     Basically, we consider KCP connection dead, if websocket connection is dead.
     After sending this, and you find kcp_config in APIUp, you can start to send data to the robot using KCP.
     The server will NOT send data before it receives the first message from the client, using KCP. */
        EnableKcp enable_kcp;
        /* This is a placeholder message. This message will be ignored by the server, but server still considers getting stuff from client.
     Can be used to start KCP connection, since server will not start sending until it receives the first message from the client, using KCP. */
        bool placeholder_message;
    } down;
} APIDown;


#ifdef __cplusplus
extern "C" {
#endif

/* Initializer values for message structs */
#define APIDown_init_default                     {0, {BaseCommand_init_default}}
#define APIDown_init_zero                        {0, {BaseCommand_init_zero}}

/* Field tags (for use in manual encoding/decoding) */
#define APIDown_base_command_tag                 1
#define APIDown_linear_lift_command_tag          2
#define APIDown_arm_command_tag                  3
#define APIDown_rotate_lift_command_tag          4
#define APIDown_set_report_frequency_tag         5
#define APIDown_secondary_device_command_tag     7
#define APIDown_enable_kcp_tag                   8
#define APIDown_placeholder_message_tag          100

/* Struct field encoding specification for nanopb */
#define APIDown_FIELDLIST(X, a) \
X(a, STATIC,   ONEOF,    MESSAGE,  (down,base_command,down.base_command),   1) \
X(a, STATIC,   ONEOF,    MESSAGE,  (down,linear_lift_command,down.linear_lift_command),   2) \
X(a, STATIC,   ONEOF,    MESSAGE,  (down,arm_command,down.arm_command),   3) \
X(a, STATIC,   ONEOF,    MESSAGE,  (down,rotate_lift_command,down.rotate_lift_command),   4) \
X(a, STATIC,   ONEOF,    UENUM,    (down,set_report_frequency,down.set_report_frequency),   5) \
X(a, STATIC,   ONEOF,    MESSAGE,  (down,secondary_device_command,down.secondary_device_command),   7) \
X(a, STATIC,   ONEOF,    MESSAGE,  (down,enable_kcp,down.enable_kcp),   8) \
X(a, STATIC,   ONEOF,    BOOL,     (down,placeholder_message,down.placeholder_message), 100)
#define APIDown_CALLBACK NULL
#define APIDown_DEFAULT NULL
#define APIDown_down_base_command_MSGTYPE BaseCommand
#define APIDown_down_linear_lift_command_MSGTYPE LinearLiftCommand
#define APIDown_down_arm_command_MSGTYPE ArmCommand
#define APIDown_down_rotate_lift_command_MSGTYPE RotateLiftCommand
#define APIDown_down_secondary_device_command_MSGTYPE SecondaryDeviceCommand
#define APIDown_down_enable_kcp_MSGTYPE EnableKcp

extern const pb_msgdesc_t APIDown_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define APIDown_fields &APIDown_msg

/* Maximum encoded size of messages (where known) */
#if defined(BaseCommand_size) && defined(ArmCommand_size) && defined(RotateLiftCommand_size) && defined(SecondaryDeviceCommand_size)
union APIDown_down_size_union {char f1[(6 + BaseCommand_size)]; char f3[(6 + ArmCommand_size)]; char f4[(6 + RotateLiftCommand_size)]; char f7[(6 + SecondaryDeviceCommand_size)]; char f0[58];};
#endif
#if defined(BaseCommand_size) && defined(ArmCommand_size) && defined(RotateLiftCommand_size) && defined(SecondaryDeviceCommand_size)
#define APIDown_size                             (0 + sizeof(union APIDown_down_size_union))
#define PUBLIC_API_DOWN_PB_H_MAX_SIZE            APIDown_size
#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
